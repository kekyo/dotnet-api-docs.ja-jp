<Type Name="ModuleBuilder" FullName="System.Reflection.Emit.ModuleBuilder">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="8aa653943eea223728fc458f0aa3a45d649dcafb" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ja-JP" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39924967" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ModuleBuilder : System.Reflection.Module, System.Runtime.InteropServices._ModuleBuilder" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi beforefieldinit ModuleBuilder extends System.Reflection.Module implements class System.Runtime.InteropServices._ModuleBuilder" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.ModuleBuilder" />
  <TypeSignature Language="VB.NET" Value="Public Class ModuleBuilder&#xA;Inherits Module&#xA;Implements _ModuleBuilder" />
  <TypeSignature Language="C++ CLI" Value="public ref class ModuleBuilder : System::Reflection::Module, System::Runtime::InteropServices::_ModuleBuilder" />
  <TypeSignature Language="F#" Value="type ModuleBuilder = class&#xA;    inherit Module&#xA;    interface _ModuleBuilder" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Emit</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.Module</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._ModuleBuilder</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._ModuleBuilder))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>動的アセンブリ内のモジュールを定義および表現します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インスタンスを取得する<xref:System.Reflection.Emit.ModuleBuilder>を使用して、<xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A?displayProperty=nameWithType>メソッド。  
  
   
  
## Examples  
 次のコード サンプルの使用を示します`ModuleBuilder`動的モジュールを作成します。 ModuleBuilder が呼び出すことによって作成されたことに注意してください。<xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>で<xref:System.Reflection.Emit.AssemblyBuilder>、コンス トラクターではなく。  
  
 [!code-cpp[ModuleBuilder_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/ModuleBuilder_Class/CPP/modulebuilder.cpp#1)]
 [!code-csharp[ModuleBuilder_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/ModuleBuilder_Class/CS/modulebuilder.cs#1)]
 [!code-vb[ModuleBuilder_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ModuleBuilder_Class/VB/modulebuilder.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ModuleBuilder ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ModuleBuilder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public override System.Reflection.Assembly Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly Assembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.ModuleBuilder.Assembly" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Assembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Assembly ^ Assembly { System::Reflection::Assembly ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Assembly : System.Reflection.Assembly" Usage="System.Reflection.Emit.ModuleBuilder.Assembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この <see cref="T:System.Reflection.Emit.ModuleBuilder" /> インスタンスが定義されている動的アセンブリを取得します。</summary>
        <value>現在の動的モジュールが定義されている動的アセンブリ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Assembly>返されるオブジェクトは、<xref:System.Reflection.Emit.AssemblyBuilder>のこのインスタンスが定義されている<xref:System.Reflection.Emit.ModuleBuilder>します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateGlobalFunctions">
      <MemberSignature Language="C#" Value="public void CreateGlobalFunctions ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CreateGlobalFunctions() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateGlobalFunctions ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CreateGlobalFunctions();" />
      <MemberSignature Language="F#" Value="member this.CreateGlobalFunctions : unit -&gt; unit" Usage="moduleBuilder.CreateGlobalFunctions " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この動的モジュールのグローバル関数定義とグローバル データ定義を完了します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この動的モジュール内のすべてのグローバル関数を定義すると、ユーザーの処理が完了したら、このメソッドを呼び出す必要があります。 この関数を呼び出すと、グローバル関数またはグローバルの新しいデータは許可されません。  
  
> [!NOTE]
>  以降では、 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]、このメンバーが不要<xref:System.Security.Permissions.ReflectionPermission>で、<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>フラグ。 (を参照してください[出力のセキュリティ関連事項リフレクション](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md))。この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
   
  
## Examples  
 次の例は、の使用方法を示します`CreateGlobalFunctions`からグローバルな静的メソッドを作成する、<xref:System.Reflection.Emit.MethodBuilder>で実装される<xref:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod%2A>します。  
  
 [!code-cpp[ModuleBuilder_CreateGlobalFunctions#2](~/samples/snippets/cpp/VS_Snippets_CLR/ModuleBuilder_CreateGlobalFunctions/CPP/modulebuilder_createglobalfunctions.cpp#2)]
 [!code-csharp[ModuleBuilder_CreateGlobalFunctions#2](~/samples/snippets/csharp/VS_Snippets_CLR/ModuleBuilder_CreateGlobalFunctions/CS/modulebuilder_createglobalfunctions.cs#2)]
 [!code-vb[ModuleBuilder_CreateGlobalFunctions#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/ModuleBuilder_CreateGlobalFunctions/VB/modulebuilder_createglobalfunctions.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">このメソッドは、既に呼び出されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDocument">
      <MemberSignature Language="C#" Value="public System.Diagnostics.SymbolStore.ISymbolDocumentWriter DefineDocument (string url, Guid language, Guid languageVendor, Guid documentType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Diagnostics.SymbolStore.ISymbolDocumentWriter DefineDocument(string url, valuetype System.Guid language, valuetype System.Guid languageVendor, valuetype System.Guid documentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineDocument(System.String,System.Guid,System.Guid,System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDocument (url As String, language As Guid, languageVendor As Guid, documentType As Guid) As ISymbolDocumentWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Diagnostics::SymbolStore::ISymbolDocumentWriter ^ DefineDocument(System::String ^ url, Guid language, Guid languageVendor, Guid documentType);" />
      <MemberSignature Language="F#" Value="member this.DefineDocument : string * Guid * Guid * Guid -&gt; System.Diagnostics.SymbolStore.ISymbolDocumentWriter" Usage="moduleBuilder.DefineDocument (url, language, languageVendor, documentType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.SymbolStore.ISymbolDocumentWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="language" Type="System.Guid" />
        <Parameter Name="languageVendor" Type="System.Guid" />
        <Parameter Name="documentType" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="url">ドキュメントの URL。</param>
        <param name="language">ドキュメントの言語を識別する GUID。 この値は、<see cref="F:System.Guid.Empty" /> でもかまいません。</param>
        <param name="languageVendor">ドキュメントの言語のベンダーを識別する GUID。 この値は、<see cref="F:System.Guid.Empty" /> でもかまいません。</param>
        <param name="documentType">ドキュメントの種類を識別する GUID。 これは <see cref="F:System.Guid.Empty" /> でもかまいません。</param>
        <summary>ソースのドキュメントを定義します。</summary>
        <returns>定義されたドキュメント。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  .NET Framework の以前のバージョンのスロー<xref:System.ArgumentException>の代わりに<xref:System.ArgumentNullException>とき`url`は`null`します。  
  
   
  
## Examples  
 次のコード サンプルの使用を示します`DefineDocument`動的モジュールに (この場合は、生の IL ファイル) で、外部シンボルのドキュメントをアタッチします。  
  
 [!code-cpp[ModuleBuilder_DefineDocument#1](~/samples/snippets/cpp/VS_Snippets_CLR/ModuleBuilder_DefineDocument/CPP/modulebuilder_definedocument.cpp#1)]
 [!code-csharp[ModuleBuilder_DefineDocument#1](~/samples/snippets/csharp/VS_Snippets_CLR/ModuleBuilder_DefineDocument/CS/modulebuilder_definedocument.cs#1)]
 [!code-vb[ModuleBuilder_DefineDocument#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ModuleBuilder_DefineDocument/VB/modulebuilder_definedocument.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="url" /> は <see langword="null" />です。 これは、.NET Framework の以前のバージョンからの変更です。</exception>
        <exception cref="T:System.InvalidOperationException">このメソッドは、デバッグ モジュールではない動的モジュールに対して呼び出されます。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineEnum">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.EnumBuilder DefineEnum (string name, System.Reflection.TypeAttributes visibility, Type underlyingType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.EnumBuilder DefineEnum(string name, valuetype System.Reflection.TypeAttributes visibility, class System.Type underlyingType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineEnum(System.String,System.Reflection.TypeAttributes,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineEnum (name As String, visibility As TypeAttributes, underlyingType As Type) As EnumBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::EnumBuilder ^ DefineEnum(System::String ^ name, System::Reflection::TypeAttributes visibility, Type ^ underlyingType);" />
      <MemberSignature Language="F#" Value="member this.DefineEnum : string * System.Reflection.TypeAttributes * Type -&gt; System.Reflection.Emit.EnumBuilder" Usage="moduleBuilder.DefineEnum (name, visibility, underlyingType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.EnumBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="visibility" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="underlyingType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">列挙型の完全なパス。 <c>name</c> に埋め込み null 値を含めることはできません。</param>
        <param name="visibility">列挙型の型属性。 属性は、<see cref="F:System.Reflection.TypeAttributes.VisibilityMask" /> で定義された任意のビットです。</param>
        <param name="underlyingType">列挙型の基になる型。 これは、組み込みの整数型にする必要があります。</param>
        <summary>指定した型の <paramref name="value__" /> という単一の非静的フィールドと共に、値型の列挙型を定義します。</summary>
        <returns>定義された列挙型。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 定義された列挙型の派生クラスである<xref:System.Enum>します。 `value__`フィールドが<xref:System.Reflection.FieldAttributes.Private>と<xref:System.Reflection.FieldAttributes.SpecialName>属性セットです。  
  
 列挙体の基になる型として指定できる組み込みの整数型の詳細については、次を参照してください。[クラス ライブラリの概要](~/docs/standard/class-library-overview.md)します。  
  
> [!NOTE]
>  .NET Framework バージョン 1.0 および 1.1 では、これを使用して列挙型を定義する必要が<xref:System.Reflection.Emit.TypeBuilder>ため<xref:System.Reflection.Emit.EnumBuilder>列挙体の要素は型の出力<xref:System.Int32>列挙型の代わりにします。 .NET Framework version 2.0 で<xref:System.Reflection.Emit.EnumBuilder>列挙体の要素は型が正しいことを出力します。  
  
> [!NOTE]
>  以降では、 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]、このメンバーが不要<xref:System.Security.Permissions.ReflectionPermission>で、<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>フラグ。 (を参照してください[出力のセキュリティ関連事項リフレクション](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md))。この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
   
  
## Examples  
 使用例を次に示します`DefineEnum`列挙型クラスの動的モジュールを実装します。 例では、という名前の列挙を定義します`Elevation`基になる型を持つ<xref:System.Int32>、2 つの要素を作成します: `Low`、値 0 の場合と`High`、値は 1 です。 アセンブリを名前で保存、型が作成されたら、`TempAssembly.dll`します。 使用することができます、 [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)してこのアセンブリの内容を確認します。  
  
> [!NOTE]
>  .NET Framework version 2.0 では、前に、このコード例は、適切な列挙を作成できません。  
  
 [!code-cpp[ModuleBuilder_DefineEnum#1](~/samples/snippets/cpp/VS_Snippets_CLR/ModuleBuilder_DefineEnum/CPP/modulebuilder_defineenum.cpp#1)]
 [!code-csharp[ModuleBuilder_DefineEnum#1](~/samples/snippets/csharp/VS_Snippets_CLR/ModuleBuilder_DefineEnum/CS/modulebuilder_defineenum.cs#1)]
 [!code-vb[ModuleBuilder_DefineEnum#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ModuleBuilder_DefineEnum/VB/modulebuilder_defineenum.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">可視属性以外の属性が指定されています。  
  
- または - 
指定された名前の列挙型が、このモジュールの親アセンブリに存在します。  
  
- または - 
可視属性が列挙型のスコープと一致しません。 たとえば、<see cref="F:System.Reflection.TypeAttributes.NestedPublic" /> が<paramref name="visibility" /> に指定されていて、列挙型が入れ子にされた型ではありません。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" />です。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineGlobalMethod">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>グローバル メソッドを定義します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineGlobalMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineGlobalMethod (string name, System.Reflection.MethodAttributes attributes, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineGlobalMethod(string name, valuetype System.Reflection.MethodAttributes attributes, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineGlobalMethod (name As String, attributes As MethodAttributes, returnType As Type, parameterTypes As Type()) As MethodBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefineGlobalMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberSignature Language="F#" Value="member this.DefineGlobalMethod : string * System.Reflection.MethodAttributes * Type * Type[] -&gt; System.Reflection.Emit.MethodBuilder" Usage="moduleBuilder.DefineGlobalMethod (name, attributes, returnType, parameterTypes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">メソッドの名前。 <c>name</c> に埋め込み null 値を含めることはできません。</param>
        <param name="attributes">メソッドの属性。 <c>attributes</c> は <see cref="F:System.Reflection.MethodAttributes.Static" /> を含む必要があります。</param>
        <param name="returnType">メソッドの戻り値の型。</param>
        <param name="parameterTypes">メソッドのパラメーターの型。</param>
        <summary>名前、属性、戻り値の型、およびパラメーター型を指定して、グローバル メソッドを定義します。</summary>
        <returns>定義されたグローバル メソッド。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを定義するグローバル メソッドを呼び出すまでは使用できません<xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A>します。  
  
> [!NOTE]
>  以降では、 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]、このメンバーが不要<xref:System.Security.Permissions.ReflectionPermission>で、<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>フラグ。 (を参照してください[出力のセキュリティ関連事項リフレクション](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md))。この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
   
  
## Examples  
 使用例を次に示します`DefineGlobalMethod`に現在関連付けられている型に依存しないメソッドを作成する<xref:System.Reflection.Emit.ModuleBuilder>します。 グローバルのメソッドをビルドした後<xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A>に手順を完了するために呼び出す必要があります。  
  
 [!code-cpp[ModuleBuilder_CreateGlobalFunctions#1](~/samples/snippets/cpp/VS_Snippets_CLR/ModuleBuilder_CreateGlobalFunctions/CPP/modulebuilder_createglobalfunctions.cpp#1)]
 [!code-csharp[ModuleBuilder_CreateGlobalFunctions#1](~/samples/snippets/csharp/VS_Snippets_CLR/ModuleBuilder_CreateGlobalFunctions/CS/modulebuilder_createglobalfunctions.cs#1)]
 [!code-vb[ModuleBuilder_CreateGlobalFunctions#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ModuleBuilder_CreateGlobalFunctions/VB/modulebuilder_createglobalfunctions.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">メソッドは静的ではありません。 つまり、<paramref name="attributes" /> に <see cref="F:System.Reflection.MethodAttributes.Static" /> が含まれていません。  
  
- または - 
<paramref name="name" /> の長さが 0 です。 
- または - 
<see cref="T:System.Type" /> 配列の要素が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /> は以前に呼び出されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineGlobalMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineGlobalMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineGlobalMethod(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineGlobalMethod (name As String, attributes As MethodAttributes, callingConvention As CallingConventions, returnType As Type, parameterTypes As Type()) As MethodBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefineGlobalMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberSignature Language="F#" Value="member this.DefineGlobalMethod : string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type * Type[] -&gt; System.Reflection.Emit.MethodBuilder" Usage="moduleBuilder.DefineGlobalMethod (name, attributes, callingConvention, returnType, parameterTypes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">メソッドの名前。 <c>name</c> に埋め込み null 値を含めることはできません。</param>
        <param name="attributes">メソッドの属性。 <c>attributes</c> は <see cref="F:System.Reflection.MethodAttributes.Static" /> を含む必要があります。</param>
        <param name="callingConvention">メソッドの呼び出し規則。</param>
        <param name="returnType">メソッドの戻り値の型。</param>
        <param name="parameterTypes">メソッドのパラメーターの型。</param>
        <summary>名前、属性、呼び出し規約、戻り値の型、およびパラメーター型を指定して、グローバル メソッドを定義します。</summary>
        <returns>定義されたグローバル メソッド。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 まで、このメソッドを定義するグローバル メソッドを使用することはできませんを呼び出す<xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A>します。  
  
> [!NOTE]
>  以降では、 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]、このメンバーが不要<xref:System.Security.Permissions.ReflectionPermission>で、<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>フラグ。 (を参照してください[出力のセキュリティ関連事項リフレクション](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md))。この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
   
  
## Examples  
 次のコード サンプルの使用を示します`DefineGlobalMethod`に現在関連付けられている型に依存しないメソッドを作成する<xref:System.Reflection.Emit.ModuleBuilder>します。 グローバルのメソッドをビルドした後<xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A>に手順を完了するために呼び出す必要があります。  
  
 [!code-cpp[ModuleBuilder_CreateGlobalFunctions#1](~/samples/snippets/cpp/VS_Snippets_CLR/ModuleBuilder_CreateGlobalFunctions/CPP/modulebuilder_createglobalfunctions.cpp#1)]
 [!code-csharp[ModuleBuilder_CreateGlobalFunctions#1](~/samples/snippets/csharp/VS_Snippets_CLR/ModuleBuilder_CreateGlobalFunctions/CS/modulebuilder_createglobalfunctions.cs#1)]
 [!code-vb[ModuleBuilder_CreateGlobalFunctions#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ModuleBuilder_CreateGlobalFunctions/VB/modulebuilder_createglobalfunctions.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">メソッドは静的ではありません。 つまり、<paramref name="attributes" /> に <see cref="F:System.Reflection.MethodAttributes.Static" /> が含まれていません。  
  
- または - 
<see cref="T:System.Type" /> 配列の要素が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /> は以前に呼び出されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineGlobalMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineGlobalMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] requiredReturnTypeCustomModifiers, Type[] optionalReturnTypeCustomModifiers, Type[] parameterTypes, Type[][] requiredParameterTypeCustomModifiers, Type[][] optionalParameterTypeCustomModifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineGlobalMethod(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] requiredReturnTypeCustomModifiers, class System.Type[] optionalReturnTypeCustomModifiers, class System.Type[] parameterTypes, class System.Type[][] requiredParameterTypeCustomModifiers, class System.Type[][] optionalParameterTypeCustomModifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineGlobalMethod (name As String, attributes As MethodAttributes, callingConvention As CallingConventions, returnType As Type, requiredReturnTypeCustomModifiers As Type(), optionalReturnTypeCustomModifiers As Type(), parameterTypes As Type(), requiredParameterTypeCustomModifiers As Type()(), optionalParameterTypeCustomModifiers As Type()()) As MethodBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefineGlobalMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ requiredReturnTypeCustomModifiers, cli::array &lt;Type ^&gt; ^ optionalReturnTypeCustomModifiers, cli::array &lt;Type ^&gt; ^ parameterTypes, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ requiredParameterTypeCustomModifiers, cli::array &lt;cli::array &lt;Type ^&gt; ^&gt; ^ optionalParameterTypeCustomModifiers);" />
      <MemberSignature Language="F#" Value="member this.DefineGlobalMethod : string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type * Type[] * Type[] * Type[] * Type[][] * Type[][] -&gt; System.Reflection.Emit.MethodBuilder" Usage="moduleBuilder.DefineGlobalMethod (name, attributes, callingConvention, returnType, requiredReturnTypeCustomModifiers, optionalReturnTypeCustomModifiers, parameterTypes, requiredParameterTypeCustomModifiers, optionalParameterTypeCustomModifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="requiredReturnTypeCustomModifiers" Type="System.Type[]" />
        <Parameter Name="optionalReturnTypeCustomModifiers" Type="System.Type[]" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="requiredParameterTypeCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="optionalParameterTypeCustomModifiers" Type="System.Type[][]" />
      </Parameters>
      <Docs>
        <param name="name">メソッドの名前。 <c>name</c> に null 文字を埋め込むことはできません。</param>
        <param name="attributes">メソッドの属性。 <c>attributes</c> は <see cref="F:System.Reflection.MethodAttributes.Static" /> を含む必要があります。</param>
        <param name="callingConvention">メソッドの呼び出し規則。</param>
        <param name="returnType">メソッドの戻り値の型。</param>
        <param name="requiredReturnTypeCustomModifiers">
          <see cref="T:System.Runtime.CompilerServices.IsConst" /> や <see cref="T:System.Runtime.CompilerServices.IsBoxed" /> などの、戻り値の型の必須のカスタム修飾子を表す型の配列。 戻り値の型が必須のカスタム修飾子を持たない場合は、<see langword="null" /> を指定します。</param>
        <param name="optionalReturnTypeCustomModifiers">
          <see cref="T:System.Runtime.CompilerServices.IsConst" /> や <see cref="T:System.Runtime.CompilerServices.IsBoxed" /> などの、戻り値の型のオプションのカスタム修飾子を表す型の配列。 戻り値の型が省略可能なカスタム修飾子を持たない場合は、<see langword="null" /> を指定します。</param>
        <param name="parameterTypes">メソッドのパラメーター型。</param>
        <param name="requiredParameterTypeCustomModifiers">型の配列の配列。 型の各配列は、グローバル メソッドの対応するパラメーターの必須のカスタム修飾子を表します。 特定の引数に必須のカスタム修飾子がない場合は、型の配列の代わりに <see langword="null" /> を指定します。 グローバル メソッドに引数がない場合、またはどの引数にも必須のカスタム修飾子がない場合は、配列の配列の代わりに <see langword="null" /> を指定します。</param>
        <param name="optionalParameterTypeCustomModifiers">型の配列の配列。 型の各配列は、対応するパラメーターのオプションのカスタム修飾子を表します。 特定の引数にオプションのカスタム修飾子がない場合は、型の配列の代わりに <see langword="null" /> を指定します。 グローバル メソッドに引数がない場合、またはどの引数にもオプションのカスタム修飾子がない場合は、配列の配列の代わりに <see langword="null" /> を指定します。</param>
        <summary>名前、属性、呼び出し規約、戻り値の型、戻り値の型のカスタム修飾子、パラメーター型、およびパラメーター型のカスタム修飾子を指定して、グローバル メソッドを定義します。</summary>
        <returns>定義されたグローバル メソッド。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードは、マネージ コンパイラの設計者に提供されます。  
  
 まで、このメソッドを定義するグローバル メソッドを使用することはできませんを呼び出す<xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A>します。  
  
> [!NOTE]
>  以降では、 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]、このメンバーが不要<xref:System.Security.Permissions.ReflectionPermission>で、<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>フラグ。 (を参照してください[出力のセキュリティ関連事項リフレクション](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md))。この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">メソッドは静的ではありません。 つまり、<paramref name="attributes" /> に <see cref="F:System.Reflection.MethodAttributes.Static" /> が含まれていません。  
  
- または - 
<see cref="T:System.Type" /> 配列の要素が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /> メソッドは既に呼び出されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineInitializedData">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.FieldBuilder DefineInitializedData (string name, byte[] data, System.Reflection.FieldAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.FieldBuilder DefineInitializedData(string name, unsigned int8[] data, valuetype System.Reflection.FieldAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineInitializedData (name As String, data As Byte(), attributes As FieldAttributes) As FieldBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::FieldBuilder ^ DefineInitializedData(System::String ^ name, cli::array &lt;System::Byte&gt; ^ data, System::Reflection::FieldAttributes attributes);" />
      <MemberSignature Language="F#" Value="member this.DefineInitializedData : string * byte[] * System.Reflection.FieldAttributes -&gt; System.Reflection.Emit.FieldBuilder" Usage="moduleBuilder.DefineInitializedData (name, data, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.FieldBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Byte[]" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
      </Parameters>
      <Docs>
        <param name="name">データを参照するために使用する名前。 <c>name</c> に埋め込み null 値を含めることはできません。</param>
        <param name="data">データのバイナリ ラージ オブジェクト (BLOB)。</param>
        <param name="attributes">フィールドの属性。 既定値は、<see langword="Static" /> です。</param>
        <summary>移植可能な実行可能 (PE) ファイルの .sdata セクションに、初期化済みデータ フィールドを定義します。</summary>
        <returns>データを参照するフィールド。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.FieldAttributes.Static> 自動的に記載されて`attributes`します。  
  
 までこのメソッドで定義されたデータを作成しない、<xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A>メソッドが呼び出されます。  
  
> [!NOTE]
>  以降では、 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]、このメンバーが不要<xref:System.Security.Permissions.ReflectionPermission>で、<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>フラグ。 (を参照してください[出力のセキュリティ関連事項リフレクション](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md))。この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
   
  
## Examples  
 次の例では、<xref:System.Reflection.Emit.ModuleBuilder.DefineInitializedData%2A>で初期化されたデータ フィールドを定義するメソッド、`.sdata`ポータブル実行可能 (PE) ファイルのセクション。  
  
 [!code-cpp[ModuleBuilder_DefineInitializedData#1](~/samples/snippets/cpp/VS_Snippets_CLR/ModuleBuilder_DefineInitializedData/CPP/modulebuilder_defineinitializeddata.cpp#1)]
 [!code-csharp[ModuleBuilder_DefineInitializedData#1](~/samples/snippets/csharp/VS_Snippets_CLR/ModuleBuilder_DefineInitializedData/CS/modulebuilder_defineinitializeddata.cs#1)]
 [!code-vb[ModuleBuilder_DefineInitializedData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ModuleBuilder_DefineInitializedData/VB/modulebuilder_defineinitializeddata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> の長さが 0 です。  
  
- または - 
<paramref name="data" /> のサイズが 0 以下か、0x3f0000 以上です。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> または <paramref name="data" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /> は以前に呼び出されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineManifestResource">
      <MemberSignature Language="C#" Value="public void DefineManifestResource (string name, System.IO.Stream stream, System.Reflection.ResourceAttributes attribute);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DefineManifestResource(string name, class System.IO.Stream stream, valuetype System.Reflection.ResourceAttributes attribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DefineManifestResource(System::String ^ name, System::IO::Stream ^ stream, System::Reflection::ResourceAttributes attribute);" />
      <MemberSignature Language="F#" Value="member this.DefineManifestResource : string * System.IO.Stream * System.Reflection.ResourceAttributes -&gt; unit" Usage="moduleBuilder.DefineManifestResource (name, stream, attribute)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="attribute" Type="System.Reflection.ResourceAttributes" />
      </Parameters>
      <Docs>
        <param name="name">リソースの、大文字と小文字が区別される名前。</param>
        <param name="stream">リソースのバイトを格納しているストリーム。</param>
        <param name="attribute">リソースがパブリックかまたはプライベートかを指定する列挙値。</param>
        <summary>動的アセンブリに埋め込まれるマニフェスト リソースを表すバイナリ ラージ オブジェクト (BLOB) を定義します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 アセンブリ マニフェストに記録されているリソースは、マネージ リソースか、マニフェスト リソースの Blob、およびこれらの各リンクすることで、または埋め込みによって、アセンブリに含ますることができます。 動的アセンブリでは、4 つすべてのシナリオはサポートされます。  
  
-   このメソッドを使用すると、動的アセンブリにマニフェスト リソース BLOB を埋め込むことができます。  
  
-   動的アセンブリのマニフェスト モジュールやサテライト モジュールには、マネージ リソースを埋め込むを使用して、<xref:System.Reflection.Emit.ModuleBuilder.DefineResource%2A?displayProperty=nameWithType>メソッドを使用して、リソース ライターを取得、<xref:System.Resources.ResourceWriter.AddResource%2A?displayProperty=nameWithType>リソースを追加するメソッド。  
  
-   動的アセンブリには、マネージ リソースをリンクするには、使用、<xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A?displayProperty=nameWithType>メソッドを使用して、リソース ライターを取得、<xref:System.Resources.ResourceWriter.AddResource%2A?displayProperty=nameWithType>リンクされたリソースを追加します。  
  
-   動的アセンブリに BLOB マニフェスト リソースをリンクするには、使用、<xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A?displayProperty=nameWithType>リンクされたリソースを追加します。  
  
 さらに、1 つの Win32 リソースに接続できますアセンブリを使用して、<xref:System.Reflection.Emit.AssemblyBuilder.DefineUnmanagedResource%2A?displayProperty=nameWithType>メソッドまたは<xref:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource%2A?displayProperty=nameWithType>メソッド。 このリソースは、アセンブリ マニフェストには表示されません。  
  
   
  
## Examples  
 次の例を生成し、という名前の動的アセンブリを保存します。 `EmittedManifestResourceAssembly.exe`、アンマネージ リソースの埋め込みが含まれています。 例を作成、アセンブリは 1 つのモジュールで構成され、アンマネージ リソースを格納するメモリ ストリームを開きます。 コードを呼び出して、<xref:System.Reflection.Emit.ModuleBuilder.DefineManifestResource%2A>リソースを定義するメソッド。  
  
> [!NOTE]
>  リソースに対してどの種類のストリームを使用することができます。たとえば、ファイルから非管理対象のバイナリ データを読み取ることができます。  
  
 例では、使用して、動的モジュールの型を定義する、`Main`メソッド、メソッド本体の MSIL を生成します。 本体の後に、`Main`メソッドが生成されているし、型が作成されて、コード例がマニフェスト リソースに関連付けられているストリームに 5 バイトを書き込みます。 アセンブリが保存されると、リソースが追加されます。  
  
 例を実行した後は、生成されたアセンブリを実行できます。 生成されたアセンブリのコード`Main`メソッドは、埋め込まれたマニフェスト リソースを読み取り、バイトの値をコンソールに出力します。 使用することができます、 [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)アセンブリ マニフェストの情報を表示します。  
  
 [!code-csharp[DefineManifestResource#1](~/samples/snippets/csharp/VS_Snippets_CLR/DefineManifestResource/cs/source.cs#1)]
 [!code-vb[DefineManifestResource#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DefineManifestResource/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" />です。  
  
- または - 
 <paramref name="stream" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> は長さゼロの文字列です。</exception>
        <exception cref="T:System.InvalidOperationException">現在のモジュールを格納している動的アセンブリが遷移的です。つまり、<see cref="M:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule(System.String,System.String)" /> の呼び出し時にファイル名が指定されていません。</exception>
        <altmember cref="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String)" />
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.DefineResource(System.String,System.String,System.String,System.Reflection.ResourceAttributes)" />
        <altmember cref="M:System.Resources.ResourceWriter.AddResource(System.String,System.String)" />
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.AddResourceFile(System.String,System.String)" />
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.DefineUnmanagedResource(System.String)" />
        <altmember cref="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.Byte[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="DefinePInvokeMethod">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see langword="PInvoke" /> メソッドを定義します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefinePInvokeMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefinePInvokeMethod (string name, string dllName, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, System.Runtime.InteropServices.CallingConvention nativeCallConv, System.Runtime.InteropServices.CharSet nativeCharSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefinePInvokeMethod(string name, string dllName, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, valuetype System.Runtime.InteropServices.CallingConvention nativeCallConv, valuetype System.Runtime.InteropServices.CharSet nativeCharSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefinePInvokeMethod(System::String ^ name, System::String ^ dllName, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Runtime::InteropServices::CallingConvention nativeCallConv, System::Runtime::InteropServices::CharSet nativeCharSet);" />
      <MemberSignature Language="F#" Value="member this.DefinePInvokeMethod : string * string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type * Type[] * System.Runtime.InteropServices.CallingConvention * System.Runtime.InteropServices.CharSet -&gt; System.Reflection.Emit.MethodBuilder" Usage="moduleBuilder.DefinePInvokeMethod (name, dllName, attributes, callingConvention, returnType, parameterTypes, nativeCallConv, nativeCharSet)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="dllName" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="nativeCallConv" Type="System.Runtime.InteropServices.CallingConvention" />
        <Parameter Name="nativeCharSet" Type="System.Runtime.InteropServices.CharSet" />
      </Parameters>
      <Docs>
        <param name="name">
          <see langword="PInvoke" /> メソッドの名前。 <c>name</c> に埋め込み null 値を含めることはできません。</param>
        <param name="dllName">
          <see langword="PInvoke" /> メソッドが定義されている DLL の名前。</param>
        <param name="attributes">メソッドの属性。</param>
        <param name="callingConvention">メソッドの呼び出し規則。</param>
        <param name="returnType">メソッドの戻り値の型。</param>
        <param name="parameterTypes">メソッドのパラメーターの型。</param>
        <param name="nativeCallConv">ネイティブ呼び出し規則。</param>
        <param name="nativeCharSet">メソッドのネイティブ文字セット。</param>
        <summary>メソッド名、メソッドが定義される DLL の名前、メソッドの属性、メソッドの呼び出し規約、メソッドの戻り値の型、メソッドのパラメーターの型、および <see langword="PInvoke" /> フラグを指定して、<see langword="PInvoke" /> メソッドを定義します。</summary>
        <returns>定義された <see langword="PInvoke" /> メソッド。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一部の DLL インポート属性は、このメソッドに引数として指定することはできません (System.Runtime.InteropServices.DllImportAttribute の説明を参照してください)。 このような属性は、メソッドのカスタム属性を生成することによって設定する必要があります。 たとえば、DLL インポート属性`PreserveSig`カスタム属性を生成することによって設定されます。  
  
> [!NOTE]
>  以降では、 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]、このメンバーが不要<xref:System.Security.Permissions.ReflectionPermission>で、<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>フラグ。 (を参照してください[出力のセキュリティ関連事項リフレクション](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md))。この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
   
  
## Examples  
 使用例を次に示します、`DefinePInvokeMethod`を作成する方法、<xref:System.Reflection.Emit.MethodBuilder>外部アンマネージ メソッドに対する`MessageBoxA`、Win32 API で。 例では、メッセージ ボックスが表示されます**再試行**と**キャンセル**ボタン、およびメッセージ ボックスからの戻り値が表示されます。  
  
> [!IMPORTANT]
>  0 以外の戻り値を取得するには、追加する必要があります<xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType>メソッド実装フラグを作成した後に、<xref:System.Reflection.Emit.MethodBuilder>を使用して、<xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType>と<xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType>メソッド。  
  
 [!code-cpp[ModuleBuilder_DefinePInvokeMethod1#1](~/samples/snippets/cpp/VS_Snippets_CLR/ModuleBuilder_DefinePInvokeMethod1/CPP/modulebuilder_definepinvokemethod1.cpp#1)]
 [!code-csharp[ModuleBuilder_DefinePInvokeMethod1#1](~/samples/snippets/csharp/VS_Snippets_CLR/ModuleBuilder_DefinePInvokeMethod1/CS/modulebuilder_definepinvokemethod1.cs#1)]
 [!code-vb[ModuleBuilder_DefinePInvokeMethod1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ModuleBuilder_DefinePInvokeMethod1/VB/modulebuilder_definepinvokemethod1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">メソッドが静的でないか、格納している型がインターフェイスです。  
  
- または - 
抽象メソッドです。  
  
- または - 
メソッドは以前に定義されています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> または <paramref name="dllName" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">含んでいる型が <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> を使用して以前に作成されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefinePInvokeMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefinePInvokeMethod (string name, string dllName, string entryName, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, System.Runtime.InteropServices.CallingConvention nativeCallConv, System.Runtime.InteropServices.CharSet nativeCharSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefinePInvokeMethod(string name, string dllName, string entryName, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, valuetype System.Runtime.InteropServices.CallingConvention nativeCallConv, valuetype System.Runtime.InteropServices.CharSet nativeCharSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodBuilder ^ DefinePInvokeMethod(System::String ^ name, System::String ^ dllName, System::String ^ entryName, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Runtime::InteropServices::CallingConvention nativeCallConv, System::Runtime::InteropServices::CharSet nativeCharSet);" />
      <MemberSignature Language="F#" Value="member this.DefinePInvokeMethod : string * string * string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type * Type[] * System.Runtime.InteropServices.CallingConvention * System.Runtime.InteropServices.CharSet -&gt; System.Reflection.Emit.MethodBuilder" Usage="moduleBuilder.DefinePInvokeMethod (name, dllName, entryName, attributes, callingConvention, returnType, parameterTypes, nativeCallConv, nativeCharSet)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="dllName" Type="System.String" />
        <Parameter Name="entryName" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="nativeCallConv" Type="System.Runtime.InteropServices.CallingConvention" />
        <Parameter Name="nativeCharSet" Type="System.Runtime.InteropServices.CharSet" />
      </Parameters>
      <Docs>
        <param name="name">
          <see langword="PInvoke" /> メソッドの名前。 <c>name</c> に埋め込み null 値を含めることはできません。</param>
        <param name="dllName">
          <see langword="PInvoke" /> メソッドが定義されている DLL の名前。</param>
        <param name="entryName">DLL 内のエントリ ポイントの名前。</param>
        <param name="attributes">メソッドの属性。</param>
        <param name="callingConvention">メソッドの呼び出し規則。</param>
        <param name="returnType">メソッドの戻り値の型。</param>
        <param name="parameterTypes">メソッドのパラメーターの型。</param>
        <param name="nativeCallConv">ネイティブ呼び出し規則。</param>
        <param name="nativeCharSet">メソッドのネイティブ文字セット。</param>
        <summary>メソッド名、メソッドが定義される DLL の名前、メソッドの属性、メソッドの呼び出し規約、メソッドの戻り値の型、メソッドのパラメーターの型、および <see langword="PInvoke" /> フラグを指定して、<see langword="PInvoke" /> メソッドを定義します。</summary>
        <returns>定義された <see langword="PInvoke" /> メソッド。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 属性のいくつかの DLL インポート (の説明を参照して<xref:System.Runtime.InteropServices.DllImportAttribute>) このメソッドに引数として指定することはできません。 このような属性は、メソッドのカスタム属性を生成することによって設定する必要があります。 たとえば、DLL インポート属性`PreserveSig`カスタム属性を生成することによって設定されます。  
  
> [!NOTE]
>  以降では、 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]、このメンバーが不要<xref:System.Security.Permissions.ReflectionPermission>で、<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>フラグ。 (を参照してください[出力のセキュリティ関連事項リフレクション](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md))。この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
   
  
## Examples  
 使用例を次に示します、`DefinePInvokeMethod`を作成する方法、<xref:System.Reflection.Emit.MethodBuilder>外部アンマネージ メソッドに対する`MessageBoxA`、Win32 API で。 例では、メッセージ ボックスが表示されます**再試行**と**キャンセル**ボタン、およびメッセージ ボックスからの戻り値が表示されます。  
  
> [!IMPORTANT]
>  0 以外の戻り値を取得するには、追加する必要があります<xref:System.Reflection.MethodImplAttributes.PreserveSig?displayProperty=nameWithType>メソッド実装フラグを作成した後に、<xref:System.Reflection.Emit.MethodBuilder>を使用して、<xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType>と<xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType>メソッド。  
  
 この例の別のオーバー ロードを使用して、<xref:System.Reflection.Emit.ModuleBuilder.DefinePInvokeMethod%2A>メソッドが、この手法は同じです。  
  
 [!code-cpp[ModuleBuilder_DefinePInvokeMethod1#1](~/samples/snippets/cpp/VS_Snippets_CLR/ModuleBuilder_DefinePInvokeMethod1/CPP/modulebuilder_definepinvokemethod1.cpp#1)]
 [!code-csharp[ModuleBuilder_DefinePInvokeMethod1#1](~/samples/snippets/csharp/VS_Snippets_CLR/ModuleBuilder_DefinePInvokeMethod1/CS/modulebuilder_definepinvokemethod1.cs#1)]
 [!code-vb[ModuleBuilder_DefinePInvokeMethod1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ModuleBuilder_DefinePInvokeMethod1/VB/modulebuilder_definepinvokemethod1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">メソッドが静的でないか、格納している型がインターフェイスです。または、メソッドが既に定義されている場合は、メソッドが抽象メソッドです。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> または <paramref name="dllName" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">含んでいる型が <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> を使用して以前に作成されています。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineResource">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>このモジュールに格納するマネージド埋め込みリソースを定義します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineResource">
      <MemberSignature Language="C#" Value="public System.Resources.IResourceWriter DefineResource (string name, string description);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Resources.IResourceWriter DefineResource(string name, string description) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineResource (name As String, description As String) As IResourceWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Resources::IResourceWriter ^ DefineResource(System::String ^ name, System::String ^ description);" />
      <MemberSignature Language="F#" Value="member this.DefineResource : string * string -&gt; System.Resources.IResourceWriter" Usage="moduleBuilder.DefineResource (name, description)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Resources.IResourceWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="description" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">リソースの名前。 <c>name</c> に埋め込み null 値を含めることはできません。</param>
        <param name="description">リソースの説明。</param>
        <summary>このモジュールに格納する名前付きマネージド埋め込みリソースを定義します。</summary>
        <returns>定義されたリソースのリソース ライター。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出し元を呼び出してはならない、`ResourceWriter.Generate()`と`ResourceWriter.Close()`メソッド、によってこれらのメソッドが呼び出されるため、`ModuleBuilder.Save`動的アセンブリが書き込まれるときにディスクにします。  
  
 このメソッドを使用して、マネージ リソースを埋め込みます。 マニフェスト リソースの blob を埋め込むを使用して、<xref:System.Reflection.Emit.ModuleBuilder.DefineManifestResource%2A>メソッド。 埋め込みとマネージ リソースと blob のマニフェスト リソースをリンクの概要については、次を参照してください。、<xref:System.Reflection.Emit.ModuleBuilder.DefineManifestResource%2A>メソッド。  
  
> [!NOTE]
>  以降では、 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]、このメンバーが不要<xref:System.Security.Permissions.ReflectionPermission>で、<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>フラグ。 (を参照してください[出力のセキュリティ関連事項リフレクション](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md))。この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
   
  
## Examples  
 使用例を次に示します`DefineResource`現在に外部のリソースを追加する<xref:System.Reflection.Emit.ModuleBuilder>します。  
  
 [!code-cpp[ModuleBuilder_DefineResource1#1](~/samples/snippets/cpp/VS_Snippets_CLR/ModuleBuilder_DefineResource1/CPP/modulebuilder_defineresource1.cpp#1)]
 [!code-csharp[ModuleBuilder_DefineResource1#1](~/samples/snippets/csharp/VS_Snippets_CLR/ModuleBuilder_DefineResource1/CS/modulebuilder_defineresource1.cs#1)]
 [!code-vb[ModuleBuilder_DefineResource1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ModuleBuilder_DefineResource1/VB/modulebuilder_defineresource1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> の長さが 0 です。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> が null です。</exception>
        <exception cref="T:System.InvalidOperationException">モジュールが遷移的です。  
  
- または - 
格納しているアセンブリが永続化できません。</exception>
        <altmember cref="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)" />
      </Docs>
    </Member>
    <Member MemberName="DefineResource">
      <MemberSignature Language="C#" Value="public System.Resources.IResourceWriter DefineResource (string name, string description, System.Reflection.ResourceAttributes attribute);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Resources.IResourceWriter DefineResource(string name, string description, valuetype System.Reflection.ResourceAttributes attribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineResource(System.String,System.String,System.Reflection.ResourceAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineResource (name As String, description As String, attribute As ResourceAttributes) As IResourceWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Resources::IResourceWriter ^ DefineResource(System::String ^ name, System::String ^ description, System::Reflection::ResourceAttributes attribute);" />
      <MemberSignature Language="F#" Value="member this.DefineResource : string * string * System.Reflection.ResourceAttributes -&gt; System.Resources.IResourceWriter" Usage="moduleBuilder.DefineResource (name, description, attribute)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Resources.IResourceWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="description" Type="System.String" />
        <Parameter Name="attribute" Type="System.Reflection.ResourceAttributes" />
      </Parameters>
      <Docs>
        <param name="name">リソースの名前。 <c>name</c> に埋め込み null 値を含めることはできません。</param>
        <param name="description">リソースの説明。</param>
        <param name="attribute">リソースの属性。</param>
        <summary>このモジュールに格納する指定した属性の名前付きマネージド埋め込みリソースを定義します。</summary>
        <returns>定義されたリソースのリソース ライター。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出し元を呼び出してはならない、`ResourceWriter.Generate()`と`ResourceWriter.Close()`メソッド、によってこれらのメソッドが呼び出されるため、`ModuleBuilder.Save`動的アセンブリが書き込まれるときにディスクにします。  
  
 このメソッドを使用して、マネージ リソースを埋め込みます。 マニフェスト リソースの blob を埋め込むを使用して、<xref:System.Reflection.Emit.ModuleBuilder.DefineManifestResource%2A>メソッド。 埋め込みとマネージ リソースと blob のマニフェスト リソースをリンクの概要については、次を参照してください。、<xref:System.Reflection.Emit.ModuleBuilder.DefineManifestResource%2A>メソッド。  
  
> [!NOTE]
>  以降では、 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]、このメンバーが不要<xref:System.Security.Permissions.ReflectionPermission>で、<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>フラグ。 (を参照してください[出力のセキュリティ関連事項リフレクション](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md))。この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
   
  
## Examples  
 次の例は、現在の外部リソースを追加する DefineResource の使用を示します<xref:System.Reflection.Emit.ModuleBuilder>します。  
  
 [!code-cpp[ModuleBuilder_DefineResource2#1](~/samples/snippets/cpp/VS_Snippets_CLR/ModuleBuilder_DefineResource2/CPP/modulebuilder_defineresource2.cpp#1)]
 [!code-csharp[ModuleBuilder_DefineResource2#1](~/samples/snippets/csharp/VS_Snippets_CLR/ModuleBuilder_DefineResource2/CS/modulebuilder_defineresource2.cs#1)]
 [!code-vb[ModuleBuilder_DefineResource2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ModuleBuilder_DefineResource2/VB/modulebuilder_defineresource2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> の長さが 0 です。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> が null です。</exception>
        <exception cref="T:System.InvalidOperationException">モジュールが遷移的です。  
  
- または - 
格納しているアセンブリが永続化できません。</exception>
        <altmember cref="M:System.Reflection.Emit.ModuleBuilder.DefineManifestResource(System.String,System.IO.Stream,System.Reflection.ResourceAttributes)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineType">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see langword="TypeBuilder" /> を構築します。 値型を定義するには、<see cref="T:System.ValueType" /> から派生する型を定義します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineType(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineType (name As String) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineType(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.DefineType : string -&gt; System.Reflection.Emit.TypeBuilder" Usage="moduleBuilder.DefineType name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">名前空間を含む、型の完全なパス。 <c>name</c> に埋め込み null 値を含めることはできません。</param>
        <summary>このモジュールで、指定した名前のプライベート型の <see langword="TypeBuilder" /> を構築します。</summary>
        <returns>指定した名前のプライベート型。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 型名は、アセンブリ内で一意である必要があります。 アセンブリの 2 つの異なるモジュールで同じ名前の 2 つの型を含めることはできません。  
  
> [!NOTE]
>  以降では、 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]、このメンバーが不要<xref:System.Security.Permissions.ReflectionPermission>で、<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>フラグ。 (を参照してください[出力のセキュリティ関連事項リフレクション](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md))。この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
   
  
## Examples  
 次の例では、作成、<xref:System.Reflection.Emit.TypeBuilder>を使用して現在の動的モジュールで`CreateType`、ビルドし、型が完了すると、アセンブリを保存します。  
  
 [!code-cpp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CS/source.cs#1)]
 [!code-vb[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">指定された名前の型が、このモジュールの親アセンブリに存在します。  
  
- または - 
入れ子にされた型の属性は、入れ子になっていない型に対して設定されます。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineType (string name, System.Reflection.TypeAttributes attr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineType(string name, valuetype System.Reflection.TypeAttributes attr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineType (name As String, attr As TypeAttributes) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineType(System::String ^ name, System::Reflection::TypeAttributes attr);" />
      <MemberSignature Language="F#" Value="member this.DefineType : string * System.Reflection.TypeAttributes -&gt; System.Reflection.Emit.TypeBuilder" Usage="moduleBuilder.DefineType (name, attr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
      </Parameters>
      <Docs>
        <param name="name">型の完全なパス。 <c>name</c> に埋め込み null 値を含めることはできません。</param>
        <param name="attr">定義された型の属性。</param>
        <summary>型名と型属性を指定して、<see langword="TypeBuilder" /> を構築します。</summary>
        <returns>要求された属性をすべて指定して作成された <see langword="TypeBuilder" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 型名は、アセンブリ内で一意である必要があります。 アセンブリの 2 つの異なるモジュールで同じ名前の 2 つの型を含めることはできません。  
  
> [!NOTE]
>  以降では、 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]、このメンバーが不要<xref:System.Security.Permissions.ReflectionPermission>で、<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>フラグ。 (を参照してください[出力のセキュリティ関連事項リフレクション](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md))。この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
   
  
## Examples  
 次の例では、作成、<xref:System.Reflection.Emit.TypeBuilder>を使用して現在の動的モジュールで`CreateType`、ビルドし、型が完了すると、アセンブリを保存します。  
  
 [!code-cpp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CS/source.cs#1)]
 [!code-vb[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">指定された名前の型が、このモジュールの親アセンブリに存在します。  
  
- または - 
入れ子にされた型の属性は、入れ子になっていない型に対して設定されます。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineType (string name, System.Reflection.TypeAttributes attr, Type parent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineType (name As String, attr As TypeAttributes, parent As Type) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent);" />
      <MemberSignature Language="F#" Value="member this.DefineType : string * System.Reflection.TypeAttributes * Type -&gt; System.Reflection.Emit.TypeBuilder" Usage="moduleBuilder.DefineType (name, attr, parent)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">型の完全なパス。 <c>name</c> に埋め込み null 値を含めることはできません。</param>
        <param name="attr">型に関連付ける属性。</param>
        <param name="parent">定義された型を拡張する型。</param>
        <summary>型名、属性、および定義された型によって拡張される型を指定して、<see langword="TypeBuilder" /> を構築します。</summary>
        <returns>要求された属性をすべて指定して作成された <see langword="TypeBuilder" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 型名は、アセンブリ内で一意である必要があります。 アセンブリの 2 つの異なるモジュールで同じ名前の 2 つの型を含めることはできません。  
  
> [!NOTE]
>  以降では、 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]、このメンバーが不要<xref:System.Security.Permissions.ReflectionPermission>で、<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>フラグ。 (を参照してください[出力のセキュリティ関連事項リフレクション](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md))。この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
   
  
## Examples  
 次の例では、作成、<xref:System.Reflection.Emit.TypeBuilder>を使用して現在の動的モジュールで`CreateType`、ビルドし、型が完了すると、アセンブリを保存します。  
  
 [!code-cpp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CS/source.cs#1)]
 [!code-vb[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">指定された名前の型が、このモジュールの親アセンブリに存在します。  
  
- または - 
入れ子にされた型の属性は、入れ子になっていない型に対して設定されます。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineType (string name, System.Reflection.TypeAttributes attr, Type parent, int typesize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, int32 typesize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineType (name As String, attr As TypeAttributes, parent As Type, typesize As Integer) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent, int typesize);" />
      <MemberSignature Language="F#" Value="member this.DefineType : string * System.Reflection.TypeAttributes * Type * int -&gt; System.Reflection.Emit.TypeBuilder" Usage="moduleBuilder.DefineType (name, attr, parent, typesize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="typesize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="name">型の完全なパス。 <c>name</c> に埋め込み null 値を含めることはできません。</param>
        <param name="attr">定義された型の属性。</param>
        <param name="parent">定義された型を拡張する型。</param>
        <param name="typesize">型の合計サイズ。</param>
        <summary>型名、属性、定義された型によって拡張される型、および型の合計サイズを指定して、<see langword="TypeBuilder" /> を構築します。</summary>
        <returns>
          <see langword="TypeBuilder" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 型名は、アセンブリ内で一意である必要があります。 アセンブリの 2 つの異なるモジュールで同じ名前の 2 つの型には禁止されています。  
  
> [!NOTE]
>  以降では、 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]、このメンバーが不要<xref:System.Security.Permissions.ReflectionPermission>で、<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>フラグ。 (を参照してください[出力のセキュリティ関連事項リフレクション](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md))。この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
   
  
## Examples  
 次の例では、作成、<xref:System.Reflection.Emit.TypeBuilder>を使用して現在の動的モジュールで`CreateType`、ビルドし、型が完了すると、アセンブリを保存します。  
  
 [!code-cpp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CS/source.cs#1)]
 [!code-vb[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">指定された名前の型が、このモジュールの親アセンブリに存在します。  
  
- または - 
入れ子にされた型の属性は、入れ子になっていない型に対して設定されます。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineType (string name, System.Reflection.TypeAttributes attr, Type parent, System.Reflection.Emit.PackingSize packsize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, valuetype System.Reflection.Emit.PackingSize packsize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineType (name As String, attr As TypeAttributes, parent As Type, packsize As PackingSize) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent, System::Reflection::Emit::PackingSize packsize);" />
      <MemberSignature Language="F#" Value="member this.DefineType : string * System.Reflection.TypeAttributes * Type * System.Reflection.Emit.PackingSize -&gt; System.Reflection.Emit.TypeBuilder" Usage="moduleBuilder.DefineType (name, attr, parent, packsize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="packsize" Type="System.Reflection.Emit.PackingSize" />
      </Parameters>
      <Docs>
        <param name="name">型の完全なパス。 <c>name</c> に埋め込み null 値を含めることはできません。</param>
        <param name="attr">定義された型の属性。</param>
        <param name="parent">定義された型を拡張する型。</param>
        <param name="packsize">型のパッキング サイズ。</param>
        <summary>型名、属性、定義された型によって拡張される型、および型のパッキング サイズを指定して、<see langword="TypeBuilder" /> を構築します。</summary>
        <returns>
          <see langword="TypeBuilder" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 型名は、アセンブリ内で一意である必要があります。 アセンブリの 2 つの異なるモジュールで同じ名前の 2 つの型を含めることはできません。  
  
> [!NOTE]
>  以降では、 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]、このメンバーが不要<xref:System.Security.Permissions.ReflectionPermission>で、<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>フラグ。 (を参照してください[出力のセキュリティ関連事項リフレクション](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md))。この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
   
  
## Examples  
 次の例では、作成、<xref:System.Reflection.Emit.TypeBuilder>を使用して現在の動的モジュールで`CreateType`、ビルドし、型が完了すると、アセンブリを保存します。  
  
 [!code-cpp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CS/source.cs#1)]
 [!code-vb[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">指定された名前の型が、このモジュールの親アセンブリに存在します。  
  
- または - 
入れ子にされた型の属性は、入れ子になっていない型に対して設定されます。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineType (string name, System.Reflection.TypeAttributes attr, Type parent, Type[] interfaces);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, class System.Type[] interfaces) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineType (name As String, attr As TypeAttributes, parent As Type, interfaces As Type()) As TypeBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent, cli::array &lt;Type ^&gt; ^ interfaces);" />
      <MemberSignature Language="F#" Value="member this.DefineType : string * System.Reflection.TypeAttributes * Type * Type[] -&gt; System.Reflection.Emit.TypeBuilder" Usage="moduleBuilder.DefineType (name, attr, parent, interfaces)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="interfaces" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">型の完全なパス。 <c>name</c> に埋め込み null 値を含めることはできません。</param>
        <param name="attr">型に関連付ける属性。</param>
        <param name="parent">定義された型を拡張する型。</param>
        <param name="interfaces">型が実装するインターフェイスのリスト。</param>
        <summary>型名、属性、定義された型によって拡張される型、および定義された型によって実装されるインターフェイスを指定して、<see langword="TypeBuilder" /> を構築します。</summary>
        <returns>要求された属性をすべて指定して作成された <see langword="TypeBuilder" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 型名は、アセンブリ内で一意である必要があります。 アセンブリの 2 つの異なるモジュールで同じ名前の 2 つの型を含めることはできません。  
  
> [!NOTE]
>  以降では、 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]、このメンバーが不要<xref:System.Security.Permissions.ReflectionPermission>で、<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>フラグ。 (を参照してください[出力のセキュリティ関連事項リフレクション](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md))。この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
   
  
## Examples  
 次の例では、作成、<xref:System.Reflection.Emit.TypeBuilder>を使用して現在の動的モジュールで`CreateType`、ビルドし、型が完了すると、アセンブリを保存します。  
  
 [!code-cpp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CS/source.cs#1)]
 [!code-vb[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">指定された名前の型が、このモジュールの親アセンブリに存在します。  
  
- または - 
入れ子にされた型の属性は、入れ子になっていない型に対して設定されます。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineType (string name, System.Reflection.TypeAttributes attr, Type parent, System.Reflection.Emit.PackingSize packingSize, int typesize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, valuetype System.Reflection.Emit.PackingSize packingSize, int32 typesize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeBuilder ^ DefineType(System::String ^ name, System::Reflection::TypeAttributes attr, Type ^ parent, System::Reflection::Emit::PackingSize packingSize, int typesize);" />
      <MemberSignature Language="F#" Value="member this.DefineType : string * System.Reflection.TypeAttributes * Type * System.Reflection.Emit.PackingSize * int -&gt; System.Reflection.Emit.TypeBuilder" Usage="moduleBuilder.DefineType (name, attr, parent, packingSize, typesize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="packingSize" Type="System.Reflection.Emit.PackingSize" />
        <Parameter Name="typesize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="name">型の完全なパス。 <c>name</c> に埋め込み null 値を含めることはできません。</param>
        <param name="attr">定義された型の属性。</param>
        <param name="parent">定義された型を拡張する型。</param>
        <param name="packingSize">型のパッキング サイズ。</param>
        <param name="typesize">型の合計サイズ。</param>
        <summary>型名、属性、定義された型によって拡張される型、定義された型のパッキング サイズ、および定義された型の合計サイズを指定して、<see langword="TypeBuilder" /> を構築します。</summary>
        <returns>要求された属性をすべて指定して作成された <see langword="TypeBuilder" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 型名は、アセンブリ内で一意である必要があります。 アセンブリの 2 つの異なるモジュールで同じ名前の 2 つの型を含めることはできません。  
  
> [!NOTE]
>  以降では、 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]、このメンバーが不要<xref:System.Security.Permissions.ReflectionPermission>で、<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>フラグ。 (を参照してください[出力のセキュリティ関連事項リフレクション](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md))。この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
   
  
## Examples  
 次の例では、作成、<xref:System.Reflection.Emit.TypeBuilder>を使用して現在の動的モジュールで`CreateType`、ビルドし、型が完了すると、アセンブリを保存します。  
  
 [!code-cpp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/CS/source.cs#1)]
 [!code-vb[Classic ModuleBuilder.DefineType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic ModuleBuilder.DefineType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">指定された名前の型が、このモジュールの親アセンブリに存在します。  
  
- または - 
入れ子にされた型の属性は、入れ子になっていない型に対して設定されます。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineUninitializedData">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.FieldBuilder DefineUninitializedData (string name, int size, System.Reflection.FieldAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.FieldBuilder DefineUninitializedData(string name, int32 size, valuetype System.Reflection.FieldAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineUninitializedData (name As String, size As Integer, attributes As FieldAttributes) As FieldBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::FieldBuilder ^ DefineUninitializedData(System::String ^ name, int size, System::Reflection::FieldAttributes attributes);" />
      <MemberSignature Language="F#" Value="member this.DefineUninitializedData : string * int * System.Reflection.FieldAttributes -&gt; System.Reflection.Emit.FieldBuilder" Usage="moduleBuilder.DefineUninitializedData (name, size, attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.FieldBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
      </Parameters>
      <Docs>
        <param name="name">データを参照するために使用する名前。 <c>name</c> に埋め込み null 値を含めることはできません。</param>
        <param name="size">データ フィールドのサイズ。</param>
        <param name="attributes">フィールドの属性。</param>
        <summary>ポータブル実行可能 (PE) ファイルの .sdata セクションの初期化されていないデータ フィールドを定義します。</summary>
        <returns>データを参照するフィールド。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.FieldAttributes.Static> 自動的に記載されて`attributes`します。  
  
 までこのメソッドで定義されたデータを作成しない、<xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A>メソッドが呼び出されます。  
  
> [!NOTE]
>  以降では、 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]、このメンバーが不要<xref:System.Security.Permissions.ReflectionPermission>で、<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>フラグ。 (を参照してください[出力のセキュリティ関連事項リフレクション](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md))。この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> の長さが 0 です。  
  
- または - 
 <paramref name="size" /> が 0 以下か、0x003f0000 以上です。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions" /> は以前に呼び出されています。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineUnmanagedResource">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>このモジュールのアンマネージ リソースを定義します。 バイナリ ラージ オブジェクト (BLOB) は、Win32 リソースとして正しい形式である必要があります。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineUnmanagedResource">
      <MemberSignature Language="C#" Value="public void DefineUnmanagedResource (byte[] resource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DefineUnmanagedResource(unsigned int8[] resource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub DefineUnmanagedResource (resource As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DefineUnmanagedResource(cli::array &lt;System::Byte&gt; ^ resource);" />
      <MemberSignature Language="F#" Value="member this.DefineUnmanagedResource : byte[] -&gt; unit" Usage="moduleBuilder.DefineUnmanagedResource resource" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resource" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="resource">アンマネージ リソースを表す非透過 BLOB。</param>
        <summary>バイトの非透過バイナリ ラージ オブジェクト (BLOB) を指定して、アンマネージ埋め込みリソースを定義します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 アセンブリは、アンマネージ リソースを 1 つだけ関連付けることができます。 つまり、呼び出す`DefineVersionInfoResource`または`DefineUnmanagedResource`メソッドのいずれかが呼び出された後にいずれか以前スロー <xref:System.ArgumentException>。 複数のアンマネージ リソースを (共通言語ランタイムでは提供されません)、Microsoft ResMerge ユーティリティなどのツールとマージする必要があります。  
  
> [!NOTE]
>  以降では、 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]、このメンバーが不要<xref:System.Security.Permissions.ReflectionPermission>で、<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>フラグ。 (を参照してください[出力のセキュリティ関連事項リフレクション](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md))。この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">モジュールのアセンブリに、既にアンマネージ リソースが定義されています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resource" /> は <see langword="null" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineUnmanagedResource">
      <MemberSignature Language="C#" Value="public void DefineUnmanagedResource (string resourceFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DefineUnmanagedResource(string resourceFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.DefineUnmanagedResource(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DefineUnmanagedResource (resourceFileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DefineUnmanagedResource(System::String ^ resourceFileName);" />
      <MemberSignature Language="F#" Value="member this.DefineUnmanagedResource : string -&gt; unit" Usage="moduleBuilder.DefineUnmanagedResource resourceFileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="resourceFileName">アンマネージ リソース ファイルの名前。</param>
        <summary>Win32 リソース ファイルの名前を指定して、アンマネージ リソースを定義します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 アセンブリは、アンマネージ リソースを 1 つだけ関連付けることができます。 つまり、呼び出す`DefineVersionInfoResource`または`DefineUnmanagedResource`メソッドのいずれかが呼び出された後にいずれか以前スロー <xref:System.ArgumentException>。 複数のアンマネージ リソースを (共通言語ランタイムでは提供されません)、Microsoft ResMerge ユーティリティなどのツールとマージする必要があります。  
  
> [!NOTE]
>  以降では、 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]、このメンバーが不要<xref:System.Security.Permissions.ReflectionPermission>で、<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>フラグ。 (を参照してください[出力のセキュリティ関連事項リフレクション](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md))。この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">モジュールのアセンブリに、既にアンマネージ リソースが定義されています。  
  
- または - 
 <paramref name="resourceFileName" /> が空の文字列 ("") です。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resourceFileName" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="resourceFileName" /> が見つかりません。  
  
- または - 
 <paramref name="resourceFileName" /> はディレクトリです。</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="moduleBuilder.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">対象のインスタンスと比較する対象のオブジェクト、または <see langword="null" />。</param>
        <summary>対象のインスタンスが、指定したオブジェクトに等しいかどうかを示す値を返します。</summary>
        <returns>
          <see langword="true" /> がこのインスタンスの型および値に等しい場合は <paramref name="obj" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FullyQualifiedName">
      <MemberSignature Language="C#" Value="public override string FullyQualifiedName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullyQualifiedName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.ModuleBuilder.FullyQualifiedName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property FullyQualifiedName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ FullyQualifiedName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FullyQualifiedName : string" Usage="System.Reflection.Emit.ModuleBuilder.FullyQualifiedName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このモジュールの完全修飾名とパスを表す <see langword="String" /> を取得します。</summary>
        <value>モジュールの完全修飾名。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 パスを含まない名前を取得する`Name`します。  
  
> [!NOTE]
>  モジュール名の大文字と小文字は、プラットフォームに依存します。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">パスの情報にアクセスします。 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> (関連する列挙体)</permission>
      </Docs>
    </Member>
    <Member MemberName="GetArrayMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetArrayMethod (Type arrayClass, string methodName, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetArrayMethod(class System.Type arrayClass, string methodName, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethod(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetArrayMethod (arrayClass As Type, methodName As String, callingConvention As CallingConventions, returnType As Type, parameterTypes As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetArrayMethod(Type ^ arrayClass, System::String ^ methodName, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberSignature Language="F#" Value="member this.GetArrayMethod : Type * string * System.Reflection.CallingConventions * Type * Type[] -&gt; System.Reflection.MethodInfo" Usage="moduleBuilder.GetArrayMethod (arrayClass, methodName, callingConvention, returnType, parameterTypes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrayClass" Type="System.Type" />
        <Parameter Name="methodName" Type="System.String" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="arrayClass">配列クラス。</param>
        <param name="methodName">配列クラスのメソッドの名前。</param>
        <param name="callingConvention">メソッドの呼び出し規則。</param>
        <param name="returnType">メソッドの戻り値の型。</param>
        <param name="parameterTypes">メソッドのパラメーターの型。</param>
        <summary>配列クラスの名前付きメソッドを返します。</summary>
        <returns>配列クラスの名前付きメソッド。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetArrayMethod` その定義が完了していない型の配列がありで定義されたメソッドにアクセスする場合に便利です<xref:System.Array>します。 たとえば、型を定義しをパラメーターとして型の配列を受け取るメソッドを定義する可能性があります。 配列の要素にアクセスするためのメソッドを呼び出す必要があります、<xref:System.Array>クラス。  
  
   
  
## Examples  
 次の例を使用する方法を示します<xref:System.Reflection.Emit.ModuleBuilder.GetArrayMethod%2A>を取得する、<xref:System.Reflection.MethodInfo>を配列の値を返すメソッドに対応します。  
  
 [!code-cpp[ModuleBuilder_GetArrayMethod#1](~/samples/snippets/cpp/VS_Snippets_CLR/ModuleBuilder_GetArrayMethod/CPP/modulebuilder_getarraymethod.cpp#1)]
 [!code-csharp[ModuleBuilder_GetArrayMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR/ModuleBuilder_GetArrayMethod/CS/modulebuilder_getarraymethod.cs#1)]
 [!code-vb[ModuleBuilder_GetArrayMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ModuleBuilder_GetArrayMethod/VB/modulebuilder_getarraymethod.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="arrayClass" /> が配列ではありません。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="arrayClass" /> または <paramref name="methodName" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetArrayMethodToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodToken GetArrayMethodToken (Type arrayClass, string methodName, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Emit.MethodToken GetArrayMethodToken(class System.Type arrayClass, string methodName, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetArrayMethodToken(System.Type,System.String,System.Reflection.CallingConventions,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetArrayMethodToken (arrayClass As Type, methodName As String, callingConvention As CallingConventions, returnType As Type, parameterTypes As Type()) As MethodToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodToken GetArrayMethodToken(Type ^ arrayClass, System::String ^ methodName, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberSignature Language="F#" Value="member this.GetArrayMethodToken : Type * string * System.Reflection.CallingConventions * Type * Type[] -&gt; System.Reflection.Emit.MethodToken" Usage="moduleBuilder.GetArrayMethodToken (arrayClass, methodName, callingConvention, returnType, parameterTypes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrayClass" Type="System.Type" />
        <Parameter Name="methodName" Type="System.String" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="arrayClass">配列のオブジェクト。</param>
        <param name="methodName">メソッドの名前を格納している文字列。</param>
        <param name="callingConvention">メソッドの呼び出し規則。</param>
        <param name="returnType">メソッドの戻り値の型。</param>
        <param name="parameterTypes">メソッドのパラメーターの型。</param>
        <summary>配列クラスの名前付きメソッドのトークンを返します。</summary>
        <returns>配列クラスの名前付きメソッドのトークン。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは<xref:System.Reflection.Emit.ModuleBuilder.GetArrayMethod%2A>、メソッド自体ではなく配列メソッドのトークンを返す点が異なります。  
  
   
  
## Examples  
 次の例を使用する方法を示します<xref:System.Reflection.Emit.ModuleBuilder.GetArrayMethod%2A>を取得する、<xref:System.Reflection.Emit.MethodToken>を配列の値を返すメソッドに対応します。  
  
 [!code-cpp[ModuleBuilder_GetArrayMethod#2](~/samples/snippets/cpp/VS_Snippets_CLR/ModuleBuilder_GetArrayMethod/CPP/modulebuilder_getarraymethod.cpp#2)]
 [!code-csharp[ModuleBuilder_GetArrayMethod#2](~/samples/snippets/csharp/VS_Snippets_CLR/ModuleBuilder_GetArrayMethod/CS/modulebuilder_getarraymethod.cs#2)]
 [!code-vb[ModuleBuilder_GetArrayMethod#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/ModuleBuilder_GetArrayMethod/VB/modulebuilder_getarraymethod.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="arrayClass" /> が配列ではありません。  
  
- または - 
<paramref name="methodName" /> の長さが 0 です。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="arrayClass" /> または <paramref name="methodName" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConstructorToken">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>このモジュール内で指定したコンストラクターの識別に使用したトークンを返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConstructorToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodToken GetConstructorToken (System.Reflection.ConstructorInfo con);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Emit.MethodToken GetConstructorToken(class System.Reflection.ConstructorInfo con) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetConstructorToken(System.Reflection.ConstructorInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructorToken (con As ConstructorInfo) As MethodToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodToken GetConstructorToken(System::Reflection::ConstructorInfo ^ con);" />
      <MemberSignature Language="F#" Value="member this.GetConstructorToken : System.Reflection.ConstructorInfo -&gt; System.Reflection.Emit.MethodToken" Usage="moduleBuilder.GetConstructorToken con" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="con" Type="System.Reflection.ConstructorInfo" />
      </Parameters>
      <Docs>
        <param name="con">トークンを取得するコンストラクター。</param>
        <summary>このモジュール内で指定したコンストラクターの識別に使用したトークンを返します。</summary>
        <returns>このモジュール内で指定したコンストラクターの識別に使用したトークン。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="con" /> は <see langword="null" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetConstructorToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodToken GetConstructorToken (System.Reflection.ConstructorInfo constructor, System.Collections.Generic.IEnumerable&lt;Type&gt; optionalParameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Emit.MethodToken GetConstructorToken(class System.Reflection.ConstructorInfo constructor, class System.Collections.Generic.IEnumerable`1&lt;class System.Type&gt; optionalParameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetConstructorToken(System.Reflection.ConstructorInfo,System.Collections.Generic.IEnumerable{System.Type})" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructorToken (constructor As ConstructorInfo, optionalParameterTypes As IEnumerable(Of Type)) As MethodToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodToken GetConstructorToken(System::Reflection::ConstructorInfo ^ constructor, System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ optionalParameterTypes);" />
      <MemberSignature Language="F#" Value="member this.GetConstructorToken : System.Reflection.ConstructorInfo * seq&lt;Type&gt; -&gt; System.Reflection.Emit.MethodToken" Usage="moduleBuilder.GetConstructorToken (constructor, optionalParameterTypes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="optionalParameterTypes" Type="System.Collections.Generic.IEnumerable&lt;System.Type&gt;" />
      </Parameters>
      <Docs>
        <param name="constructor">トークンを取得するコンストラクター。</param>
        <param name="optionalParameterTypes">コンストラクターに対する省略可能なパラメーターの型のコレクション。</param>
        <summary>このモジュール内の指定された属性とパラメーターの型を持つコンストラクターの識別に使用したトークンを返します。</summary>
        <returns>このモジュール内で指定したコンストラクターの識別に使用したトークン。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="constructor" /> は <see langword="null" />です。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の <see cref="T:System.Reflection.Emit.ModuleBuilder" /> に適用されるカスタム属性を返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberSignature Language="F#" Value="override this.GetCustomAttributes : bool -&gt; obj[]" Usage="moduleBuilder.GetCustomAttributes inherit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">この型のオブジェクトでは、この引数は無視されます。</param>
        <summary>現在の <see cref="T:System.Reflection.Emit.ModuleBuilder" /> に適用されたカスタム属性をすべて返します。</summary>
        <returns>カスタム属性を含む配列。属性がない場合、配列は空です。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="override this.GetCustomAttributes : Type * bool -&gt; obj[]" Usage="moduleBuilder.GetCustomAttributes (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">属性の派生元となる基本型。</param>
        <param name="inherit">この型のオブジェクトでは、この引数は無視されます。</param>
        <summary>現在の <see cref="T:System.Reflection.Emit.ModuleBuilder" /> に適用されており、指定された属性の型から派生するすべてのカスタム属性を返します。</summary>
        <returns>
          <paramref name="attributeType" /> の任意のレベルから派生したカスタム属性を含む配列。そのような属性がない場合、配列は空です。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="attributeType" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="attributeType" />は、ランタイムによって提供された <see cref="T:System.Type" /> オブジェクトではありません。 たとえば、<paramref name="attributeType" /> は <see cref="T:System.Reflection.Emit.TypeBuilder" /> オブジェクトです。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributesData">
      <MemberSignature Language="C#" Value="public override System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt; GetCustomAttributesData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Collections.Generic.IList`1&lt;class System.Reflection.CustomAttributeData&gt; GetCustomAttributesData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetCustomAttributesData" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributesData () As IList(Of CustomAttributeData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Collections::Generic::IList&lt;System::Reflection::CustomAttributeData ^&gt; ^ GetCustomAttributesData();" />
      <MemberSignature Language="F#" Value="override this.GetCustomAttributesData : unit -&gt; System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;" Usage="moduleBuilder.GetCustomAttributesData " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see cref="T:System.Reflection.Emit.ModuleBuilder" /> に適用されている属性に関する情報を、<see cref="T:System.Reflection.CustomAttributeData" /> オブジェクトとして返します。</summary>
        <returns>現在のモジュールに適用されている属性に関するデータを表す <see cref="T:System.Reflection.CustomAttributeData" /> オブジェクトのジェネリック リスト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 リフレクションのみのコンテキストに読み込まれるコードでカスタム属性そのものが定義されている場合、リフレクションのみのコンテキスト内のコードのカスタム属性を調べるには、このメソッドを使用します。 などのメソッド<xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType>と<xref:System.Reflection.Assembly.GetCustomAttributes%2A?displayProperty=nameWithType>属性のインスタンスを作成するため、このような場合では使用できません。 リフレクションのみのコンテキストでコードを実行できません。 詳細と例のコードについて、次を参照してください。、<xref:System.Reflection.CustomAttributeData>クラス。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public override System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.FieldInfo GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetField(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetField (name As String, bindingAttr As BindingFlags) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::FieldInfo ^ GetField(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="override this.GetField : string * System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo" Usage="moduleBuilder.GetField (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">フィールド名。</param>
        <param name="bindingAttr">検索を制御するために使用される <see langword="BindingFlags" /> ビット フラグの組み合わせ。</param>
        <summary>移植可能な実行可能 (PE) ファイルの .sdata セクションに定義されている、指定した名前とバインディング属性を持つモジュール レベルのフィールドを返します。</summary>
        <returns>指定した名前とバインディング属性を持つフィールド。フィールドが存在しない場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、ポータブル実行可能 (PE) ファイルの .sdata セクションにフィールドが定義されている動的アセンブリを生成するときに、<xref:System.Reflection.Emit.ModuleBuilder.DefineInitializedData%2A>または<xref:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData%2A>メソッド。  
  
> [!IMPORTANT]
>  までは、モジュール レベルのフィールドを取得できません後、<xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A>モジュールのメソッドが呼び出されました。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> パラメーターが <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public override System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.FieldInfo[] GetFields(valuetype System.Reflection.BindingFlags bindingFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetFields(System.Reflection.BindingFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields(System::Reflection::BindingFlags bindingFlags);" />
      <MemberSignature Language="F#" Value="override this.GetFields : System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo[]" Usage="moduleBuilder.GetFields bindingFlags" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingFlags" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingFlags">検索を制御するために使用される <see langword="BindingFlags" /> ビット フラグの組み合わせ。</param>
        <summary>移植可能な実行可能 (PE) ファイルの .sdata セクションに定義されている、指定したバインディング フラグに一致するすべてのフィールドを返します。</summary>
        <returns>指定したフラグに一致するフィールドの配列。このようなフィールドが存在しない場合、配列は空になります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、ポータブル実行可能 (PE) ファイルの .sdata セクションにフィールドが定義されている動的アセンブリを生成するときに、<xref:System.Reflection.Emit.ModuleBuilder.DefineInitializedData%2A>または<xref:System.Reflection.Emit.ModuleBuilder.DefineUninitializedData%2A>メソッド。  
  
> [!IMPORTANT]
>  までは、モジュール レベルのフィールドを取得できません後、<xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A>モジュールのメソッドが呼び出されました。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> パラメーターが <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFieldToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.FieldToken GetFieldToken (System.Reflection.FieldInfo field);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Emit.FieldToken GetFieldToken(class System.Reflection.FieldInfo field) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetFieldToken(System.Reflection.FieldInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFieldToken (field As FieldInfo) As FieldToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::FieldToken GetFieldToken(System::Reflection::FieldInfo ^ field);" />
      <MemberSignature Language="F#" Value="member this.GetFieldToken : System.Reflection.FieldInfo -&gt; System.Reflection.Emit.FieldToken" Usage="moduleBuilder.GetFieldToken field" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.FieldToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="field" Type="System.Reflection.FieldInfo" />
      </Parameters>
      <Docs>
        <param name="field">トークンを取得するフィールド。</param>
        <summary>このモジュール内で指定したフィールドの識別に使用したトークンを返します。</summary>
        <returns>このモジュール内で指定したフィールドの識別に使用したトークン。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="field" /> は <see langword="null" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="moduleBuilder.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このインスタンスのハッシュ コードを返します。</summary>
        <returns>32 ビット符号付き整数ハッシュ コード。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="override this.GetMethodImpl : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="moduleBuilder.GetMethodImpl (name, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">メソッド名。</param>
        <param name="bindingAttr">検索を制御するために使用される <see langword="BindingFlags" /> ビット フラグの組み合わせ。</param>
        <param name="binder">このメソッドに関連するプロパティが含まれ、<see langword="Binder" /> を実装するオブジェクト。</param>
        <param name="callConvention">メソッドの呼び出し規則。</param>
        <param name="types">メソッドのパラメーターの型。</param>
        <param name="modifiers">型が変更されているパラメーター シグネチャでバインドを機能させるために使われるパラメーター修飾子の配列。</param>
        <summary>指定した基準に一致するモジュール レベルのメソッドを返します。</summary>
        <returns>モジュール レベルで定義されている、指定した基準に一致するメソッド。このようなメソッドが存在しない場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、すべてのオーバー ロード、継承の実装を提供します。<xref:System.Reflection.Module.GetMethod%2A?displayProperty=nameWithType>メソッド。 使用して、継承した<xref:System.Reflection.Module.GetMethod%2A?displayProperty=nameWithType>モジュール レベルで宣言されているメソッドを取得します。 使用して生成されたコードのモジュール レベルのメソッドが定義されている、<xref:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod%2A>メソッド。  
  
> [!IMPORTANT]
>  までは、モジュール レベルのメソッドを取得できません後、<xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A>モジュールのメソッドが呼び出されました。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> が <see langword="null" /> であるか、<paramref name="types" /> が <see langword="null" /> であるか、または <paramref name="types" /> の要素が <see langword="null" /> です。</exception>
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodInfo[] GetMethods(valuetype System.Reflection.BindingFlags bindingFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetMethods(System.Reflection.BindingFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods(System::Reflection::BindingFlags bindingFlags);" />
      <MemberSignature Language="F#" Value="override this.GetMethods : System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo[]" Usage="moduleBuilder.GetMethods bindingFlags" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingFlags" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingFlags">検索を制御するために使用される <see langword="BindingFlags" /> ビット フラグの組み合わせ。</param>
        <summary>現在の <see cref="T:System.Reflection.Emit.ModuleBuilder" /> に対してモジュール レベルで定義され、指定したバインディング フラグに一致するすべてのメソッドを返します。</summary>
        <returns>
          <paramref name="bindingFlags" /> に一致するすべてのモジュール レベルのメソッドを含む配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して生成されたコードのモジュール レベルのメソッドが定義されている、<xref:System.Reflection.Emit.ModuleBuilder.DefineGlobalMethod%2A>メソッド。  
  
> [!IMPORTANT]
>  までは、モジュール レベルのメソッドを取得できません後、<xref:System.Reflection.Emit.ModuleBuilder.CreateGlobalFunctions%2A>モジュールのメソッドが呼び出されました。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethodToken">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>このモジュール内で指定したメソッドの識別に使用したトークンを返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethodToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodToken GetMethodToken (System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Emit.MethodToken GetMethodToken(class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetMethodToken(System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethodToken (method As MethodInfo) As MethodToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodToken GetMethodToken(System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="member this.GetMethodToken : System.Reflection.MethodInfo -&gt; System.Reflection.Emit.MethodToken" Usage="moduleBuilder.GetMethodToken method" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="method">トークンを取得するメソッド。</param>
        <summary>このモジュール内で指定したメソッドの識別に使用したトークンを返します。</summary>
        <returns>このモジュール内で指定したメソッドの識別に使用したトークン。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.InvalidOperationException">メソッドの宣言型がこのモジュールにありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethodToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodToken GetMethodToken (System.Reflection.MethodInfo method, System.Collections.Generic.IEnumerable&lt;Type&gt; optionalParameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Emit.MethodToken GetMethodToken(class System.Reflection.MethodInfo method, class System.Collections.Generic.IEnumerable`1&lt;class System.Type&gt; optionalParameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetMethodToken(System.Reflection.MethodInfo,System.Collections.Generic.IEnumerable{System.Type})" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethodToken (method As MethodInfo, optionalParameterTypes As IEnumerable(Of Type)) As MethodToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::MethodToken GetMethodToken(System::Reflection::MethodInfo ^ method, System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ optionalParameterTypes);" />
      <MemberSignature Language="F#" Value="member this.GetMethodToken : System.Reflection.MethodInfo * seq&lt;Type&gt; -&gt; System.Reflection.Emit.MethodToken" Usage="moduleBuilder.GetMethodToken (method, optionalParameterTypes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="optionalParameterTypes" Type="System.Collections.Generic.IEnumerable&lt;System.Type&gt;" />
      </Parameters>
      <Docs>
        <param name="method">トークンを取得するメソッド。</param>
        <param name="optionalParameterTypes">メソッドに対する省略可能なパラメーターの型のコレクション。</param>
        <summary>このモジュール内の指定された属性とパラメーターの型を持つメソッドの識別に使用したトークンを返します。</summary>
        <returns>このモジュール内で指定したメソッドの識別に使用したトークン。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="method" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.InvalidOperationException">メソッドの宣言型がこのモジュールにありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetPEKind">
      <MemberSignature Language="C#" Value="public override void GetPEKind (out System.Reflection.PortableExecutableKinds peKind, out System.Reflection.ImageFileMachine machine);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void GetPEKind([out] valuetype System.Reflection.PortableExecutableKinds&amp; peKind, [out] valuetype System.Reflection.ImageFileMachine&amp; machine) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetPEKind(System.Reflection.PortableExecutableKinds@,System.Reflection.ImageFileMachine@)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub GetPEKind (ByRef peKind As PortableExecutableKinds, ByRef machine As ImageFileMachine)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void GetPEKind([Runtime::InteropServices::Out] System::Reflection::PortableExecutableKinds % peKind, [Runtime::InteropServices::Out] System::Reflection::ImageFileMachine % machine);" />
      <MemberSignature Language="F#" Value="override this.GetPEKind :  *  -&gt; unit" Usage="moduleBuilder.GetPEKind (peKind, machine)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="peKind" Type="System.Reflection.PortableExecutableKinds" RefType="out" />
        <Parameter Name="machine" Type="System.Reflection.ImageFileMachine" RefType="out" />
      </Parameters>
      <Docs>
        <param name="peKind">このメソッドから制御が戻る場合、モジュール内のコードの性質を示す <see cref="T:System.Reflection.PortableExecutableKinds" /> 値の組み合わせ。</param>
        <param name="machine">このメソッドから制御が戻る場合、モジュールの対象プラットフォームを示す <see cref="T:System.Reflection.ImageFileMachine" /> 値の 1 つ。</param>
        <summary>モジュール内のコードの性質およびモジュールの対象プラットフォームを示す値のペアを取得します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 動的モジュールの場合の`peKind`は常に<xref:System.Reflection.PortableExecutableKinds.NotAPortableExecutableImage?displayProperty=nameWithType>と`machine`は常に 0 (ゼロ)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetSignatureToken">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>シグネチャ トークンを定義します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSignatureToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.SignatureToken GetSignatureToken (System.Reflection.Emit.SignatureHelper sigHelper);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Emit.SignatureToken GetSignatureToken(class System.Reflection.Emit.SignatureHelper sigHelper) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetSignatureToken(System.Reflection.Emit.SignatureHelper)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSignatureToken (sigHelper As SignatureHelper) As SignatureToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::SignatureToken GetSignatureToken(System::Reflection::Emit::SignatureHelper ^ sigHelper);" />
      <MemberSignature Language="F#" Value="member this.GetSignatureToken : System.Reflection.Emit.SignatureHelper -&gt; System.Reflection.Emit.SignatureToken" Usage="moduleBuilder.GetSignatureToken sigHelper" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.SignatureToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sigHelper" Type="System.Reflection.Emit.SignatureHelper" />
      </Parameters>
      <Docs>
        <param name="sigHelper">署名。</param>
        <summary>指定した <see cref="T:System.Reflection.Emit.SignatureHelper" /> で定義されたシグネチャのトークンを定義します。</summary>
        <returns>定義されたシグネチャのトークン。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドによって表されるシグネチャのメタデータ トークンを定義する`sigHelper`します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sigHelper" /> は <see langword="null" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSignatureToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.SignatureToken GetSignatureToken (byte[] sigBytes, int sigLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Emit.SignatureToken GetSignatureToken(unsigned int8[] sigBytes, int32 sigLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetSignatureToken(System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSignatureToken (sigBytes As Byte(), sigLength As Integer) As SignatureToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::SignatureToken GetSignatureToken(cli::array &lt;System::Byte&gt; ^ sigBytes, int sigLength);" />
      <MemberSignature Language="F#" Value="member this.GetSignatureToken : byte[] * int -&gt; System.Reflection.Emit.SignatureToken" Usage="moduleBuilder.GetSignatureToken (sigBytes, sigLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.SignatureToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sigBytes" Type="System.Byte[]" />
        <Parameter Name="sigLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sigBytes">シグネチャのバイナリ ラージ オブジェクト (BLOB)。</param>
        <param name="sigLength">シグネチャ BLOB の長さ。</param>
        <summary>指定した文字配列とシグネチャの長さを持つシグネチャのトークンを定義します。</summary>
        <returns>指定したシグネチャのトークン。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sigBytes" /> は <see langword="null" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSignerCertificate">
      <MemberSignature Language="C#" Value="public override System.Security.Cryptography.X509Certificates.X509Certificate GetSignerCertificate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.Cryptography.X509Certificates.X509Certificate GetSignerCertificate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetSignerCertificate" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetSignerCertificate () As X509Certificate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::Cryptography::X509Certificates::X509Certificate ^ GetSignerCertificate();" />
      <MemberSignature Language="F#" Value="override this.GetSignerCertificate : unit -&gt; System.Security.Cryptography.X509Certificates.X509Certificate" Usage="moduleBuilder.GetSignerCertificate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509Certificate</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このモジュールが属すアセンブリの Authenticode 署名に含まれた、証明書に対応する <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate" /> オブジェクトを返します。 アセンブリに Authenticode 署名がない場合は <see langword="null" /> が返されます。</summary>
        <returns>証明書。このモジュールが属するアセンブリに Authenticode 署名がない場合は <see langword="null" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetStringConstant">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.StringToken GetStringConstant (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Emit.StringToken GetStringConstant(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetStringConstant(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetStringConstant (str As String) As StringToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::StringToken GetStringConstant(System::String ^ str);" />
      <MemberSignature Language="F#" Value="member this.GetStringConstant : string -&gt; System.Reflection.Emit.StringToken" Usage="moduleBuilder.GetStringConstant str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.StringToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">モジュールの定数プールに追加する文字列。</param>
        <summary>モジュールの定数プールで指定された文字列のトークンを返します。</summary>
        <returns>定数プールの文字列のトークン。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合`str`が既に定義されている、既存のトークンが返されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" /> は <see langword="null" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSymWriter">
      <MemberSignature Language="C#" Value="public System.Diagnostics.SymbolStore.ISymbolWriter GetSymWriter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Diagnostics.SymbolStore.ISymbolWriter GetSymWriter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetSymWriter" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSymWriter () As ISymbolWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Diagnostics::SymbolStore::ISymbolWriter ^ GetSymWriter();" />
      <MemberSignature Language="F#" Value="member this.GetSymWriter : unit -&gt; System.Diagnostics.SymbolStore.ISymbolWriter" Usage="moduleBuilder.GetSymWriter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.SymbolStore.ISymbolWriter</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この動的モジュールに関連付けられたシンボル ライターを返します。</summary>
        <returns>この動的モジュールに関連付けられたシンボル ライター。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  以降では、 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]、このメンバーが不要<xref:System.Security.Permissions.ReflectionPermission>で、<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>フラグ。 (を参照してください[出力のセキュリティ関連事項リフレクション](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md))。この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>このモジュールで定義されている名前付きの型を取得します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public override Type GetType (string className);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetType(string className) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetType (className As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetType(System::String ^ className);" />
      <MemberSignature Language="F#" Value="override this.GetType : string -&gt; Type" Usage="moduleBuilder.GetType className" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="className" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="className">取得する <see cref="T:System.Type" /> の名前。</param>
        <summary>このモジュールで定義されている名前付きの型を取得します。</summary>
        <returns>型がこのモジュールで定義されている場合は要求された型。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、配列型、ポインター型、または byref 型を生成しないでください。 使用して、 <xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A?displayProperty=nameWithType>、 <xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A?displayProperty=nameWithType>、および<xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A?displayProperty=nameWithType>メソッド代わりにします。  
  
> [!NOTE]
>  以降では、 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]、このメンバーが不要<xref:System.Security.Permissions.ReflectionPermission>で、<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>フラグ。 (を参照してください[出力のセキュリティ関連事項リフレクション](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md))。この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="className" /> の長さが 0 か、または 1023 を超えています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="className" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Security.SecurityException">要求された <see cref="T:System.Type" /> がパブリックではなく、呼び出し元には、現在のアセンブリ外の非パブリック オブジェクトをリフレクトするための <see cref="T:System.Security.Permissions.ReflectionPermission" /> がありません。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">クラス初期化子が呼び出され、例外をスローします。</exception>
        <exception cref="T:System.TypeLoadException">
          <see cref="T:System.Type" /> の読み込み中にエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public override Type GetType (string className, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetType(string className, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetType (className As String, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetType(System::String ^ className, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="override this.GetType : string * bool -&gt; Type" Usage="moduleBuilder.GetType (className, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="className" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="className">取得する <see cref="T:System.Type" /> の名前。</param>
        <param name="ignoreCase">
          <see langword="true" /> の場合、検索では、大文字と小文字を区別しません。 <see langword="false" /> の場合、検索では、大文字と小文字が区別されます。</param>
        <summary>オプションで型名の大文字小文字の区別を無視して、モジュールで定義されている名前付きの型を取得します。</summary>
        <returns>型がこのモジュールで定義されている場合は要求された型。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、配列型、ポインター型、または byref 型を生成しないでください。 使用して、 <xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A?displayProperty=nameWithType>、 <xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A?displayProperty=nameWithType>、および<xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A?displayProperty=nameWithType>メソッド代わりにします。  
  
> [!NOTE]
>  以降では、 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]、このメンバーが不要<xref:System.Security.Permissions.ReflectionPermission>で、<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>フラグ。 (を参照してください[出力のセキュリティ関連事項リフレクション](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md))。この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="className" /> の長さが 0 か、または 1023 を超えています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="className" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Security.SecurityException">要求された <see cref="T:System.Type" /> がパブリックではなく、呼び出し元には、現在のアセンブリ外の非パブリック オブジェクトをリフレクトするための <see cref="T:System.Security.Permissions.ReflectionPermission" /> がありません。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">クラス初期化子が呼び出され、例外をスローします。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public override Type GetType (string className, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetType(string className, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetType (className As String, throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetType(System::String ^ className, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="override this.GetType : string * bool * bool -&gt; Type" Usage="moduleBuilder.GetType (className, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="className" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="className">取得する <see cref="T:System.Type" /> の名前。</param>
        <param name="throwOnError">型が見つからなかったときに例外をスローする場合は <see langword="true" />。<see langword="false" /> を返す場合は <see langword="null" />。</param>
        <param name="ignoreCase">
          <see langword="true" /> の場合、検索では、大文字と小文字を区別しません。 <see langword="false" /> の場合、検索では、大文字と小文字が区別されます。</param>
        <summary>オプションで型名の大文字小文字の区別を無視して、モジュールで定義されている名前付きの型を取得します。 型が見つからないときに例外をスローすることもできます。</summary>
        <returns>型がこのモジュールで宣言されている場合は、指定した型。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `throwOnError`パラメーター型が見つからない場合にのみ影響します。 スローされる可能性があるその他の例外には影響しません。 型が見つかりましたが、読み込みができない場合は、特に<xref:System.TypeLoadException>スローされる場合でも`throwOnError`は`false`。  
  
 このメソッドを使用して、配列型、ポインター型、または byref 型を生成しないでください。 使用して、 <xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A?displayProperty=nameWithType>、 <xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A?displayProperty=nameWithType>、および<xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A?displayProperty=nameWithType>メソッド代わりにします。  
  
> [!NOTE]
>  以降では、 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]、このメンバーが不要<xref:System.Security.Permissions.ReflectionPermission>で、<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>フラグ。 (を参照してください[出力のセキュリティ関連事項リフレクション](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md))。この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="className" /> の長さが 0 か、または 1023 を超えています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="className" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Security.SecurityException">要求された <see cref="T:System.Type" /> がパブリックではなく、呼び出し元には、現在のアセンブリ外の非パブリック オブジェクトをリフレクトするための <see cref="T:System.Security.Permissions.ReflectionPermission" /> がありません。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">クラス初期化子が呼び出され、例外をスローします。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /> が <see langword="true" /> で、指定した型が見つかりません。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypes">
      <MemberSignature Language="C#" Value="public override Type[] GetTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;Type ^&gt; ^ GetTypes();" />
      <MemberSignature Language="F#" Value="override this.GetTypes : unit -&gt; Type[]" Usage="moduleBuilder.GetTypes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このモジュールで定義されているすべてのクラスを返します。</summary>
        <returns>このインスタンスによってリフレクトされたモジュールで定義されている型を格納している配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ReflectionTypeLoadException` 特殊なクラスの読み込み例外です。 `ReflectionTypeLoadException.Types`プロパティには、モジュールで定義され、読み込まれたクラスの配列が含まれています。 この配列は、null 値を含めることができます。 `ReflectionTypeLoadException.LoaderExceptions`プロパティは、クラス ローダーによってスローされた例外を表す例外の配列です。 クラスの配列の穴は、例外を整列します。  
  
 などの場合は、クラスの 1 つのクラスの初期化中に例外がスローされている、読み込まれる、`TargetInvocationException`の対応する要素に格納された、`LoaderExceptions`配列。  
  
> [!NOTE]
>  以降では、 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]、このメンバーが不要<xref:System.Security.Permissions.ReflectionPermission>で、<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>フラグ。 (を参照してください[出力のセキュリティ関連事項リフレクション](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md))。この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.ReflectionTypeLoadException">モジュールの 1 つまたは複数のクラスを読み込むことができませんでした。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <altmember cref="T:System.Reflection.ReflectionTypeLoadException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeToken">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>型トークンを返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeToken GetTypeToken (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Emit.TypeToken GetTypeToken(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetTypeToken(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeToken (name As String) As TypeToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeToken GetTypeToken(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GetTypeToken : string -&gt; System.Reflection.Emit.TypeToken" Usage="moduleBuilder.GetTypeToken name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">名前空間を含むクラスの名前。</param>
        <summary>指定した名前の型を識別するときに使用するトークンを返します。</summary>
        <returns>このモジュール内で指定した名前の型の識別に使用したトークン。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドがクライアントの場合に便利ですが、<xref:System.Reflection.Emit.MethodRental>メソッドの本体を直接変更を希望するクラス。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> が空の文字列 ("") です。  
  
- または - 
 <paramref name="name" /> が <see langword="ByRef" /> 型を表しています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" />です。  
  
- または - 
<paramref name="name" /> で指定された型が見つかりませんでした。</exception>
        <exception cref="T:System.InvalidOperationException">これは、遷移的モジュールを参照する非遷移的モジュールです。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeToken GetTypeToken (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Emit.TypeToken GetTypeToken(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.GetTypeToken(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::TypeToken GetTypeToken(Type ^ type);" />
      <MemberSignature Language="F#" Value="member this.GetTypeToken : Type -&gt; System.Reflection.Emit.TypeToken" Usage="moduleBuilder.GetTypeToken type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">クラス型を表す型オブジェクト。</param>
        <summary>このモジュール内で指定した型の識別に使用したトークンを返します。</summary>
        <returns>このモジュール内で指定した型の識別に使用したトークン。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 トークンは、Microsoft intermediate language (MSIL) 命令でオブジェクトを識別するために使用されます。 トークンは、モジュールが含まれています。 トークンの値など、`String`モジュール別にする可能性があります。 ときに`GetTypeToken`が呼び出されると、参照は、モジュールに追加されます。 参照は、モジュールの永続的な部分になります同じ引数を持つ複数の呼び出しは、その他の影響を与えるありません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> は <see langword="ByRef" /> 型です。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.InvalidOperationException">これは、遷移的モジュールを参照する非遷移的モジュールです。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public override bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="override this.IsDefined : Type * bool -&gt; bool" Usage="moduleBuilder.IsDefined (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">テストするカスタム属性の型。</param>
        <param name="inherit">この型のオブジェクトでは、この引数は無視されます。</param>
        <summary>指定された属性型がこのモジュールに適用されているかどうかを示す値を返します。</summary>
        <returns>このモジュールに <paramref name="attributeType" /> のインスタンスが 1 つ以上適用されている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="attributeType" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="attributeType" />は、ランタイムによって提供された <see cref="T:System.Type" /> オブジェクトではありません。 たとえば、<paramref name="attributeType" /> は <see cref="T:System.Reflection.Emit.TypeBuilder" /> オブジェクトです。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsResource">
      <MemberSignature Language="C#" Value="public override bool IsResource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsResource() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.IsResource" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsResource () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsResource();" />
      <MemberSignature Language="F#" Value="override this.IsResource : unit -&gt; bool" Usage="moduleBuilder.IsResource " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>オブジェクトがリソースかどうかを示す値を取得します。</summary>
        <returns>オブジェクトがリソースである場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTransient">
      <MemberSignature Language="C#" Value="public bool IsTransient ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsTransient() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.IsTransient" />
      <MemberSignature Language="VB.NET" Value="Public Function IsTransient () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsTransient();" />
      <MemberSignature Language="F#" Value="member this.IsTransient : unit -&gt; bool" Usage="moduleBuilder.IsTransient " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この動的モジュールが遷移的モジュールかどうかを示す値を返します。</summary>
        <returns>この動的モジュールが遷移的モジュールの場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MDStreamVersion">
      <MemberSignature Language="C#" Value="public override int MDStreamVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MDStreamVersion" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.ModuleBuilder.MDStreamVersion" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MDStreamVersion As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int MDStreamVersion { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MDStreamVersion : int" Usage="System.Reflection.Emit.ModuleBuilder.MDStreamVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>メタデータ ストリーム バージョンを取得します。</summary>
        <value>メタデータ ストリーム バージョンを表す 32 ビットの整数。 上位 2 バイトはメジャー バージョン番号を表し、下位 2 バイトはマイナー バージョン番号を表します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  メタデータ ヘッダーの詳細については、共通言語基盤 (CLI) のドキュメントに"Partition II:: Metadata Definition and Semantics"を参照してください。 このドキュメントはオンラインです。参照してください[ECMA c# および共通言語基盤の標準](http://go.microsoft.com/fwlink/?LinkID=99212)msdn および[標準 ECMA 335 の共通言語基盤 (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) ECMA の Web サイト。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MetadataToken">
      <MemberSignature Language="C#" Value="public override int MetadataToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MetadataToken" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.ModuleBuilder.MetadataToken" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MetadataToken As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int MetadataToken { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MetadataToken : int" Usage="System.Reflection.Emit.ModuleBuilder.MetadataToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>メタデータ内の現在の動的モジュールを識別するトークンを取得します。</summary>
        <value>メタデータ内の現在モジュールを識別する整数トークン。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 アンマネージ リフレクション API には、このプロパティを使用して取得したトークンを渡すことができます。 詳細については、次を参照してください。[アンマネージ リフレクション API](http://msdn.microsoft.com/library/0c5bb9de-0cf6-438d-ba47-134e6c775fb8)します。  
  
> [!NOTE]
>  共通言語基盤 (CLI) のドキュメントでは、特に"Partition II:: Metadata Definition and Semantics"メタデータ トークンに関する情報が見つかります。 このドキュメントはオンラインです。参照してください[ECMA c# および共通言語基盤の標準](http://go.microsoft.com/fwlink/?LinkID=99212)msdn および[標準 ECMA 335 の共通言語基盤 (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) ECMA の Web サイト。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuleVersionId">
      <MemberSignature Language="C#" Value="public override Guid ModuleVersionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid ModuleVersionId" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.ModuleBuilder.ModuleVersionId" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ModuleVersionId As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Guid ModuleVersionId { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.ModuleVersionId : Guid" Usage="System.Reflection.Emit.ModuleBuilder.ModuleVersionId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>モジュールの 2 つのバージョンを区別するために使用できる汎用一意識別子 (UUID) を取得します。</summary>
        <value>モジュールの 2 つのバージョンを区別するために使用できる <see cref="T:System.Guid" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 アンマネージ メタデータでは、によって返される GUID、<xref:System.Reflection.Module.ModuleVersionId%2A>プロパティと呼ばれる、 `mvid`、GUID ヒープに格納されます。  
  
> [!NOTE]
>  メタデータの詳細については、共通言語基盤 (CLI) のドキュメントでは、特に"Partition II:: Metadata Definition and Semantics"見つかんだことができます。 このドキュメントはオンラインです。参照してください[ECMA c# および共通言語基盤の標準](http://go.microsoft.com/fwlink/?LinkID=99212)msdn および[標準 ECMA 335 の共通言語基盤 (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) ECMA の Web サイト。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.ModuleBuilder.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Reflection.Emit.ModuleBuilder.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>これがメモリ内モジュールであることを示す文字列。</summary>
        <value>これがメモリ内モジュールであることを示すテキスト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 モジュールに保存され、ディスクから再読み込みされるまで、動的モジュールの名前を取得できません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResolveField">
      <MemberSignature Language="C#" Value="public override System.Reflection.FieldInfo ResolveField (int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.FieldInfo ResolveField(int32 metadataToken, class System.Type[] genericTypeArguments, class System.Type[] genericMethodArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.ResolveField(System.Int32,System.Type[],System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ResolveField (metadataToken As Integer, genericTypeArguments As Type(), genericMethodArguments As Type()) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::FieldInfo ^ ResolveField(int metadataToken, cli::array &lt;Type ^&gt; ^ genericTypeArguments, cli::array &lt;Type ^&gt; ^ genericMethodArguments);" />
      <MemberSignature Language="F#" Value="override this.ResolveField : int * Type[] * Type[] -&gt; System.Reflection.FieldInfo" Usage="moduleBuilder.ResolveField (metadataToken, genericTypeArguments, genericMethodArguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
        <Parameter Name="genericTypeArguments" Type="System.Type[]" />
        <Parameter Name="genericMethodArguments" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="metadataToken">モジュール内のフィールドを識別するメタデータ トークン。</param>
        <param name="genericTypeArguments">トークンがスコープ内にある型のジェネリック型引数を表す <see cref="T:System.Type" /> オブジェクトの配列。その型がジェネリックではない場合は <see langword="null" />。</param>
        <param name="genericMethodArguments">トークンがスコープ内にあるメソッドのジェネリック型引数を表す <see cref="T:System.Type" /> オブジェクトの配列。そのメソッドがジェネリックではない場合は <see langword="null" />。</param>
        <summary>指定したジェネリック型パラメーターで定義されたコンテキストの、指定したメタデータ トークンで識別されるフィールドを返します。</summary>
        <returns>指定したメタデータ トークンで識別されるフィールドを表す <see cref="T:System.Reflection.FieldInfo" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType>型のメソッド、`metadataToken`のジェネリック型引数の配列を取得するスコープに`genericTypeArguments`します。 使用して、<xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType>メソッドのメソッド、`metadataToken`のジェネリック型引数の配列を取得するスコープに`genericTypeArguments`。 不要な場合でも、これらの引数を用意することは常にします。  
  
> [!NOTE]
>  共通言語基盤 (CLI) のドキュメントでは、特に"Partition II:: Metadata Definition and Semantics"メタデータ トークンに関する情報が見つかります。 このドキュメントはオンラインです。参照してください[ECMA c# および共通言語基盤の標準](http://go.microsoft.com/fwlink/?LinkID=99212)msdn および[標準 ECMA 335 の共通言語基盤 (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) ECMA の Web サイト。  
  
 トークンの解像度を示すコードについて汎用コンテキスト (つまり、ジェネリック型や、トークンが埋め込まれているジェネリック メソッドのジェネリック型パラメーター) を使用して参照してください、<xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29?displayProperty=nameWithType>メソッド。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="metadataToken" /> は、現在のモジュールのスコープに含まれるフィールドのトークンではありません。  
  
- または - 
 <paramref name="metadataToken" /> は、親 <see langword="TypeSpec" /> が要素型 <see langword="var" /> (ジェネリック型の型パラメーター) または <see langword="mvar" /> (ジェネリック メソッドの型パラメーター) を含む署名を持つフィールドを識別しますが、必要なジェネリック型引数が <paramref name="genericTypeArguments" /> と <paramref name="genericMethodArguments" /> の両方またはいずれかに提供されていません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="metadataToken" /> は、現在のモジュールのスコープで有効なトークンではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveMember">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberInfo ResolveMember (int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MemberInfo ResolveMember(int32 metadataToken, class System.Type[] genericTypeArguments, class System.Type[] genericMethodArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.ResolveMember(System.Int32,System.Type[],System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ResolveMember (metadataToken As Integer, genericTypeArguments As Type(), genericMethodArguments As Type()) As MemberInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MemberInfo ^ ResolveMember(int metadataToken, cli::array &lt;Type ^&gt; ^ genericTypeArguments, cli::array &lt;Type ^&gt; ^ genericMethodArguments);" />
      <MemberSignature Language="F#" Value="override this.ResolveMember : int * Type[] * Type[] -&gt; System.Reflection.MemberInfo" Usage="moduleBuilder.ResolveMember (metadataToken, genericTypeArguments, genericMethodArguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
        <Parameter Name="genericTypeArguments" Type="System.Type[]" />
        <Parameter Name="genericMethodArguments" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="metadataToken">モジュール内の型またはメンバーを識別するメタデータ トークン。</param>
        <param name="genericTypeArguments">トークンがスコープ内にある型のジェネリック型引数を表す <see cref="T:System.Type" /> オブジェクトの配列。その型がジェネリックではない場合は <see langword="null" />。</param>
        <param name="genericMethodArguments">トークンがスコープ内にあるメソッドのジェネリック型引数を表す <see cref="T:System.Type" /> オブジェクトの配列。そのメソッドがジェネリックではない場合は <see langword="null" />。</param>
        <summary>指定したジェネリック型パラメーターで定義されたコンテキストの、指定したメタデータ トークンで識別される型またはメンバーを返します。</summary>
        <returns>指定したメタデータ トークンで識別される型またはメンバーを表す <see cref="T:System.Reflection.MemberInfo" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType>型のメソッド、`metadataToken`のジェネリック型引数の配列を取得するスコープに`genericTypeArguments`します。 使用して、<xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType>メソッドのメソッド、`metadataToken`のジェネリック型引数の配列を取得するスコープに`genericTypeArguments`。 不要な場合でも、これらの引数を用意することは常にします。  
  
> [!NOTE]
>  共通言語基盤 (CLI) のドキュメントでは、特に"Partition II:: Metadata Definition and Semantics"メタデータ トークンに関する情報が見つかります。 このドキュメントはオンラインです。参照してください[ECMA c# および共通言語基盤の標準](http://go.microsoft.com/fwlink/?LinkID=99212)msdn および[標準 ECMA 335 の共通言語基盤 (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) ECMA の Web サイト。  
  
 トークンの解像度を示すコードについて汎用コンテキスト (つまり、ジェネリック型や、トークンが埋め込まれているジェネリック メソッドのジェネリック型パラメーター) を使用して参照してください、<xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29?displayProperty=nameWithType>メソッド。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="metadataToken" /> は、現在のモジュールのスコープ内の型またはメンバーのトークンではありません。  
  
- または - 
 <paramref name="metadataToken" /> は、要素型 <see langword="var" /> (ジェネリック型の型パラメーター) または <see langword="mvar" /> (ジェネリック メソッドの型パラメーター) を含むシグネチャを持つ <see langword="MethodSpec" /> または <see langword="TypeSpec" /> ですが、必要なジェネリック型の引数が <paramref name="genericTypeArguments" /> と <paramref name="genericMethodArguments" /> の両方またはいずれかに提供されていません。  
  
- または - 
 <paramref name="metadataToken" /> は、プロパティまたはイベントを識別します。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="metadataToken" /> は、現在のモジュールのスコープで有効なトークンではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveMethod">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodBase ResolveMethod (int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodBase ResolveMethod(int32 metadataToken, class System.Type[] genericTypeArguments, class System.Type[] genericMethodArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.ResolveMethod(System.Int32,System.Type[],System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ResolveMethod (metadataToken As Integer, genericTypeArguments As Type(), genericMethodArguments As Type()) As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodBase ^ ResolveMethod(int metadataToken, cli::array &lt;Type ^&gt; ^ genericTypeArguments, cli::array &lt;Type ^&gt; ^ genericMethodArguments);" />
      <MemberSignature Language="F#" Value="override this.ResolveMethod : int * Type[] * Type[] -&gt; System.Reflection.MethodBase" Usage="moduleBuilder.ResolveMethod (metadataToken, genericTypeArguments, genericMethodArguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
        <Parameter Name="genericTypeArguments" Type="System.Type[]" />
        <Parameter Name="genericMethodArguments" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="metadataToken">メソッドまたはモジュール内のコンス トラクターを識別するメタデータ トークン。</param>
        <param name="genericTypeArguments">トークンがスコープ内にある型のジェネリック型引数を表す <see cref="T:System.Type" /> オブジェクトの配列。その型がジェネリックではない場合は <see langword="null" />。</param>
        <param name="genericMethodArguments">トークンがスコープ内にあるメソッドのジェネリック型引数を表す <see cref="T:System.Type" /> オブジェクトの配列。そのメソッドがジェネリックではない場合は <see langword="null" />。</param>
        <summary>指定したジェネリック型パラメーターで定義されたコンテキストの、指定したメタデータ トークンで識別されるメソッドまたはコンストラクターを返します。</summary>
        <returns>指定したメタデータ トークンで識別されるメソッドを表す <see cref="T:System.Reflection.MethodBase" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType>型のメソッド、`metadataToken`のジェネリック型引数の配列を取得するスコープに`genericTypeArguments`します。 使用して、<xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType>メソッドのメソッド、`metadataToken`のジェネリック型引数の配列を取得するスコープに`genericMethodArguments`。 不要な場合でも、これらの引数を用意することは常にします。  
  
> [!NOTE]
>  共通言語基盤 (CLI) のドキュメントでは、特に"Partition II:: Metadata Definition and Semantics"メタデータ トークンに関する情報が見つかります。 このドキュメントはオンラインです。参照してください[ECMA c# および共通言語基盤の標準](http://go.microsoft.com/fwlink/?LinkID=99212)msdn および[標準 ECMA 335 の共通言語基盤 (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) ECMA の Web サイト。  
  
 トークンの解像度を示すコードについて汎用コンテキスト (つまり、ジェネリック型や、トークンが埋め込まれているジェネリック メソッドのジェネリック型パラメーター) を使用して参照してください、<xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29?displayProperty=nameWithType>メソッド。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="metadataToken" /> は、現在のモジュールのスコープに含まれるメソッドまたはコンストラクターのトークンではありません。  
  
- または - 
 <paramref name="metadataToken" /> は、要素型 <see langword="var" /> (ジェネリック型の型パラメーター) または <see langword="mvar" /> (ジェネリック メソッドの型パラメーター) を含むシグネチャを持つ <see langword="MethodSpec" /> ですが、必要なジェネリック型引数が <paramref name="genericTypeArguments" /> と <paramref name="genericMethodArguments" />.の両方またはいずれかに提供されていません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="metadataToken" /> は、現在のモジュールのスコープで有効なトークンではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveSignature">
      <MemberSignature Language="C#" Value="public override byte[] ResolveSignature (int metadataToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] ResolveSignature(int32 metadataToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.ResolveSignature(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ResolveSignature (metadataToken As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Byte&gt; ^ ResolveSignature(int metadataToken);" />
      <MemberSignature Language="F#" Value="override this.ResolveSignature : int -&gt; byte[]" Usage="moduleBuilder.ResolveSignature metadataToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="metadataToken">モジュール内のシグネチャを識別するメタデータ トークン。</param>
        <summary>メタデータ トークンで識別されるシグネチャ BLOB を返します。</summary>
        <returns>シグネチャ BLOB を表すバイトの配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  共通言語基盤 (CLI) のドキュメントでは、特に"Partition II:: Metadata Definition and Semantics"メタデータ トークン、および署名に関する情報が見つかります。 このドキュメントはオンラインです。参照してください[ECMA c# および共通言語基盤の標準](http://go.microsoft.com/fwlink/?LinkID=99212)msdn および[標準 ECMA 335 の共通言語基盤 (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) ECMA の Web サイト。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="metadataToken" /> は、現在のモジュールのスコープで有効な <see langword="MemberRef" />、<see langword="MethodDef" />、<see langword="TypeSpec" />、シグネチャ、または <see langword="FieldDef" /> トークンではありません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="metadataToken" /> は、現在のモジュールのスコープで有効なトークンではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveString">
      <MemberSignature Language="C#" Value="public override string ResolveString (int metadataToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ResolveString(int32 metadataToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.ResolveString(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ResolveString (metadataToken As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ResolveString(int metadataToken);" />
      <MemberSignature Language="F#" Value="override this.ResolveString : int -&gt; string" Usage="moduleBuilder.ResolveString metadataToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="metadataToken">モジュールの文字列ヒープ内の文字列を識別するメタデータ トークン。</param>
        <summary>指定したメタデータ トークンで識別される文字列を返します。</summary>
        <returns>メタデータの文字列ヒープの文字列値を格納する <see cref="T:System.String" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  共通言語基盤 (CLI) のドキュメントでは、特に"Partition II:: Metadata Definition and Semantics"メタデータ トークンに関する情報が見つかります。 このドキュメントはオンラインです。参照してください[ECMA c# および共通言語基盤の標準](http://go.microsoft.com/fwlink/?LinkID=99212)msdn および[標準 ECMA 335 の共通言語基盤 (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) ECMA の Web サイト。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="metadataToken" /> は、現在のモジュールのスコープ内の文字列のトークンではありません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="metadataToken" /> は、現在のモジュールのスコープで有効なトークンではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveType">
      <MemberSignature Language="C#" Value="public override Type ResolveType (int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type ResolveType(int32 metadataToken, class System.Type[] genericTypeArguments, class System.Type[] genericMethodArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.ResolveType(System.Int32,System.Type[],System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ResolveType (metadataToken As Integer, genericTypeArguments As Type(), genericMethodArguments As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ ResolveType(int metadataToken, cli::array &lt;Type ^&gt; ^ genericTypeArguments, cli::array &lt;Type ^&gt; ^ genericMethodArguments);" />
      <MemberSignature Language="F#" Value="override this.ResolveType : int * Type[] * Type[] -&gt; Type" Usage="moduleBuilder.ResolveType (metadataToken, genericTypeArguments, genericMethodArguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
        <Parameter Name="genericTypeArguments" Type="System.Type[]" />
        <Parameter Name="genericMethodArguments" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="metadataToken">モジュール内の型を識別するメタデータ トークン。</param>
        <param name="genericTypeArguments">トークンがスコープ内にある型のジェネリック型引数を表す <see cref="T:System.Type" /> オブジェクトの配列。その型がジェネリックではない場合は <see langword="null" />。</param>
        <param name="genericMethodArguments">トークンがスコープ内にあるメソッドのジェネリック型引数を表す <see cref="T:System.Type" /> オブジェクトの配列。そのメソッドがジェネリックではない場合は <see langword="null" />。</param>
        <summary>指定したジェネリック型パラメーターで定義されたコンテキストの、指定したメタデータ トークンで識別される型を返します。</summary>
        <returns>指定したメタデータ トークンで識別される型を表す <see cref="T:System.Type" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType>型のメソッド、`metadataToken`のジェネリック型引数の配列を取得するスコープに`genericTypeArguments`します。 使用して、<xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType>メソッドのメソッド、`metadataToken`のジェネリック型引数の配列を取得するスコープに`genericTypeArguments`。 不要な場合でも、これらの引数を用意することは常にします。  
  
> [!NOTE]
>  共通言語基盤 (CLI) のドキュメントでは、特に"Partition II:: Metadata Definition and Semantics"メタデータ トークンに関する情報が見つかります。 このドキュメントはオンラインです。参照してください[ECMA c# および共通言語基盤の標準](http://go.microsoft.com/fwlink/?LinkID=99212)msdn および[標準 ECMA 335 の共通言語基盤 (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) ECMA の Web サイト。  
  
 トークンの解像度を示すコードについて汎用コンテキスト (つまり、ジェネリック型や、トークンが埋め込まれているジェネリック メソッドのジェネリック型パラメーター) を使用して参照してください、<xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29?displayProperty=nameWithType>メソッド。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="metadataToken" /> は、現在のモジュールのスコープに含まれる型のトークンではありません。  
  
- または - 
 <paramref name="metadataToken" /> は、要素型 <see langword="var" /> (ジェネリック型の型パラメーター) または <see langword="mvar" /> (ジェネリック メソッドの型パラメーター) を含むシグネチャを持つ <see langword="TypeSpec" /> ですが、必要なジェネリック型引数が <paramref name="genericTypeArguments" /> と <paramref name="genericMethodArguments" />.の両方またはいずれかに提供されていません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="metadataToken" /> は、現在のモジュールのスコープで有効なトークンではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="ScopeName">
      <MemberSignature Language="C#" Value="public override string ScopeName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ScopeName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.ModuleBuilder.ScopeName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ScopeName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ScopeName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ScopeName : string" Usage="System.Reflection.Emit.ModuleBuilder.ScopeName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>動的モジュールの名前を表す文字列を取得します。</summary>
        <value>動的アセンブリの名前。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetCustomAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>カスタム属性をこのモジュールに適用します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetCustomAttribute (System.Reflection.Emit.CustomAttributeBuilder customBuilder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCustomAttribute(class System.Reflection.Emit.CustomAttributeBuilder customBuilder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCustomAttribute (customBuilder As CustomAttributeBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCustomAttribute(System::Reflection::Emit::CustomAttributeBuilder ^ customBuilder);" />
      <MemberSignature Language="F#" Value="member this.SetCustomAttribute : System.Reflection.Emit.CustomAttributeBuilder -&gt; unit" Usage="moduleBuilder.SetCustomAttribute customBuilder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="customBuilder" Type="System.Reflection.Emit.CustomAttributeBuilder" />
      </Parameters>
      <Docs>
        <param name="customBuilder">適用するカスタム属性を指定するためのヘルパー クラスのインスタンス。</param>
        <summary>カスタム属性ビルダーを使用して、カスタム属性をこのモジュールに適用します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  以降では、 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]、このメンバーが不要<xref:System.Security.Permissions.ReflectionPermission>で、<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>フラグ。 (を参照してください[出力のセキュリティ関連事項リフレクション](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md))。この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="customBuilder" /> は <see langword="null" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetCustomAttribute (System.Reflection.ConstructorInfo con, byte[] binaryAttribute);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCustomAttribute(class System.Reflection.ConstructorInfo con, unsigned int8[] binaryAttribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCustomAttribute (con As ConstructorInfo, binaryAttribute As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCustomAttribute(System::Reflection::ConstructorInfo ^ con, cli::array &lt;System::Byte&gt; ^ binaryAttribute);" />
      <MemberSignature Language="F#" Value="member this.SetCustomAttribute : System.Reflection.ConstructorInfo * byte[] -&gt; unit" Usage="moduleBuilder.SetCustomAttribute (con, binaryAttribute)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="con" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="binaryAttribute" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="con">カスタム属性のコンストラクター。</param>
        <param name="binaryAttribute">属性を表すバイト BLOB。</param>
        <summary>属性を表す指定したバイナリ ラージ オブジェクト (BLOB) を使用して、カスタム属性をこのモジュールに適用します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 書式設定する方法の詳細についての`binaryAttribute`、共通言語基盤 (CLI) のドキュメント、特に「Partition II:: メタデータ Definition and Semantics」を参照してください。 ドキュメントはオンラインで入手できます。MSDN の「[ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212)」 (ECMA の C# および共通言語基盤の標準規格) と、ECMA のインターナショナル Web サイトにある「[Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552)」を参照してください。  
  
> [!NOTE]
>  以降では、 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]、このメンバーが不要<xref:System.Security.Permissions.ReflectionPermission>で、<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>フラグ。 (を参照してください[出力のセキュリティ関連事項リフレクション](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md))。この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="con" /> または <paramref name="binaryAttribute" /> が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetSymCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetSymCustomAttribute (string name, byte[] data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSymCustomAttribute(string name, unsigned int8[] data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.SetSymCustomAttribute(System.String,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSymCustomAttribute (name As String, data As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSymCustomAttribute(System::String ^ name, cli::array &lt;System::Byte&gt; ^ data);" />
      <MemberSignature Language="F#" Value="member this.SetSymCustomAttribute : string * byte[] -&gt; unit" Usage="moduleBuilder.SetSymCustomAttribute (name, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="name">カスタム属性の名前。</param>
        <param name="data">カスタム属性の値を表すバイトの非透過バイナリ ラージ オブジェクト (BLOB)。</param>
        <summary>このメソッドは何も実行しません。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは何も実行しません。  
  
> [!NOTE]
>  以降では、 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]、このメンバーが不要<xref:System.Security.Permissions.ReflectionPermission>で、<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>フラグ。 (を参照してください[出力のセキュリティ関連事項リフレクション](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md))。この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="url" /> は <see langword="null" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetUserEntryPoint">
      <MemberSignature Language="C#" Value="public void SetUserEntryPoint (System.Reflection.MethodInfo entryPoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetUserEntryPoint(class System.Reflection.MethodInfo entryPoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.SetUserEntryPoint(System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetUserEntryPoint (entryPoint As MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetUserEntryPoint(System::Reflection::MethodInfo ^ entryPoint);" />
      <MemberSignature Language="F#" Value="member this.SetUserEntryPoint : System.Reflection.MethodInfo -&gt; unit" Usage="moduleBuilder.SetUserEntryPoint entryPoint" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entryPoint" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="entryPoint">ユーザー エントリ ポイント。</param>
        <summary>ユーザー エントリ ポイントを設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コンパイラは、メイン ユーザーを呼び出す前にスタートアップ スタブを生成する可能性があります。 スタートアップのスタブをエントリ ポイントとなります。 コンパイラのエントリ ポイントにデバッガーがステップはしないように、メインのユーザーはユーザー エントリ ポイントをします。  
  
> [!NOTE]
>  以降では、 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]、このメンバーが不要<xref:System.Security.Permissions.ReflectionPermission>で、<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>フラグ。 (を参照してください[出力のセキュリティ関連事項リフレクション](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md))。この機能を使用するには、アプリケーションで [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 以降を対象とする必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="entryPoint" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.InvalidOperationException">このメソッドは、デバッグ モジュールではない動的モジュールに対して呼び出されます。  
  
- または - 
 <paramref name="entryPoint" /> が、この動的モジュールに格納されていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._ModuleBuilder.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _ModuleBuilder.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._ModuleBuilder.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _ModuleBuilder.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._ModuleBuilder.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_ModuleBuilder::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._ModuleBuilder.GetIDsOfNames(System.Guid,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">将来使用するために予約されています。 IID_NULL にする必要があります。</param>
        <param name="rgszNames">マッピング対象として渡される名前の配列。</param>
        <param name="cNames">マッピングされる名前のカウント。</param>
        <param name="lcid">名前を解釈するロケール コンテキスト。</param>
        <param name="rgDispId">名前に対応する ID を受け取る、呼び出し元が割り当てた配列。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.Runtime.InteropServices._ModuleBuilder.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />」をご覧ください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびマネージ コードから呼び出さないでいます。 詳細については`IDispatch::GetIDsOfNames`、MSDN ライブラリを参照してください。  
  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Reflection.Emit.ModuleBuilder> のインスタンスが <xref:System.Runtime.InteropServices._ModuleBuilder> インターフェイスにキャストされる場合のみ、使用できます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">このメソッドは COM <c>IDispatch</c> インターフェイスを使用して遅延バインディングで呼び出されます。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._ModuleBuilder.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _ModuleBuilder.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._ModuleBuilder.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _ModuleBuilder.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._ModuleBuilder.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_ModuleBuilder::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._ModuleBuilder.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">返される型情報。</param>
        <param name="lcid">型情報のロケール ID。</param>
        <param name="ppTInfo">要求された型情報オブジェクトへのポインター。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.Runtime.InteropServices._ModuleBuilder.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />」をご覧ください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびマネージ コードから呼び出さないでいます。 詳細については`IDispatch::GetTypeInfo`、MSDN ライブラリを参照してください。  
  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Reflection.Emit.ModuleBuilder> のインスタンスが <xref:System.Runtime.InteropServices._ModuleBuilder> インターフェイスにキャストされる場合のみ、使用できます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">このメソッドは COM <c>IDispatch</c> インターフェイスを使用して遅延バインディングで呼び出されます。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._ModuleBuilder.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _ModuleBuilder.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._ModuleBuilder.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _ModuleBuilder.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._ModuleBuilder.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_ModuleBuilder::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._ModuleBuilder.GetTypeInfoCount(System.UInt32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">オブジェクトによって提供される型情報インターフェイスの数を受け取る場所。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.Runtime.InteropServices._ModuleBuilder.GetTypeInfoCount(System.UInt32@)" />」をご覧ください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびマネージ コードから呼び出さないでいます。 詳細については`IDispatch::GetTypeInfoCount`、MSDN ライブラリを参照してください。  
  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Reflection.Emit.ModuleBuilder> のインスタンスが <xref:System.Runtime.InteropServices._ModuleBuilder> インターフェイスにキャストされる場合のみ、使用できます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">このメソッドは COM <c>IDispatch</c> インターフェイスを使用して遅延バインディングで呼び出されます。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._ModuleBuilder.Invoke">
      <MemberSignature Language="C#" Value="void _ModuleBuilder.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._ModuleBuilder.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.ModuleBuilder.System#Runtime#InteropServices#_ModuleBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _ModuleBuilder.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._ModuleBuilder.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_ModuleBuilder::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._ModuleBuilder.Invoke(System.UInt32,System.Guid,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">メンバー ID。</param>
        <param name="riid">将来使用するために予約されています。 IID_NULL にする必要があります。</param>
        <param name="lcid">引数を解釈する対象のロケール コンテキスト。</param>
        <param name="wFlags">呼び出しのコンテキストを記述するフラグ。</param>
        <param name="pDispParams">引数の配列、名前付き引数の DISPID の配列、配列内の要素数のカウントを格納している構造体へのポインター。</param>
        <param name="pVarResult">結果が格納される場所へのポインター。</param>
        <param name="pExcepInfo">例外情報を格納する構造体へのポインター。</param>
        <param name="puArgErr">エラーが存在する最初の引数のインデックス。</param>
        <summary>このメンバーの詳細については、「<see cref="M:System.Runtime.InteropServices._ModuleBuilder.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />」をご覧ください。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびマネージ コードから呼び出さないでいます。 詳細については`IDispatch::Invoke`、MSDN ライブラリを参照してください。  
  
 このメンバーは、明示的なインターフェイス メンバーの実装です。 これは、<xref:System.Reflection.Emit.ModuleBuilder> のインスタンスが <xref:System.Runtime.InteropServices._ModuleBuilder> インターフェイスにキャストされる場合のみ、使用できます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">このメソッドは COM <c>IDispatch</c> インターフェイスを使用して遅延バインディングで呼び出されます。</exception>
      </Docs>
    </Member>
  </Members>
</Type>