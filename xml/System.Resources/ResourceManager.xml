<Type Name="ResourceManager" FullName="System.Resources.ResourceManager">
  <Metadata><Meta Name="ms.openlocfilehash" Value="1f4576691fe95ae036b83eb8f7fd45935ddefe96" /><Meta Name="ms.sourcegitcommit" Value="a3e01ec36374fac54a55add0dcc1e754e394abeb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="03/30/2019" /><Meta Name="ms.locfileid" Value="58729889" /></Metadata><TypeSignature Language="C#" Value="public class ResourceManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit ResourceManager extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Resources.ResourceManager" />
  <TypeSignature Language="VB.NET" Value="Public Class ResourceManager" />
  <TypeSignature Language="C++ CLI" Value="public ref class ResourceManager" />
  <TypeSignature Language="F#" Value="type ResourceManager = class" />
  <AssemblyInfo>
    <AssemblyName>System.Resources.ResourceManager</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netstandard-1.0;netstandard-1.1;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
      <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6">
      <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>実行時にカルチャ固有のリソースにアクセスする便利な手段を提供するリソース マネージャーを表します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE [untrusted-data-class-note](~/includes/untrusted-data-class-note.md)]

 <xref:System.Resources.ResourceManager> クラスは、アセンブリに埋め込まれているバイナリ .resources ファイル、または、スタンドアロンの .resources ファイルからリソースを取得します。 アプリがローカライズされ、ローカライズされたリソースが[サテライト アセンブリ](~/docs/framework/resources/creating-satellite-assemblies-for-desktop-apps.md)に配置されているなら、アプリは、カルチャ固有のリソースを検索し、ローカライズされたリソースが存在しない場合は、リソース フォールバックを提供します。また、リソースのシリアル化をサポートします。  
  
 デスクトップ アプリや [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] アプリでのリソース作成および管理の詳細については、次のセクションを参照してください。  
  
-   [デスクトップ アプリ](#desktop)  
  
    -   [リソースの作成](#creating_resources)  
  
    -   [ResourceManager オブジェクトのインスタンス化](#instantiating)  
  
    -   [ResourceManager とカルチャ固有のリソース](#CultureSpecific)  
  
    -   [リソースの取得](#retrieving)  
  
    -   [MissingManifestResourceException および MissingSatelliteAssemblyException 例外の処理](#exception)  
  
    -   [リソースのバージョン管理](#versioning)  
  
    -   [\<satelliteassemblies> 構成ファイルのノード](#config)  
  
-   [Windows ストア アプリ](#ws)  
  
<a name="desktop"></a>   
## <a name="desktop-apps"></a>デスクトップ アプリ  
 デスクトップ アプリの場合、<xref:System.Resources.ResourceManager> クラスは、バイナリ リソース (.resources) ファイルからリソースを取得します。 通常は、言語コンパイラか[アセンブリ リンカー (AL.exe)](~/docs/framework/tools/al-exe-assembly-linker.md) がアセンブリにこれらのリソース ファイルを埋め込みます。 <xref:System.Resources.ResourceManager.CreateFileBasedResourceManager%2A> メソッドを呼び出すことによって、<xref:System.Resources.ResourceManager> オブジェクトを使用して、アセンブリに埋め込まれていない .resources ファイルからリソースを直接取得できます。  
  
> [!CAUTION]
>  ASP.NET アプリでスタンドアロン .resources ファイルを使用すると、XCOPY による配置が中断されます。<xref:System.Resources.ResourceManager.ReleaseAllResources%2A> メソッドによって明示的に解放されるまで、リソースがロックされたままになるためです。 ASP.NET アプリでリソースを配置する場合は、サテライト アセンブリに .resources ファイルをコンパイルする必要があります。  
  
 リソース ベースのアプリでは、1 つの .resources ファイルは既定のカルチャのリソースを含んでいます。そのリソースは、カルチャ固有のリソースが見つからない場合に使用されます。 たとえば、アプリの既定のカルチャが英語 (en) の場合は、英語 (米国) (en-US) やフランス語 (フランス) (fr-FR) などの、特定のカルチャに対してローカライズされたリソースが見つからないときに、英語の言語リソースが使用されます。 通常は、既定のカルチャのリソースはメイン アプリ アセンブリに埋め込まれ、他のローカライズされたリソースはサテライト アセンブリに埋め込まれます。 サテライト アセンブリはリソースのみを含みます。 サテライト アセンブリは、メイン アセンブリと同じルート ファイル名と、resources.dll の拡張子を持ちます。 アプリのアセンブリがグローバル アセンブリ キャッシュに登録されていない場合は、サテライト アセンブリは、アセンブリのカルチャに対応する名前を持つ、アプリのサブディレクトリに格納されます。  
  
<a name="creating_resources"></a>   
### <a name="creating-resources"></a>リソースの作成  
 リソース ベースのアプリを開発する際は、テキスト ファイル (.txt か .restext 拡張子を持つファイル) または XML ファイル (.resx 拡張子を持つファイル) にリソース情報を格納します。 それから[リソース ファイル ジェネレーター (Resgen.exe)](~/docs/framework/tools/resgen-exe-resource-file-generator.md) を使用して、テキスト ファイルまたは XML ファイルをコンパイルし、バイナリ .resources ファイルを作成します。 C# や Visual Basic コンパイラにおける `/resources` のようなコンパイラ オプションを使用して、作成した .resources ファイルを実行可能ファイルまたはライブラリに埋め込むことができます。または、アセンブリ リンカー (Al.exe) を使用して、サテライト アセンブリに埋め込むことができます。 Visual Studio プロジェクトに .resx ファイルを含めると、Visual Studio はビルド プロセスの一部として、既定のリソースとローカライズされたリソースのコンパイルおよび埋め込みを自動的に処理します。  
  
 理想的には、アプリがサポートするすべての言語か、少なくとも各言語で意味をなすサブセットに対して、リソースを作成してください。 バイナリ .resources ファイルの名前は、*basename*.*cultureName*.resources の名前付け規則に従います。ここで *basename* は、必要な詳細のレベルに応じて、アプリの名前またはクラスの名前になります。 *cultureName* を判断するには、<xref:System.Globalization.CultureInfo.Name%2A?displayProperty=nameWithType> プロパティを使用します。 アプリの既定のカルチャのリソースには、*basename*.resources の名前をつけてください。  
  
 たとえば、ベースの名前に MyResources を持つリソース ファイルにいくつかのリソースが含まれているアセンブリを想定します。 これらのリソース ファイルは、日本 (日本語) のカルチャには MyResources.ja-JP.resources、ドイツのカルチャには MyResources.de.resources、簡体字中国語のカルチャには MyResources.zh-CHS.resources、フランス語 (ベルギー) のカルチャには MyResources.fr-BE.resources、などの名前を持つ必要があります。 既定のリソース ファイルは MyResources.resources の名前を持つ必要があります。 通常は、カルチャ固有のリソース ファイルは、カルチャごとにサテライト アセンブリにパッケージ化されます。 既定のリソース ファイルは、アプリのメイン アセンブリに埋め込まれる必要があります。  
  
 注意として、リソースをプライベートとしてマークできますが、他のアセンブリからアクセスできるように、常にリソースをパブリックとしてマークしてください。 (サテライト アセンブリはコードを含まないため、プライベートとしてマークされたリソースは、どんな方法を使ってもアプリで使用できません。)  
  
 リソースの作成、パッケージ化、および、配置の詳細については、[リソース ファイルの作成](~/docs/framework/resources/creating-resource-files-for-desktop-apps.md)、[サテライト アセンブリの作成](~/docs/framework/resources/creating-satellite-assemblies-for-desktop-apps.md)、[リソースのパッケージ化と配置](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md)の記事を参照してください。  
  
<a name="instantiating"></a>   
### <a name="instantiating-a-resourcemanager-object"></a>ResourceManager オブジェクトのインスタンス化  
 埋め込まれた .resources ファイルからリソースを取得する <xref:System.Resources.ResourceManager> オブジェクトのインスタンス化は、それのクラス コンストラクターのオーバーロードの 1 つを呼び出すことによって行います。 これは、<xref:System.Resources.ResourceManager> オブジェクトを、特定の .resources ファイルや、サテライト アセンブリにあり関連するローカライズされた .resources ファイルとを密に結びつけます。  
  
 最もよく呼び出されるコンストラクターは次の 2 つです。  
  
-   <xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29> は、指定した 2 つの情報に基づいてリソースを検索します。それらは .resources ファイルのベース名と、既定の .resources ファイルが存在するアセンブリです。 ベース名は、.resources ファイルの名前空間とルート名を含み、それのカルチャや拡張子を含みません。 コマンド ラインからコンパイルされた .resources ファイルは、通常は名前空間の名前を含みませんが、Visual Studio 環境で作成した .resources ファイルはそれを含むことに注意してください。 たとえば、リソース ファイルの名前が MyCompany.StringResources.resources であり、`Example.Main` という名前の静的メソッドから <xref:System.Resources.ResourceManager> コンストラクターを呼び出す場合、次のコードが .resources ファイルからリソースを取得できる <xref:System.Resources.ResourceManager> オブジェクトをインスタンス化します。  
  
     [!code-csharp[Conceptual.Resources.Retrieving#1](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.retrieving/cs/ctor1.cs#1)]
     [!code-vb[Conceptual.Resources.Retrieving#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.retrieving/vb/ctor1.vb#1)]  
  
-   <xref:System.Resources.ResourceManager.%23ctor%28System.Type%29> は、型オブジェクトからの情報に基づいて、サテライト アセンブリにあるリソースを検索します。 型の完全修飾名は、ファイル名の拡張子を含まない .resources ファイルのベース名に対応します。 Visual Studio リソース デザイナーを使用して作成されたデスクトップ アプリでは、Visual Studio は .resources ファイルのルート名と同じ完全修飾名を持つラッパー クラスを作成します。 たとえば、リソース ファイルの名前が MyCompany.StringResources.resources であり、`MyCompany.StringResources` という名前のラッパー クラスがある場合、次のコードが .resources ファイルからリソースを取得できる <xref:System.Resources.ResourceManager> オブジェクトをインスタンス化します。  
  
     [!code-csharp[Conceptual.Resources.Retrieving#2](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.retrieving/cs/ctor1.cs#2)]
     [!code-vb[Conceptual.Resources.Retrieving#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.retrieving/vb/ctor1.vb#2)]  
  
 適切なリソースが見つからない場合、コンストラクターの呼び出しは有効な <xref:System.Resources.ResourceManager> オブジェクトを作成します。 ただし、リソースを取得しようとすると、<xref:System.Resources.MissingManifestResourceException> 例外がスローされます。 例外に対処する方法については、この記事で後述する [MissingManifestResourceException および MissingSatelliteAssemblyException 例外の処理](#exception)を参照してください。  
  
 次の例は、<xref:System.Resources.ResourceManager> オブジェクトをインスタンス化する方法を示しています。 それには ShowTime.exe という名前の実行可能ファイルのソース コードが含まれています。 また、次に示す `TimeHeader` という唯一の文字列リソースを含む、Strings.txt という名前のテキスト ファイルも含まれます。  
  
```  
TimeHeader=The current time is  
```  
  
 バッチ ファイルを使用して、リソース ファイルを生成し、実行可能ファイルに埋め込むことができます。 C# コンパイラを使用して、実行可能ファイルを生成するバッチ ファイルを次に示します。  
  
```  
  
resgen strings.txt  
csc ShowTime.cs /resource:strings.resources  
  
```  
  
 Visual Basic コンパイラでは、次のバッチ ファイルを使用できます。  
  
```  
  
resgen strings.txt  
vbc ShowTime.vb /resource:strings.resources  
  
```  
  
 [!code-csharp[System.Resources.ResourceManager.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.class/cs/showtime.cs#1)]
 [!code-vb[System.Resources.ResourceManager.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.class/vb/showtime.vb#1)]  
  
<a name="CultureSpecific"></a>   
### <a name="resourcemanager-and-culture-specific-resources"></a>ResourceManager とカルチャ固有のリソース  
 [リソースのパッケージ化と配置](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md)の記事で説明したように、ローカライズされたアプリはリソースを配置する必要があります。 アセンブリが正しく構成されているなら、リソース マネージャーは、現在のスレッドの <xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType> プロパティに基づいて、どのリソースを取得するかを決定します。 (そのプロパティは現在のスレッドの UI カルチャを返します。) たとえば、メイン アセンブリに既定の英語の言語リソースがあり、2 つのサテライト アセンブリにフランス語とロシア語の言語リソースがあるようにアプリがコンパイルされていて、<xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType> プロパティが fr-FR に設定されている場合、リソース マネージャーはフランス語のリソースを取得します。  
  
 <xref:System.Globalization.CultureInfo.CurrentUICulture%2A> プロパティは明示的または暗黙的に設定できます。 それを設定する方法によって、<xref:System.Resources.ResourceManager> オブジェクトがカルチャに基づいてリソースを取得する方法が決定されます。  
  
-   明示的に <xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType> プロパティに特定のカルチャを設定する場合、リソース マネージャーは常に、ユーザーのブラウザーまたはオペレーティング システムの言語に関係なく、そのカルチャのリソースを取得します。 既定の英語の言語リソースと、英語 (米国)、フランス語 (フランス)、およびロシア語 (ロシア) のリソースを含む 3 つのサテライト アセンブリとともにコンパイルされているアプリを考えます。 <xref:System.Globalization.CultureInfo.CurrentUICulture%2A> プロパティが fr-FR に設定されている場合、たとえユーザーのオペレーティング システムの言語がフランス語ではないとしても、<xref:System.Resources.ResourceManager> オブジェクトは常にフランス語 (フランス) のリソースを取得します。 プロパティを明示的に設定する前に、これが目的の動作であることを確認してください。  
  
     ASP.NET アプリでは、サーバーの設定が受信したクライアント要求と一致しない可能性があるため、<xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType> プロパティを明示的に設定する必要があります。 ASP.NET アプリは <xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType> プロパティをユーザーのブラウザーが受け入れ可能な言語に明示的に設定できます。  
  
     <xref:System.Threading.Thread.CurrentUICulture%2A?displayProperty=nameWithType> プロパティを明示的に設定することによって、そのスレッドの現在の UI カルチャが定義されます。 これは、アプリの他のスレッドの現在の UI カルチャには影響しません。  
  
-   <xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=nameWithType> 静的プロパティに UI カルチャを表す <xref:System.Globalization.CultureInfo> オブジェクトを割り当てることで、アプリ ドメイン内のすべてのスレッドの UI カルチャを設定できます。  
  
-   現在の UI カルチャを明示的に設定せず、現在のアプリ ドメインに既定のカルチャを定義しない場合、<xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType> プロパティは Windows の `GetUserDefaultUILanguage` 関数によって暗黙的に設定されます。 この関数は Multilingual User Interface (MUI) によって提供されます。MUI は、ユーザーが既定の言語を設定できるようにします。 UI 言語がユーザーによって設定されていない場合、その既定値はシステムによってインストールされた言語になります。これはオペレーティング システムのリソースの言語です。  
  
 次の単純な "Hello world" の例では、現在の UI カルチャを明示的に設定します。 これには、英語 (米国) (en-US)、フランス語 (フランス) (fr-FR)、およびロシア語 (ロシア) (ru-RU) の 3 つのカルチャのリソースが含まれています。 en-US のリソースは、Greetings.txt という名前のテキスト ファイルに含まれています。  
  
```  
HelloString=Hello world!  
```  
  
 fr-FR のリソースは、Greetings.fr-FR.txt という名前のテキスト ファイルに含まれています。  
  
```  
HelloString=Salut tout le monde!  
```  
  
 ru-RU のリソースは、Greetings.ru-RU.txt という名前のテキスト ファイルに含まれています。  
  
```  
HelloString=Всем привет!  
```  
  
 次に、この例のソース コード (Visual Basic バージョンの Example.vb または C# バージョンの Example.cs) を示します。  
  
 [!code-csharp[Conceptual.Resources.CurrentCulture#1](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.currentculture/cs/example.cs#1)]
 [!code-vb[Conceptual.Resources.CurrentCulture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.currentculture/vb/example.vb#1)]  
  
 この例をコンパイルするには、次のコマンドを含むバッチ (.bat) ファイルを作成し、コマンド プロンプトからそれを実行します。 C# を使用している場合は、`vbc` の代わりに `csc` を指定し、`Example.vb` の代わりに `Example.cs` を指定します。  
  
```  
resgen Greetings.txt   
vbc Example.vb /resource:Greetings.resources  
  
resgen Greetings.fr-FR.txt  
Md fr-FR  
al /embed:Greetings.fr-FR.resources /culture:fr-FR /out:fr-FR\Example.resources.dll  
  
resgen Greetings.ru-RU.txt  
Md ru-RU  
al /embed:Greetings.ru-RU.resources /culture:ru-RU /out:ru-RU\Example.resources.dll  
```  
  
<a name="retrieving"></a>   
### <a name="retrieving-resources"></a>リソースの取得  
 特定のリソースにアクセスするには、<xref:System.Resources.ResourceManager.GetObject%28System.String%29> と <xref:System.Resources.ResourceManager.GetString%28System.String%29> メソッドを呼び出します。 <xref:System.Resources.ResourceManager.GetStream%28System.String%29> メソッドを呼び出して、文字列以外のリソースをバイト配列として取得することもできます。 既定では、リソースがローカライズされているアプリでは、これらのメソッドは、呼び出しを行ったスレッドの現在の UI カルチャによって決定されるカルチャのリソースを返します。 スレッドの現在の UI カルチャを定義する方法の詳細については、前のセクションの [ResourceManager とカルチャ固有のリソース](#CultureSpecific)を参照してください。 リソース マネージャーが現在のスレッドの UI カルチャのリソースを見つけられない場合は、フォールバック プロセスを使用して、指定したリソースを取得します。 リソース マネージャーがローカライズされたリソースを何も見つけられない場合は、既定のカルチャのリソースを使用します。 リソース フォールバック規則の詳細については、[リソースのパッケージ化と配置](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md)の記事内の「リソース フォールバック プロセス」セクションを参照してください。  
  
> [!NOTE]
>  <xref:System.Resources.ResourceManager> クラスのコンストラクターで指定された .resources ファイルが見つからない場合、リソースを取得しようとすると、<xref:System.Resources.MissingManifestResourceException> または <xref:System.Resources.MissingSatelliteAssemblyException> 例外がスローされます。 例外に対処する方法については、この記事で後述する [MissingManifestResourceException および MissingSatelliteAssemblyException 例外の処理](#exception)を参照してください。  
  
 次の例では、<xref:System.Resources.ResourceManager.GetString%2A> メソッドを使用して、カルチャ固有のリソースを取得します。 これは、英語 (en)、フランス語 (フランス) (fr-FR)、およびロシア語 (ロシア) (ru-RU) の .txt ファイルからコンパイルされたリソースで構成されます。 例では、現在のカルチャと現在の UI カルチャを、英語 (米国)、フランス語 (フランス)、ロシア語 (ロシア)、およびスウェーデン語 (スウェーデン) に変更します。 それから、<xref:System.Resources.ResourceManager.GetString%2A> メソッドを呼び出して、ローカライズされた文字列を取得します。この文字列は現在の日付と月と一緒に表示されます。 現在の UI カルチャがスウェーデン語 (スウェーデン) である場合を除き、適切なローカライズされた文字列が出力に表示されることに注意してください。 スウェーデン語の言語リソースが利用できないため、アプリは代わりに既定のカルチャである英語のリソースを使用します。  
  
 例には、次の表に記載されたテキスト ベースのリソース ファイルが必要です。 それぞれには `DateStart` という名前の唯一の文字列リソースがあります。  
  
|カルチャ|ファイル名|リソース名|リソースの値|  
|-------------|---------------|-------------------|--------------------|  
|en-US|DateStrings.txt|`DateStart`|Today is|  
|fr-FR|DateStrings.fr-FR.txt|`DateStart`|Aujourd'hui, c'est le|  
|ru-RU|DateStrings.ru-RU.txt|`DateStart`|Сегодня|  
  
 次に、この例のソース コード (Visual Basic バージョンの ShowDate.vb または C# バージョンの ShowDate.cs) を示します。  
  
 [!code-csharp[System.Resources.ResourceManager.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.class/cs/showdate.cs#2)]
 [!code-vb[System.Resources.ResourceManager.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.class/vb/showdate.vb#2)]  
  
 この例をコンパイルするには、次のコマンドを含むバッチ ファイルを作成し、コマンド プロンプトからそれを実行します。 C# を使用している場合は、`vbc` の代わりに `csc` を指定し、`showdate.vb` の代わりに `showdate.cs` を指定します。  
  
```  
  
resgen DateStrings.txt  
vbc showdate.vb /resource:DateStrings.resources  
  
md fr-FR  
resgen DateStrings.fr-FR.txt  
al /out:fr-FR\Showdate.resources.dll /culture:fr-FR /embed:DateStrings.fr-FR.resources   
  
md ru-RU  
resgen DateStrings.ru-RU.txt  
al /out:ru-RU\Showdate.resources.dll /culture:ru-RU /embed:DateStrings.ru-RU.resources  
  
```  
  
 現在の UI カルチャ以外の特定のカルチャのリソースを取得する方法は 2 つあります。  
  
-   <xref:System.Resources.ResourceManager.GetString%28System.String%2CSystem.Globalization.CultureInfo%29>、<xref:System.Resources.ResourceManager.GetObject%28System.String%2CSystem.Globalization.CultureInfo%29>、または<xref:System.Resources.ResourceManager.GetStream%28System.String%2CSystem.Globalization.CultureInfo%29> メソッドを呼び出して、指定したカルチャのリソースを取得できます。 ローカライズされたリソースが見つからない場合、リソース マネージャーはリソース フォールバック プロセスを使用して、適切なリソースを見つけます。  
  
-   <xref:System.Resources.ResourceManager.GetResourceSet%2A> メソッドを呼び出して、特定のカルチャのリソースを表す <xref:System.Resources.ResourceSet> オブジェクトを取得できます。 メソッドの呼び出しでは、ローカライズされたリソースが見つからない場合に、親カルチャのリソース マネージャーのプローブを作成するかどうかや、単純に既定のカルチャのリソースにフォールバックするかどうかを指定できます。 その後、<xref:System.Resources.ResourceSet> のメソッドを使用して、(そのカルチャに向けてローカライズされた) リソースに名前でアクセスしたり、または、セット内のリソースを列挙したりできます。  
  
<a name="exception"></a>   
### <a name="handling-missingmanifestresourceexception-and-missingsatelliteassemblyexception-exceptions"></a>MissingManifestResourceException および MissingSatelliteAssemblyException 例外の処理  
 特定のリソースを取得しようとしても、リソース マネージャーがそのリソースを見つけられないときに、既定のカルチャが定義されていないか、または既定のカルチャのリソースが見つからない場合、リソース マネージャーは、メイン アセンブリにリソースを探しているなら、<xref:System.Resources.MissingManifestResourceException> 例外をスローし、サテライト アセンブリにリソースを探しているなら、<xref:System.Resources.MissingSatelliteAssemblyException> 例外をスローします。 例外がスローされるのは、<xref:System.Resources.ResourceManager.GetString%2A> や <xref:System.Resources.ResourceManager.GetObject%2A> などのリソース取得メソッドを呼び出すときであり、<xref:System.Resources.ResourceManager> オブジェクトをインスタンス化するときではないことに注意してください。  
  
 次の条件下では、通常、例外がスローされます。  
  
-   適切なリソース ファイルまたはサテライト アセンブリが存在しません。 リソース マネージャーによって、アプリの既定のリソースがメイン アプリ アセンブリに埋め込まれていることが期待される場合に、それらが存在しません。 <xref:System.Resources.NeutralResourcesLanguageAttribute> 属性によって、アプリの既定のリソースがサテライト アセンブリに存在することが指示されている場合に、そのアセンブリが見つかりません。 アプリをコンパイルするときに、リソースがメイン アセンブリに埋め込まれているか、あるいは必要なサテライト アセンブリが生成され、適切な名前がついていることを確認します。 その名前は *appName*.resources.dll の形式をとる必要があります。また、含まれているリソースのカルチャに基づいて名前をつけたディレクトリに配置する必要があります。  
  
-   アプリに既定のカルチャ、あるいはニュートラル カルチャがありません。 ソース コード ファイルまたはプロジェクトの情報ファイル (Visual Basic アプリでは AssemblyInfo.vb、C# アプリでは AssemblyInfo.cs) に <xref:System.Resources.NeutralResourcesLanguageAttribute> 属性を追加します。  
  
-   <xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29> コンストラクターの `baseName` パラメーターに .resources ファイルの名前が指定されていません。 名前には、リソース ファイルの完全修飾名前空間を含める必要がありますが、そのファイル名拡張子は不要です。 通常、Visual Studio で作成されるリソース ファイルは名前空間の名前を含みますが、コマンド プロンプトで作成されコンパイルされたリソース ファイルはそれを含みません。 次のユーティリティをコンパイルして実行すると、埋め込まれた .resources ファイルの名前を判断できます。 これは、メイン アセンブリまたはサテライト アセンブリの名前をコマンド ライン パラメーターとして指定するコンソール アプリです。 これは、リソース マネージャーがリソースを正しく特定できるように、`baseName` パラメーターに指定するべき文字列を表示します。  
  
     [!code-csharp[System.Resources.ResourceManager.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.class/cs/resourcenames.cs#4)]
     [!code-vb[System.Resources.ResourceManager.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.class/vb/resourcenames.vb#4)]  
  
 アプリケーションの現在のカルチャを明示的に変更する場合、リソース マネージャーは <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType> プロパティではなく <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> プロパティの値に基づいてリソース セットを取得することも覚えておいてください。 通常は、一方の値を変更するなら、もう一方も変更する必要があります。  
  
<a name="versioning"></a>   
### <a name="resource-versioning"></a>リソースのバージョン管理  
 アプリの既定のリソースを含むメイン アセンブリは、アプリのサテライト アセンブリから切り離されているため、サテライト アセンブリを再配置せずに、メイン アセンブリの新しいバージョンをリリースできます。 既存のサテライト アセンブリを使用し、メイン アセンブリの新しいバージョンと一緒にそれらを再配置しないようにリソース マネージャーに指示するためには、<xref:System.Resources.SatelliteContractVersionAttribute> 属性を使用します。  
  
 サテライト アセンブリのバージョン管理サポートの詳細については、[リソースの取得](~/docs/framework/resources/retrieving-resources-in-desktop-apps.md)の記事を参照してください。  
  
<a name="config"></a>   
### <a name="satelliteassemblies-configuration-file-node"></a>\<satelliteassemblies> 構成ファイルのノード  
 Web サイト (HREF .exe ファイル) から展開と実行がされる実行可能ファイルの場合、<xref:System.Resources.ResourceManager> オブジェクトは Web 経由でサテライト アセンブリのプローブを作成する可能性があり、アプリのパフォーマンスが低下することがあります。 パフォーマンスの問題を排除するために、アプリと一緒に配置したサテライト アセンブリへのプローブを制限できます。 これを行うには、アプリの構成ファイル内に `<satelliteassemblies>` ノードを作成し、アプリの特定のカルチャのセットを配置したことと、<xref:System.Resources.ResourceManager> オブジェクトがそのノードに示されていないカルチャのプローブを作成するべきではないことを指定します。  
  
> [!NOTE]
>  `<satelliteassemblies>` ノードの作成より推奨される方法は、[ClickOnce 配置マニフェスト](https://msdn.microsoft.com/library/8457e615-e3b6-4990-8dcf-11bc590e4e9b)の機能を使用することです。  
  
 アプリの構成ファイルで、次のようなセクションを作成します。  
  
```  
<?xml version ="1.0"?>  
<configuration>  
    <satelliteassemblies>  
        <assembly name="MainAssemblyName, Version=versionNumber, Culture=neutral, PublicKeyToken=null|yourPublicKeyToken">  
            <culture>cultureName1</culture>  
            <culture>cultureName2</culture>  
            <culture>cultureName3</culture>  
        </assembly>  
    </satelliteassemblies>  
</configuration>  
```  
  
 この構成情報は次のように編集します。  
  
-   配置するメイン アセンブリごとに `<assembly>` ノードを 1 つ以上指定し、各ノードで完全修飾アセンブリ名を指定します。 *MainAssemblyName* の場所にメイン アセンブリの名前を指定し、メイン アセンブリに対応する `Version`、`PublicKeyToken`、および `Culture` 属性の値を指定します。  
  
     `Version` 属性には、アセンブリのバージョン番号を指定します。 たとえば、アセンブリの最初のリリースでは、バージョン番号は 1.0.0.0 になるでしょう。  
  
     `PublicKeyToken` 属性には、厳密な名前でアセンブリに署名していない場合は、キーワード `null` を指定し、アセンブリに署名した場合は、公開キー トークンを指定します。  
  
     `Culture` 属性には、メイン アセンブリを指定するためにキーワード `neutral` を指定し、<xref:System.Resources.ResourceManager> クラスが `<culture>` ノードに示されているカルチャに対してのみプローブを作成するようにします。  
  
     完全修飾アセンブリ名の詳細については、[アセンブリ名](~/docs/framework/app-domains/assembly-names.md)の記事を参照してください。 厳密な名前付きアセンブリの詳細については、[厳密な名前付きアセンブリの作成と使用](~/docs/framework/app-domains/create-and-use-strong-named-assemblies.md)の記事を参照してください。  
  
-   "fr-FR" などの特定のカルチャ名、または "fr" などのニュートラル カルチャ名を持つ `<culture>` ノードを 1 つ以上指定します。  
  
 `<satelliteassemblies>` ノード下に示されていないアセンブリにリソースが必要な場合、<xref:System.Resources.ResourceManager> クラスは標準のプローブ規則を使用してカルチャにプローブを作成します。  
  
<a name="ws"></a>   
## <a name="includewin8appnamelongincludeswin8-appname-long-mdmd-apps"></a>[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] アプリ  
  
> [!IMPORTANT]
>  <xref:System.Resources.ResourceManager> クラスは [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] アプリでサポートされていますが、その使用は推奨されていません。 [!INCLUDE[net_portable](~/includes/net-portable-md.md)] アプリで使用できる[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]を開発する場合にのみ、このクラスを使用します。 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] アプリのリソースを取得するには、[Windows.ApplicationModel.Resources.ResourceLoader](https://go.microsoft.com/fwlink/p/?LinkId=238182) クラスを代わりに使用します。  
  
 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] アプリでは、<xref:System.Resources.ResourceManager> クラスはパッケージ リソース インデックス (PRI) ファイルからリソースを取得します。 単一の PRI ファイル (アプリケーション パッケージの PRI ファイル) には、既定のカルチャとすべてのローカライズされたリソースの両方が含まれています。 1 つ以上の XML リソース (.resw) 形式のリソース ファイルから PRI ファイルを作成するには、MakePRI ユーティリティを使用します。 Visual Studio プロジェクトに含まれているリソースは、Visual Studio が自動的に PRI ファイルの作成とパッケージ化のプロセスを処理します。 その後、.NET Framework の <xref:System.Resources.ResourceManager> クラスを使用して、アプリやライブラリのリソースにアクセスできます。  
  
 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] アプリでは、デスクトップ アプリの場合と同じ方法で <xref:System.Resources.ResourceManager> オブジェクトのインスタンスを作成できます。  
  
 それから、<xref:System.Resources.ResourceManager.GetString%28System.String%29> メソッドに取得するリソースの名前を渡すことによって、特定のカルチャのリソースにアクセスすることができます。 既定では、このメソッドは、呼び出しを行ったスレッドの現在の UI カルチャによって決定されるカルチャのリソースを返します。 リソースの名前と、取得するリソースのカルチャを表す <xref:System.Globalization.CultureInfo> オブジェクトを <xref:System.Resources.ResourceManager.GetString%28System.String%2CSystem.Globalization.CultureInfo%29> メソッドに渡すことによって、特定のカルチャのリソースも取得できます。 現在の UI カルチャまたは指定したカルチャのリソースが見つからない場合、リソース マネージャーは UI 言語フォールバック リストを使用して、適切なリソースを見つけます。  
  
   
  
## Examples  
 次の例では、明示的なカルチャおよび暗黙的な現在の UI カルチャを使用して、メイン アセンブリとサテライト アセンブリから文字列リソースを取得する方法を示します。 詳細については、[サテライト アセンブリの作成](~/docs/framework/resources/creating-satellite-assemblies-for-desktop-apps.md)の記事内の「グローバル アセンブリ キャッシュにインストールされていないサテライト アセンブリのディレクトリの場所」セクションを参照してください。  
  
 この例を実行するには、  
  
1.  アプリ ディレクトリで、次のリソース文字列を含む rmc.txt という名前のファイルを作成します。  
  
    ```  
  
    day=Friday  
    year=2006  
    holiday="Cinco de Mayo"  
  
    ```  
  
2.  次のように、[リソース ファイル ジェネレーター](~/docs/framework/tools/resgen-exe-resource-file-generator.md) を使用して、入力ファイル rmc.txt からリソース ファイル rmc.resources を生成します。  
  
    ```  
    resgen rmc.txt  
    ```  
  
3.  アプリ ディレクトリのサブディレクトリを作成し、"es-MX" という名前をつけます。 これは、続く 3 つの手順で作成するサテライト アセンブリのカルチャ名です。  
  
4.  次のリソース文字列を含む rmc.es-MX.txt という名前のファイルを es-MX のディレクトリに作成します。  
  
    ```  
  
    day=Viernes  
    year=2006  
    holiday="Cinco de Mayo"  
  
    ```  
  
5.  次のように、[リソース ファイル ジェネレーター](~/docs/framework/tools/resgen-exe-resource-file-generator.md) を使用して、入力ファイル rmc.es-MX.txt からリソース ファイル rmc.es-MX.resources を生成します。  
  
    ```  
    resgen rmc.es-MX.txt  
    ```  
  
6.  この例のファイル名が rmc.vb または rmc.cs のどちらかであると仮定します。 下記のソース コードをファイルにコピーします。 それをコンパイルし、メイン アセンブリのリソース ファイルである rmc.resources を実行可能アセンブリに埋め込みます。 Visual Basic コンパイラを使用している場合、構文は次のようになります。  
  
    ```  
    vbc rmc.vb /resource:rmc.resources  
    ```  
  
     これは C# コンパイラの対応する構文です。  
  
    ```  
    csc /resource:rmc.resources rmc.cs  
    ```  
  
7.  [アセンブリ リンカー](~/docs/framework/tools/al-exe-assembly-linker.md) を使用して、サテライト アセンブリを作成します。 アプリのベース名が rmc なら、サテライト アセンブリの名前は rmc.resources.dll である必要があります。 サテライト アセンブリは es-MX ディレクトリに作成する必要があります。 es-MX が現在のディレクトリの場合は、このコマンドを使用します。  
  
    ```  
    al /embed:rmc.es-MX.resources /c:es-MX /out:rmc.resources.dll   
    ```  
  
8.  rmc.exe を実行して、埋め込まれたリソース文字列の取得と表示を行います。  
  
 [!code-csharp[ResourceManager_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/ResourceManager_Class/cs/rmc.cs#1)]
 [!code-vb[ResourceManager_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ResourceManager_Class/vb/rmc.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>この型はスレッド セーフです。</threadsafe>
    <altmember cref="T:System.Globalization.CultureInfo" />
    <altmember cref="P:System.Globalization.CultureInfo.CurrentUICulture" />
    <altmember cref="T:System.Resources.SatelliteContractVersionAttribute" />
    <related type="Article" href="https://msdn.microsoft.com/library/8ad495d4-2941-40cf-bf64-e82e85825890">アプリケーションのリソース</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Resources.ResourceManager" /> クラスの新しいインスタンスを初期化します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ResourceManager ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ResourceManager();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Resources.ResourceManager" /> クラスの新しいインスタンスを既定値で初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコンス トラクターは、独自のクラスから派生したを記述する場合にのみ役立ちます、<xref:System.Resources.ResourceManager>クラス。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ResourceManager (Type resourceSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type resourceSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.#ctor(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (resourceSource As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ResourceManager(Type ^ resourceSource);" />
      <MemberSignature Language="F#" Value="new System.Resources.ResourceManager : Type -&gt; System.Resources.ResourceManager" Usage="new System.Resources.ResourceManager resourceSource" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="resourceSource" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="resourceSource">リソース マネージャーが .resources ファイルを検索するために必要なすべての情報を取得する元となる種類。</param>
        <summary>指定した型オブジェクトの情報に基づいて、サテライト アセンブリでリソースを検索する <see cref="T:System.Resources.ResourceManager" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="desktop-apps"></a>デスクトップ アプリ  
 リソース マネージャーを使用してデスクトップ アプリ、`resourceSource`パラメーターを次のように、特定のリソース ファイルを読み込めません。  
  
-   場合、<xref:System.Resources.NeutralResourcesLanguageAttribute>を示す既定のカルチャのリソースがサテライト アセンブリに配置をリソース マネージャーは、既定のカルチャのリソース ファイルをで指定された型と同じアセンブリで見つかったこと前提としています属性は使用されません。`resourceSource`パラメーター。  
  
-   リソース マネージャーは、既定のリソース ファイルがで指定された型と同じ基本名を持つことを想定しています、`resourceSource`パラメーター。  
  
-   リソース マネージャーは、既定値を使用します。<xref:System.Resources.ResourceSet>リソース ファイルを操作するクラス。  
  
 MyType を定義するアセンブリで MyCompany.MyProduct.MyType.resources をという名前の .resources ファイルのリソース マネージャーを検索など MyCompany.MyProduct.MyType という名前の型を指定します。  
  
 Visual Studio で、リソース デザイナーを自動的に生成コードを定義する、 `internal` (で C# の場合) または`Friend`(Visual Basic) では、クラスの名前は既定のカルチャの .resources ファイルの基本名と同じです。 これにより、インスタンス化すること、<xref:System.Resources.ResourceManager>として、リソースがある必要があります、クラスがコンパイラに表示されている限りために、リソースの名前に対応する名前の型のオブジェクトを取得することによって、特定のリソースのセットを結合、およびオブジェクトまぁ。 たとえば、Resource1 .resources ファイルの名前が場合、次のステートメントをインスタンス化、 <xref:System.Resources.ResourceManager> Resource1 をという名前の .resources ファイルを管理するオブジェクト。  
  
 [!code-csharp[System.Resources.ResourceManager.ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.ctor/cs/ctor1.cs#2)]  
  
 Visual Studio を使用していない場合、その名前空間と名前は、既定の .resources ファイルのと同じメンバーを持たないクラスを作成することができます。 具体的な例を次に示します。  
  
## <a name="includewin8appnamelongincludeswin8-appname-long-mdmd-apps"></a>[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] アプリ  
  
> [!IMPORTANT]
>  <xref:System.Resources.ResourceManager> クラスは [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] アプリでサポートされていますが、その使用は推奨されていません。 [!INCLUDE[net_portable](~/includes/net-portable-md.md)] アプリで使用できる[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]を開発する場合にのみ、このクラスを使用します。 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] アプリのリソースを取得するには、[Windows.ApplicationModel.Resources.ResourceLoader](https://go.microsoft.com/fwlink/p/?LinkId=238182) クラスを代わりに使用します。  
  
 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]アプリ、<xref:System.Resources.ResourceManager>を使用して、`resourceSource`パラメーター、アセンブリ、基本名、およびリソース項目をアプリのパッケージ リソース インデックス (PRI) ファイル内に配置できる場所の名前空間を推論します。 たとえばで定義されている MyCompany.MyProduct.MyType という名前の型を指定`MyAssembly`、リソース マネージャーのリソース セット識別子が MyAssembly という名前の外観し、MyCompany.MyProduct.MyType そのリソース セット内のスコープを探します。 リソース マネージャーは、このスコープ内での既定のコンテキスト (現在のカルチャや現在のハイ コントラスト設定) の下にあるリソース項目を検索します。  
  
   
  
## Examples  
 次の例では、<xref:System.Resources.ResourceManager.%23ctor%28System.Type%29>インスタンスを作成するコンス トラクター、<xref:System.Resources.ResourceManager>オブジェクト。 これは、英語 (en)、フランス語 (フランス) (fr-FR)、およびロシア語 (ロシア) (ru-RU) の .txt ファイルからコンパイルされたリソースで構成されます。 例では、現在のカルチャと現在の UI カルチャを、英語 (米国)、フランス語 (フランス)、ロシア語 (ロシア)、およびスウェーデン語 (スウェーデン) に変更します。 呼び出して、<xref:System.Resources.ResourceManager.GetString%28System.String%29>時間帯に依存している応答メッセージを表示するローカライズされた文字列を取得します。  
  
 例では、次の表に記載されている、3 つのテキスト ベースのリソース ファイルが必要です。 各ファイルには、という名前の文字列リソースが含まれています。 `Morning`、 `Afternoon`、および`Evening`します。  
  
|カルチャ|ファイル名|リソース名|リソースの値|  
|-------------|---------------|-------------------|--------------------|  
|en-US|GreetingResources.txt|`Morning`|おはようございます|  
|en-US|GreetingResources.txt|`Afternoon`|こんにちは|  
|en-US|GreetingResources.txt|`Evening`|こんばんは|  
|fr-FR|GreetingResources.fr ファイルに格納|`Morning`|Bonjour|  
|fr-FR|GreetingResources.fr ファイルに格納|`Afternoon`|Bonjour|  
|fr-FR|GreetingResources.fr ファイルに格納|`Evening`|Bonsoir|  
|ru-RU|GreetingResources.ru ファイルに格納|`Morning`|Доброе утро|  
|ru-RU|GreetingResources.ru ファイルに格納|`Afternoon`|ДОБРЫЙ ДЕНЬ|  
|ru-RU|GreetingResources.ru ファイルに格納|`Evening`|Добрый вечер|  
  
 次のバッチ ファイルを使用して、Visual Basic の例をコンパイルし、Greet.exe という名前の実行可能ファイルを作成することができます。 C# でコンパイルをするからコンパイラ名を変更`vbc`に`csc`とからのファイル拡張子`.vb`に`.cs`します。  
  
```  
  
resgen GreetingResources.txt  
vbc Greet.vb /resource: GreetingResources.resources  
  
md fr-FR  
resgen GreetingResources.fr-FR.txt  
al /out:fr-FR\Greet.resources.dll /culture:fr-FR /embed: GreetingResources.fr-FR.resources   
  
md ru-RU  
resgen GreetingResources.ru-RU.txt  
al /out:ru-RU\Greet.resources.dll /culture:ru-RU /embed: GreetingResources.ru-RU.resources  
  
```  
  
 次に、この例のソース コード (Visual Basic バージョンの ShowDate.vb または C# バージョンの ShowDate.cs) を示します。  
  
 [!code-csharp[System.Resources.ResourceManager.Ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.ctor/cs/greet.cs#3)]
 [!code-vb[System.Resources.ResourceManager.Ctor#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.ctor/vb/greet.vb#3)]  
  
 アプリのクラスを定義するだけでなく、名前付き`Example`、ソース コードは、名前の内部クラスを定義します`GreetingResources`、リソース ファイルの基本名と同じです。 正常にインスタンスを作成できるようになります、<xref:System.Resources.ResourceManager>オブジェクトを呼び出すことによって、<xref:System.Resources.ResourceManager.%23ctor%28System.Type%29>コンス トラクター。  
  
 出力が表示されますが、適切なローカライズされた文字列ことである場合、現在の UI カルチャがスウェーデン語 (スウェーデン) が場合を除き、通知は、英語の言語リソースを使用します。 定義されている、アプリが既定のカルチャのリソースを使用してスウェーデン語の言語リソースが利用できないため、<xref:System.Resources.NeutralResourcesLanguageAttribute>属性は、代わりにします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="resourceSource" /> パラメーターが <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ResourceManager (string baseName, System.Reflection.Assembly assembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string baseName, class System.Reflection.Assembly assembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.#ctor(System.String,System.Reflection.Assembly)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ResourceManager(System::String ^ baseName, System::Reflection::Assembly ^ assembly);" />
      <MemberSignature Language="F#" Value="new System.Resources.ResourceManager : string * System.Reflection.Assembly -&gt; System.Resources.ResourceManager" Usage="new System.Resources.ResourceManager (baseName, assembly)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="baseName" Type="System.String" />
        <Parameter Name="assembly" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="baseName">拡張子はないが、完全修飾名前空間名を含んだ、リソース ファイルのルート名。 たとえば、"MyApplication.MyResource.en-US.resources" というリソース ファイルのルート名は "MyApplication.MyResource" です。</param>
        <param name="assembly">リソースのメイン アセンブリ。</param>
        <summary>指定したアセンブリ内で指定したルート名を持つファイルに含まれているリソースを検索する <see cref="T:System.Resources.ResourceManager" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="desktop-apps"></a>デスクトップ アプリ  
 デスクトップ アプリ、サテライト アセンブリには、個々 のカルチャに固有のリソース ファイルを含める必要があり、メイン アセンブリには、既定のカルチャのリソース ファイルを含める必要があります。 サテライト アセンブリでは、そのアセンブリのマニフェストで指定された 1 つのカルチャのリソースを含むと見なされますされ、必要に応じて読み込まれます。  
  
> [!NOTE]
>  呼び出す必要がありますをアセンブリから取得するのではなく、直接の .resources ファイルからリソースを取得する、<xref:System.Resources.ResourceManager.CreateFileBasedResourceManager%2A>メソッド代わりにインスタンス化する、<xref:System.Resources.ResourceManager>オブジェクト。  
  
 リソース ファイルがで識別される場合`baseName`内に見つかりません`assembly`、メソッドがインスタンス化、<xref:System.Resources.ResourceManager>オブジェクトが、特定のリソースを取得しようとすると、通常、例外がスロー<xref:System.Resources.MissingManifestResourceException>します。 例外の原因を診断する方法の詳細については、の「the MissingManifestResourceException 例外を処理する」セクションを参照してください、<xref:System.Resources.ResourceManager>クラスに関するトピック。  
  
## <a name="includewin8appnamelongincludeswin8-appname-long-mdmd-apps"></a>[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] アプリ  
  
> [!IMPORTANT]
>  <xref:System.Resources.ResourceManager> クラスは [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] アプリでサポートされていますが、その使用は推奨されていません。 [!INCLUDE[net_portable](~/includes/net-portable-md.md)] アプリで使用できる[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]を開発する場合にのみ、このクラスを使用します。 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] アプリのリソースを取得するには、[Windows.ApplicationModel.Resources.ResourceLoader](https://go.microsoft.com/fwlink/p/?LinkId=238182) クラスを代わりに使用します。  
  
 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]アプリ、リソース マネージャーの使用の簡易名、`assembly`アプリのパッケージ リソース インデックス (PRI) ファイルで一致するリソースを検索するパラメーターを設定します。 `baseName`リソース セット内のリソース項目を検索するパラメーターを使用します。 たとえば、PortableLibrary1.Resource1.de DE.resources のルート名は PortableLibrary1.Resource1 です。  
  
   
  
## Examples  
 次の例を示すためにローカライズされていない単純な"Hello World"アプリを使用して、<xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29>コンス トラクター。 ExampleResources.txt をという名前のテキスト ファイルの内容を次に示します。 アプリがコンパイルされると、リソースは、メイン アプリケーション アセンブリに埋め込まれます。  
  
```  
Greeting=Hello  
```  
  
 使用して、テキスト ファイルをバイナリ リソース ファイルに変換できる、コマンド プロンプトで、次のようにします。  
  
```  
resgen ExampleResources.txt  
```  
  
 次の例は、実行可能コードをインスタンス化する、<xref:System.Resources.ResourceManager>オブジェクトの名前を入力するように求めるし、あいさつ文が表示されます。  
  
 [!code-csharp[System.Resources.ResourceManager.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.ctor/cs/example.cs#1)]
 [!code-vb[System.Resources.ResourceManager.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.ctor/vb/example.vb#1)]  
  
 Visual Basic では、次のコマンドを使用してコンパイルできます。  
  
```  
vbc Example.vb /resource:ExampleResources.resources  
```  
  
 または、以下を使用して C# ではコマンドします。  
  
```  
csc Example.cs /resource:ExampleResources.resources  
```  
  
 例にそのアセンブリで定義された型を渡すことによって、リソース ファイルを含むアセンブリへの参照を取得することに注意してください、`typeof`関数 (C#) または`GetType`(Visual Basic) で機能し、そのの値を取得する<xref:System.Type.Assembly%2A?displayProperty=nameWithType>プロパティ。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="baseName" /> パラメーターまたは <paramref name="assembly" /> パラメーターが <see langword="null" /> です。</exception>
        <block subset="none" type="overrides"><para>このコンス トラクターは、システム指定<see cref="T:System.Resources.ResourceSet" />実装します。 派生する必要があります、カスタム リソース ファイル形式を使用する、<see cref="T:System.Resources.ResourceSet" />クラスでオーバーライド、<see cref="M:System.Resources.ResourceSet.GetDefaultReader" />と<see cref="M:System.Resources.ResourceSet.GetDefaultWriter" />メソッド、およびパスを入力する、<see cref="M:System.Resources.ResourceManager.#ctor(System.String,System.Reflection.Assembly,System.Type)" />コンス トラクター。 カスタムを使用して<see cref="T:System.Resources.ResourceSet" />は制御するリソースのキャッシュ ポリシーまたは、独自のリソース ファイル形式をサポートしているが、一般に必要な役に立ちます。</para></block>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ResourceManager (string baseName, System.Reflection.Assembly assembly, Type usingResourceSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string baseName, class System.Reflection.Assembly assembly, class System.Type usingResourceSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.#ctor(System.String,System.Reflection.Assembly,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ResourceManager(System::String ^ baseName, System::Reflection::Assembly ^ assembly, Type ^ usingResourceSet);" />
      <MemberSignature Language="F#" Value="new System.Resources.ResourceManager : string * System.Reflection.Assembly * Type -&gt; System.Resources.ResourceManager" Usage="new System.Resources.ResourceManager (baseName, assembly, usingResourceSet)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="baseName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="assembly" Type="System.Reflection.Assembly" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="usingResourceSet" Type="System.Type" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="baseName">拡張子はないが、完全修飾名前空間名を含んだ、リソース ファイルのルート名。 たとえば、"MyApplication.MyResource.en-US.resources" というリソース ファイルのルート名は "MyApplication.MyResource" です。</param>
        <param name="assembly">リソースのメイン アセンブリ。</param>
        <param name="usingResourceSet">使用するカスタム <see cref="T:System.Resources.ResourceSet" /> の種類。 <see langword="null" /> の場合は、既定のランタイム <see cref="T:System.Resources.ResourceSet" /> オブジェクトが使用されます。</param>
        <summary>指定した <see cref="T:System.Resources.ResourceSet" /> クラスを使用して、指定したアセンブリ内で指定したルート名を持つファイルに含まれるリソースを検索する <see cref="T:System.Resources.ResourceManager" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 サテライト アセンブリには、個々 のカルチャに固有のリソース ファイルを含める必要があり、メイン アセンブリには、既定のカルチャのリソース ファイルを含める必要があります。 サテライト アセンブリでは、そのアセンブリのマニフェストで指定された 1 つのカルチャのリソースを含むと見なされますされ、必要に応じて読み込まれます。  
  
> [!NOTE]
>  呼び出す必要がありますをアセンブリから取得するのではなく、直接の .resources ファイルからリソースを取得する、<xref:System.Resources.ResourceManager.CreateFileBasedResourceManager%2A>メソッド代わりにインスタンス化する、<xref:System.Resources.ResourceManager>オブジェクト。  
  
 リソース ファイルがで識別される場合`baseName`内に見つかりません`assembly`、メソッドがインスタンス化、<xref:System.Resources.ResourceManager>オブジェクトが、特定のリソースを取得しようとすると、通常、例外がスロー<xref:System.Resources.MissingManifestResourceException>します。 例外の原因を診断する方法の詳細については、の「the MissingManifestResourceException 例外を処理する」セクションを参照してください、<xref:System.Resources.ResourceManager>クラスに関するトピック。  
  
> [!NOTE]
>  `usingResourceSet`パラメーターは、独自のリソース形式をサポートするために使用されは、一般的に`null`します。 異なるを受け取るコンス トラクター、<xref:System.Type>のみです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="usingResourceset" /> が <see cref="T:System.Resources.ResourceSet" /> の派生クラスではありません。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="baseName" /> パラメーターまたは <paramref name="assembly" /> パラメーターが <see langword="null" /> です。</exception>
        <block subset="none" type="usage"><para>このコンス トラクターでは、指定することができます、<see cref="T:System.Resources.ResourceSet" />実装します。 特定したくない場合<see cref="T:System.Resources.ResourceSet" />実装は、カスタム リソース ファイルの形式を使用するようにから派生する必要があります、<see cref="T:System.Resources.ResourceSet" />クラスでオーバーライド、<see cref="M:System.Resources.ResourceSet.GetDefaultReader" />と<see cref="M:System.Resources.ResourceSet.GetDefaultWriter" />メソッド、およびこのコンス トラクターにパスを入力します。</para></block>
      </Docs>
    </Member>
    <Member MemberName="BaseName">
      <MemberSignature Language="C#" Value="public virtual string BaseName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BaseName" />
      <MemberSignature Language="DocId" Value="P:System.Resources.ResourceManager.BaseName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property BaseName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ BaseName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseName : string" Usage="System.Resources.ResourceManager.BaseName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Resources.ResourceManager" /> がリソースを検索するリソース ファイルのルート名を取得します。</summary>
        <value><see cref="T:System.Resources.ResourceManager" /> がリソースを検索するリソース ファイルのルート名。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceManager.BaseName%2A>プロパティには、完全修飾名前空間の名前とそのカルチャまたはファイル名拡張子を除いたのリソース ファイルのルート リソース名が反映されます。 たとえば、アプリの既定のリソース ファイルの名前は`SampleApps.StringResources.resources`の値、<xref:System.Resources.ResourceManager.BaseName%2A>プロパティが"SampleApps.StringResources"。 アプリの既定のリソース ファイルの名前が場合`SampleApps.StringResources.en-US.resources`の値、サテライト アセンブリに埋め込まれていると、<xref:System.Resources.ResourceManager.BaseName%2A>プロパティが"SampleApps.StringResources"。  
  
> [!IMPORTANT]
>  <xref:System.Resources.ResourceManager.BaseName%2A>を含めない限り、明示的に 1 つのファイルをコンパイルするときに、コンパイルされ、コマンドラインから埋め込みリソース ファイルのプロパティの値で名前空間の名前が含まれません。 一方で、<xref:System.Resources.ResourceManager.BaseName%2A>コンパイルされ、通常、Visual Studio 環境内で埋め込みリソース ファイルのプロパティの値には、既定の名前空間の名前にが含まれます。  
  
 <xref:System.Resources.ResourceManager.BaseName%2A>に渡された文字列と同じプロパティ値が、<xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29>または<xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%2CSystem.Type%29>コンス トラクターをインスタンス化するときに、<xref:System.Resources.ResourceManager>インスタンス。  
  
   
  
## Examples  
 次のユーティリティをコンパイルして実行すると、埋め込まれた .resources ファイルの名前を判断できます。 これは、メイン アセンブリまたはサテライト アセンブリの名前をコマンド ライン パラメーターとして指定するコンソール アプリです。 文字列として指定する必要がありますが表示されます、`baseName`のパラメーター、<xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29>または<xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%2CSystem.Type%29>コンス トラクター、resource manager では、リソースを正しく特定できるようにします。  
  
 [!code-csharp[System.Resources.ResourceManager.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.class/cs/resourcenames.cs#4)]
 [!code-vb[System.Resources.ResourceManager.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.class/vb/resourcenames.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseNameField">
      <MemberSignature Language="C#" Value="protected string BaseNameField;" />
      <MemberSignature Language="ILAsm" Value=".field family string BaseNameField" />
      <MemberSignature Language="DocId" Value="F:System.Resources.ResourceManager.BaseNameField" />
      <MemberSignature Language="VB.NET" Value="Protected BaseNameField As String " />
      <MemberSignature Language="C++ CLI" Value="protected: System::String ^ BaseNameField;" />
      <MemberSignature Language="F#" Value="val mutable BaseNameField : string" Usage="System.Resources.ResourceManager.BaseNameField" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Resources.ResourceManager" /> がリソースを検索するリソース ファイルのルート名を指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceManager.BaseNameField>フィールドはから派生した独自のクラスを記述する場合にのみ役立ちますが、<xref:System.Resources.ResourceManager>クラス。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateFileBasedResourceManager">
      <MemberSignature Language="C#" Value="public static System.Resources.ResourceManager CreateFileBasedResourceManager (string baseName, string resourceDir, Type usingResourceSet);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Resources.ResourceManager CreateFileBasedResourceManager(string baseName, string resourceDir, class System.Type usingResourceSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.CreateFileBasedResourceManager(System.String,System.String,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateFileBasedResourceManager (baseName As String, resourceDir As String, usingResourceSet As Type) As ResourceManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Resources::ResourceManager ^ CreateFileBasedResourceManager(System::String ^ baseName, System::String ^ resourceDir, Type ^ usingResourceSet);" />
      <MemberSignature Language="F#" Value="static member CreateFileBasedResourceManager : string * string * Type -&gt; System.Resources.ResourceManager" Usage="System.Resources.ResourceManager.CreateFileBasedResourceManager (baseName, resourceDir, usingResourceSet)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Resources.ResourceManager</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="resourceDir" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="usingResourceSet" Type="System.Type" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="baseName">リソースのルート名。 たとえば、"MyResource.en-US.resources" というリソース ファイルのルート名は "MyResource" です。</param>
        <param name="resourceDir">リソースを検索するディレクトリの名前。 <paramref name="resourceDir" /> には、アプリケーション ディレクトリを基準とした相対パス、または絶対パスを指定できます。</param>
        <param name="usingResourceSet">使用するカスタム <see cref="T:System.Resources.ResourceSet" /> の種類。 <see langword="null" /> の場合は、既定のランタイム <see cref="T:System.Resources.ResourceSet" /> オブジェクトが使用されます。</param>
        <summary>リソースのアセンブリ マニフェストではなく特定のディレクトリを検索する <see cref="T:System.Resources.ResourceManager" /> オブジェクトを返します。</summary>
        <returns>リソースのアセンブリ マニフェストの代わりに指定されたディレクトリを検索する、リソース マネージャーの新しいインスタンス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、アセンブリに埋め込まれていない .resources ファイルからリソースを取得するリソース マネージャーを返します。 これを使用することができます<xref:System.Resources.ResourceManager>ASP.NET ページのリソースを読み込むかをテストするオブジェクト、<xref:System.Resources.ResourceSet>実装します。  スタンドアロンの .resources ファイルからリソースを取得する例を参照してください、[のリソースの取得](~/docs/framework/resources/retrieving-resources-in-desktop-apps.md)記事。  
  
 このメソッドを指定できます、<xref:System.Resources.ResourceSet>実装します。 特定したくない場合<xref:System.Resources.ResourceSet>実装では、カスタム リソース ファイル形式を使用することから派生する必要があります、<xref:System.Resources.ResourceSet>クラスでオーバーライド、<xref:System.Resources.ResourceSet.GetDefaultReader%2A>と<xref:System.Resources.ResourceSet.GetDefaultWriter%2A>メソッド、およびこのコンス トラクターにパスを入力します。  
  
> [!CAUTION]
>  ASP.NET アプリでスタンドアロン .resources ファイルを使用すると、XCOPY による配置が中断されます。<xref:System.Resources.ResourceManager.ReleaseAllResources%2A> メソッドによって明示的に解放されるまで、リソースがロックされたままになるためです。 ASP.NET アプリケーションでリソースをデプロイする場合は、サテライト アセンブリに .resources ファイルをコンパイルします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="baseName" /> パラメーターまたは <paramref name="resourceDir" /> パラメーターが <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />します。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /> (関連する列挙体)</permission>
      </Docs>
    </Member>
    <Member MemberName="FallbackLocation">
      <MemberSignature Language="C#" Value="protected System.Resources.UltimateResourceFallbackLocation FallbackLocation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Resources.UltimateResourceFallbackLocation FallbackLocation" />
      <MemberSignature Language="DocId" Value="P:System.Resources.ResourceManager.FallbackLocation" />
      <MemberSignature Language="VB.NET" Value="Protected Property FallbackLocation As UltimateResourceFallbackLocation" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Resources::UltimateResourceFallbackLocation FallbackLocation { System::Resources::UltimateResourceFallbackLocation get(); void set(System::Resources::UltimateResourceFallbackLocation value); };" />
      <MemberSignature Language="F#" Value="member this.FallbackLocation : System.Resources.UltimateResourceFallbackLocation with get, set" Usage="System.Resources.ResourceManager.FallbackLocation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Resources.UltimateResourceFallbackLocation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>既定のフォールバック リソースの取得元の場所を取得または設定します。</summary>
        <value>リソース マネージャーがフォールバック リソースを検索できる場所を指定する列挙値のいずれか 1 つ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceManager.FallbackLocation%2A>プロパティは、独自のクラスから派生したを記述する場合にのみ役立ちますが、<xref:System.Resources.ResourceManager>クラス。  
  
 使用することができます、<xref:System.Resources.NeutralResourcesLanguageAttribute>アプリ用の既定のカルチャの検索場所、リソース マネージャーに通知する属性: (既定値) のメインのアセンブリまたはサテライト アセンブリ。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Resources.UltimateResourceFallbackLocation" />
        <altmember cref="T:System.Resources.NeutralResourcesLanguageAttribute" />
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">リソースのパッケージ化と配置</related>
      </Docs>
    </Member>
    <Member MemberName="GetNeutralResourcesLanguage">
      <MemberSignature Language="C#" Value="protected static System.Globalization.CultureInfo GetNeutralResourcesLanguage (System.Reflection.Assembly a);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig class System.Globalization.CultureInfo GetNeutralResourcesLanguage(class System.Reflection.Assembly a) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetNeutralResourcesLanguage(System.Reflection.Assembly)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function GetNeutralResourcesLanguage (a As Assembly) As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static System::Globalization::CultureInfo ^ GetNeutralResourcesLanguage(System::Reflection::Assembly ^ a);" />
      <MemberSignature Language="F#" Value="static member GetNeutralResourcesLanguage : System.Reflection.Assembly -&gt; System.Globalization.CultureInfo" Usage="System.Resources.ResourceManager.GetNeutralResourcesLanguage a" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Reflection.Assembly" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="a">カルチャ固有の情報を返すアセンブリ。</param>
        <summary>指定したアセンブリで <see cref="T:System.Resources.NeutralResourcesLanguageAttribute" /> 属性の値を取得して、メイン アセンブリの既定のリソースのカルチャ固有の情報を返します。</summary>
        <returns>見つかった場合は <see cref="T:System.Resources.NeutralResourcesLanguageAttribute" /> 属性のカルチャ、それ以外の場合は、インバリアント カルチャ。</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />します。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /> (関連する列挙体)</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetObject">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在のカルチャの文字列以外の指定したリソースの値を返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetObject">
      <MemberSignature Language="C#" Value="public virtual object GetObject (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetObject(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetObject(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetObject (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetObject(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetObject : string -&gt; obj&#xA;override this.GetObject : string -&gt; obj" Usage="resourceManager.GetObject name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">取得するリソースの名前。</param>
        <summary>指定した文字列以外のリソースの値を返します。</summary>
        <returns>呼び出し元の現在のカルチャ用にローカライズされているリソースの値。 適切なリソース セットが存在するが、<paramref name="name" /> が見つからない場合、メソッドは <see langword="null" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceManager.GetObject%2A>文字列以外のリソースを取得するメソッドを使用します。 などのプリミティブ データ型に属している値が含まれます<xref:System.Int32>または<xref:System.Double>、ビットマップ (など、<xref:System.Drawing.Bitmap?displayProperty=nameWithType>オブジェクト)、またはカスタム オブジェクトをシリアル化します。 通常、返されたオブジェクトをキャスト (C#) または (Visual Basic) で、適切な型のオブジェクトへの変換する必要があります。  
  
 定義されている現在のスレッドの UI カルチャの返されたリソースのローカライズ、<xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType>プロパティ。 リソースがそのカルチャのローカライズされていない場合、リソース マネージャーは適切なリソースの読み込みにフォールバック規則を使用します。 使用できるローカライズされたリソースのセットが見つからない場合、<xref:System.Resources.ResourceManager>既定のカルチャのリソースにフォールバックします。 既定のカルチャのリソース セットが見つからない場合、メソッドがスローされます、<xref:System.Resources.MissingManifestResourceException>例外や、サテライト アセンブリ内に存在するリソース セットが予想される場合、<xref:System.Resources.MissingSatelliteAssemblyException>例外。 適切なリソースが設定という名前のリソースを見つけることができませんが、リソース マネージャーが読み込むことができる場合`name`、メソッドを返します`null`します。  
  
 <xref:System.Resources.ResourceManager.IgnoreCase%2A>プロパティを決定するかどうかの比較`name`リソースの名前を持つ大文字小文字が (既定値) または大文字小文字を区別します。  
  
> [!CAUTION]
>  このメソッドは、表示されているもの以外の例外をスローできます。 これが発生する理由の 1 つは、このメソッドを呼び出すメソッドが例外をスローするかどうかです。  たとえば、<xref:System.IO.FileLoadException>の配置またはサテライト アセンブリのインストール エラーが行われた場合、例外がスローされる<xref:System.Runtime.Serialization.SerializationException>型が逆シリアル化時に、ユーザー定義型がユーザー定義の例外をスローした場合、例外がスローされる可能性が。  
  
## <a name="performance-considerations"></a>パフォーマンスに関する考慮事項  
 呼び出す場合、<xref:System.Resources.ResourceManager.GetObject%2A>メソッドを複数回、同じ`name`パラメーターでは、各呼び出しで同じオブジェクトへの参照を返すメソッドに依存しません。 これは、ため、<xref:System.Resources.ResourceManager.GetObject%2A>メソッドは、キャッシュで既存のリソース オブジェクトへの参照を返すか、リソースを再読み込みし、新しいリソース オブジェクトへの参照を返します。  
  
   
  
## Examples  
 次の例では、 <xref:System.Resources.ResourceManager.GetObject%28System.String%29> メソッドを使用して、カスタム オブジェクトを逆シリアル化します。 例では、UIElements.cs (場合は UIElements.vb Visual Basic を使用している場合) をという名前のソース コード ファイルが含まれていますという名前の次の構造を定義する`PersonTable`します。 この構造体は、ローカライズされたテーブル列名を表示する一般的なテーブル表示ルーチンでの使用を目的としています。 `PersonTable` 構造体は、 <xref:System.SerializableAttribute> 属性でマークされています。  
  
 [!code-csharp[Conceptual.Resources.Retrieving#6](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.retrieving/cs/example.cs#6)]
 [!code-vb[Conceptual.Resources.Retrieving#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.retrieving/vb/example.vb#6)]  
  
 CreateResources.cs (Visual Basic の場合は CreateResources.vb) という名前のファイルに入っている次のコードは、UIResources.resx という名前の XML リソース ファイルを作成します。このリソース ファイルには、テーブルのタイトルに加えて、英語にローカライズされたアプリに関する情報を含む `PersonTable` オブジェクトが格納されます。  
  
 [!code-csharp[Conceptual.Resources.Retrieving#7](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.retrieving/cs/example1.cs#7)]
 [!code-vb[Conceptual.Resources.Retrieving#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.retrieving/vb/example.vb#7)]  
  
 GetObject.cs (GetObject.vb) という名前のソース コード ファイルに含まれる次のコードは、リソースを取得し、コンソールに表示します。  
  
 [!code-csharp[Conceptual.Resources.Retrieving#8](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.retrieving/cs/example2.cs#8)]
 [!code-vb[Conceptual.Resources.Retrieving#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.retrieving/vb/example2.vb#8)]  
  
 次のバッチ ファイルを実行することで、必要なリソース ファイルとアセンブリをビルドし、アプリケーションを実行することができます。 `/r` 構造体に関する情報にアクセスできるように、 `PersonTable` オプションを使用して Resgen.exe を指定し、UIElements.dll への参照を含める必要があります。 C# を使用している場合は、 `vbc` コンパイラ名を `csc`に置換し、 `.vb` 拡張子を `.cs`に置換します。  
  
```  
  
vbc /t:library UIElements.vb  
vbc CreateResources.vb /r:UIElements.dll  
CreateResources  
  
resgen UIResources.resx  /r:UIElements.dll  
vbc GetObject.vb /r:UIElements.dll /resource:UIResources.resources  
  
GetObject.exe  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.Resources.MissingManifestResourceException">使用できるローカライズされたリソースのセットが見つからず、既定のカルチャ リソースもありません。 この例外の処理方法の詳細については、<see cref="T:System.Resources.ResourceManager" /> クラスのトピックの MissingManifestResourceException 例外と MissingSatelliteAssemblyException 例外の処理に関するセクションを参照してください。</exception>
        <exception cref="T:System.Resources.MissingSatelliteAssemblyException">既定のカルチャのリソースがサテライト アセンブリに存在し、そのサテライト アセンブリが見つかりませんでした。 この例外の処理方法の詳細については、<see cref="T:System.Resources.ResourceManager" /> クラスのトピックの MissingManifestResourceException 例外と MissingSatelliteAssemblyException 例外の処理に関するセクションを参照してください。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />します。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /> (関連する列挙体)</permission>
        <altmember cref="M:System.Resources.ResourceManager.GetStream(System.String)" />
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">リソースのパッケージ化と配置</related>
      </Docs>
    </Member>
    <Member MemberName="GetObject">
      <MemberSignature Language="C#" Value="public virtual object GetObject (string name, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetObject(string name, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetObject(System.String,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetObject (name As String, culture As CultureInfo) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetObject(System::String ^ name, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member GetObject : string * System.Globalization.CultureInfo -&gt; obj&#xA;override this.GetObject : string * System.Globalization.CultureInfo -&gt; obj" Usage="resourceManager.GetObject (name, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">取得するリソースの名前。</param>
        <param name="culture">リソースのローカライズ対象のカルチャ。 リソースがこのカルチャにローカライズされていない場合、リソース マネージャーはフォールバック規則を使用して適切なリソースを探します。  
  
この値が <see langword="null" /> の場合、<see cref="P:System.Globalization.CultureInfo.CurrentUICulture" /> プロパティを使用して <see cref="T:System.Globalization.CultureInfo" /> オブジェクトが取得されます。</param>
        <summary>指定されたカルチャ用にローカライズされている指定された文字列以外のリソースの値を取得します。</summary>
        <returns>指定されたカルチャに合わせてローカライズされているリソースの値。 適切なリソース セットが存在するが、<paramref name="name" /> が見つからない場合、メソッドは <see langword="null" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceManager.GetObject%28System.String%2CSystem.Globalization.CultureInfo%29>文字列以外のリソースを取得するメソッドを使用します。 などのプリミティブ データ型に属している値が含まれます<xref:System.Int32>または<xref:System.Double>、ビットマップ (など、<xref:System.Drawing.Bitmap?displayProperty=nameWithType>オブジェクト)、またはカスタム オブジェクトをシリアル化します。 通常、返されたオブジェクトをキャスト (C#) または (Visual Basic) で、適切な型のオブジェクトへの変換する必要があります。  
  
 指定されたカルチャ用に、返されたリソースがローカライズ`culture`、またはカルチャで指定されている、<xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType>プロパティ場合`culture`は`null`します。 リソースがそのカルチャのローカライズされていない場合、リソース マネージャーは適切なリソースの読み込みにフォールバック規則を使用します。 使用できるローカライズされたリソースのセットが見つからない場合、リソース マネージャーの既定のカルチャのリソースにフォールバックします。 既定のカルチャのリソース セットが見つからない場合、メソッドがスローされます、<xref:System.Resources.MissingManifestResourceException>例外や、サテライト アセンブリ内に存在するリソース セットが予想される場合、<xref:System.Resources.MissingSatelliteAssemblyException>例外。 適切なリソースが設定という名前のリソースを見つけることができませんが、リソース マネージャーが読み込むことができる場合`name`、メソッドを返します`null`します。  
  
 <xref:System.Resources.ResourceManager.IgnoreCase%2A>プロパティを決定するかどうかの比較`name`リソースの名前を持つ大文字小文字が (既定値) または大文字小文字を区別します。  
  
> [!CAUTION]
>  このメソッドは、表示されているもの以外の例外をスローできます。 これが発生する理由の 1 つは、このメソッドを呼び出すメソッドが例外をスローするかどうかです。  たとえば、<xref:System.IO.FileLoadException>の配置またはサテライト アセンブリのインストール エラーが行われた場合、例外がスローされる<xref:System.Runtime.Serialization.SerializationException>型が逆シリアル化時に、ユーザー定義型がユーザー定義の例外をスローした場合、例外がスローされる可能性が。  
  
## <a name="performance-considerations"></a>パフォーマンスに関する考慮事項  
 呼び出す場合、<xref:System.Resources.ResourceManager.GetObject%2A>メソッドを複数回、同じ`name`パラメーターでは、各呼び出しで同じオブジェクトへの参照を返すメソッドに依存しません。 これは、ため、<xref:System.Resources.ResourceManager.GetObject%2A>メソッドは、キャッシュで既存のリソース オブジェクトへの参照を返すか、リソースを再読み込みし、新しいリソース オブジェクトへの参照を返します。  
  
   
  
## Examples  
 次の例では、 <xref:System.Resources.ResourceManager.GetObject%28System.String%2CSystem.Globalization.CultureInfo%29> メソッドを使用して、カスタム オブジェクトを逆シリアル化します。 例では、NumberInfo.cs (NumberInfo.vb Visual Basic を使用している場合) をという名前のソース コード ファイルが含まれていますという名前の次の構造を定義する`Numbers`します。 この構造体がについて説明する英語以外には英語で 10 にカウントする単純な教育アプリで使用するためのものです。 なお、`Numbers`クラスには、<xref:System.SerializableAttribute>属性。  
  
 [!code-csharp[System.Resources.ResourceManager.GetObject#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.getobject/cs/numberinfo.cs#1)]
 [!code-vb[System.Resources.ResourceManager.GetObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.getobject/vb/numberinfo.vb#1)]  
  
 次のソース コードをファイルから名前付き CreateResources.cs (Visual Basic の場合は CreateResources.vb) は、既定の英語とフランス語、ポルトガル語、ロシア語の言語の XML リソース ファイルを作成します。  
  
 [!code-csharp[System.Resources.ResourceManager.GetObject#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.getobject/cs/createresources.cs#2)]
 [!code-vb[System.Resources.ResourceManager.GetObject#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.getobject/vb/createresources.vb#2)]  
  
 リソースは、次のアプリは、現在の UI カルチャをフランス語 (フランス)、ポルトガル語 (ブラジル)、またはロシア語 (ロシア) に設定によって使用されます。 呼び出す、<xref:System.Resources.ResourceManager.GetObject%28System.String%29>を取得するメソッド、`Numbers`ローカライズされた数値を含むオブジェクトと<xref:System.Resources.ResourceManager.GetObject%28System.String%2CSystem.Globalization.CultureInfo%29>を取得します、`Numbers`英語数字を含むオブジェクト。 現在の UI カルチャと英語の言語を使用して奇数の数値が表示されます。 ソース コード ファイルの名前は ShowNumbers.cs (ShowNumbers.vb)。  
  
 [!code-csharp[System.Resources.ResourceManager.GetObject#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.getobject/cs/shownumbers.cs#3)]
 [!code-vb[System.Resources.ResourceManager.GetObject#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.getobject/vb/shownumbers.vb#3)]  
  
 ビルドの例では、Visual Basic バージョンを実行して、次のバッチ ファイルを使用できます。 C# を使用している場合は置き換えます`vbc`で`csc`と置換、`.vb`拡張機能を`.cs`します。  
  
```  
  
vbc /t:library NumberInfo.vb  
  
vbc CreateResources.vb /r:NumberInfo.dll  
CreateResources  
  
resgen NumberResources.resx /r:NumberInfo.dll  
  
resgen NumberResources.fr.resx /r:Numberinfo.dll  
Md fr  
al /embed:NumberResources.fr.resources /culture:fr /t:lib /out:fr\ShowNumbers.resources.dll  
  
resgen NumberResources.pt.resx  /r:Numberinfo.dll  
Md pt  
al /embed:NumberResources.pt.resources /culture:pt /t:lib /out:pt\ShowNumbers.resources.dll  
  
resgen NumberResources.ru.resx /r:Numberinfo.dll  
Md ru  
al /embed:NumberResources.ru.resources /culture:ru /t:lib /out:ru\ShowNumbers.resources.dll  
  
vbc ShowNumbers.vb /r:NumberInfo.dll /resource:NumberResources.resources  
ShowNumbers.exe  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.Resources.MissingManifestResourceException">使用できるリソースのセットが見つからず、既定のカルチャ リソースもありません。 この例外の処理方法の詳細については、<see cref="T:System.Resources.ResourceManager" /> クラスのトピックの MissingManifestResourceException 例外と MissingSatelliteAssemblyException 例外の処理に関するセクションを参照してください。</exception>
        <exception cref="T:System.Resources.MissingSatelliteAssemblyException">既定のカルチャのリソースがサテライト アセンブリに存在し、そのサテライト アセンブリが見つかりませんでした。 この例外の処理方法の詳細については、<see cref="T:System.Resources.ResourceManager" /> クラスのトピックの MissingManifestResourceException 例外と MissingSatelliteAssemblyException 例外の処理に関するセクションを参照してください。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />します。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /> (関連する列挙体)</permission>
        <threadsafe><see cref="M:System.Resources.ResourceManager.GetObject(System.String,System.Globalization.CultureInfo)" />メソッドはスレッド セーフであります。</threadsafe>
        <altmember cref="M:System.Resources.ResourceManager.GetStream(System.String,System.Globalization.CultureInfo)" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">リソースのパッケージ化と配置</related>
      </Docs>
    </Member>
    <Member MemberName="GetResourceFileName">
      <MemberSignature Language="C#" Value="protected virtual string GetResourceFileName (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string GetResourceFileName(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetResourceFileName(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetResourceFileName (culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::String ^ GetResourceFileName(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member GetResourceFileName : System.Globalization.CultureInfo -&gt; string&#xA;override this.GetResourceFileName : System.Globalization.CultureInfo -&gt; string" Usage="resourceManager.GetResourceFileName culture" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="culture">リソース ファイル名を構築する対象のカルチャ オブジェクト。</param>
        <summary>指定した <see cref="T:System.Globalization.CultureInfo" /> オブジェクトのリソース ファイルの名前を生成します。</summary>
        <returns>指定した <see cref="T:System.Globalization.CultureInfo" /> オブジェクトのリソース ファイルに使用できる名前。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceManager.GetResourceFileName%2A>メソッドは、独自のクラスから派生したを記述する場合にのみ、<xref:System.Resources.ResourceManager>クラス。  
  
 このメソッドを使用して、<xref:System.Globalization.CultureInfo.Name%2A?displayProperty=nameWithType>インバリアント カルチャ以外のすべてのカルチャのファイル名の一部としてプロパティ。 このメソッドは、アセンブリのマニフェストまたはタッチ、ディスクを検索しませんし、リソースのファイル名を作成する場合にのみ使用されます (に渡すに適した、<xref:System.Resources.ResourceReader>コンス トラクター) または blob のマニフェスト リソース名。  
  
 派生クラスが別の拡張機能など、検索するには、このメソッドをオーバーライドできます"。ResX"、またはリソース ファイルの名前付けするためのまったく異なるスキーム。 サテライト アセンブリ内のリソース ファイルの名前をカスタマイズし、サテライト アセンブリ自体の名前をカスタマイズするには、いないメソッドを使用できることに注意してください。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />します。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /> (関連する列挙体)</permission>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <related type="Article" href="~/docs/standard/globalization-localization/index.md">.NET アプリケーションのグローバライズとローカライズ</related>
      </Docs>
    </Member>
    <Member MemberName="GetResourceSet">
      <MemberSignature Language="C#" Value="public virtual System.Resources.ResourceSet GetResourceSet (System.Globalization.CultureInfo culture, bool createIfNotExists, bool tryParents);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Resources.ResourceSet GetResourceSet(class System.Globalization.CultureInfo culture, bool createIfNotExists, bool tryParents) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetResourceSet(System.Globalization.CultureInfo,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetResourceSet (culture As CultureInfo, createIfNotExists As Boolean, tryParents As Boolean) As ResourceSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Resources::ResourceSet ^ GetResourceSet(System::Globalization::CultureInfo ^ culture, bool createIfNotExists, bool tryParents);" />
      <MemberSignature Language="F#" Value="abstract member GetResourceSet : System.Globalization.CultureInfo * bool * bool -&gt; System.Resources.ResourceSet&#xA;override this.GetResourceSet : System.Globalization.CultureInfo * bool * bool -&gt; System.Resources.ResourceSet" Usage="resourceManager.GetResourceSet (culture, createIfNotExists, tryParents)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Resources.ResourceSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="createIfNotExists" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="tryParents" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="culture">リソースが取得されるカルチャ。</param>
        <param name="createIfNotExists">リソース セットがまだ読み込まれていなければ読み込む場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <param name="tryParents">リソース セットが見つからないときに、適切なリソースを読み込むためにリソース フォールバックを使用する場合は <see langword="true" />。リソース フォールバック プロセスをバイパスする場合は <see langword="false" />。</param>
        <summary>特定のカルチャのリソース セットを取得します。</summary>
        <returns>指定されたカルチャに設定されたリソース。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返されるリソース セットは、指定したカルチャにローカライズされたリソースを表します。 そのカルチャのリソースがローカライズされていない場合、`tryParents`は`true`、<xref:System.Resources.ResourceManager.GetResourceSet%2A>リソース フォールバック規則を使用して、適切なリソースを読み込めません。 場合`tryParents`は`false`、メソッドを返しますのカルチャに固有のリソース セットが見つからない`null`します。 リソース フォールバックの詳細については、「リソース フォールバック プロセス」セクションを参照して、 [Packaging and Deploying Resources](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md)記事。  
  
   
  
## Examples  
 次の例では、<xref:System.Resources.ResourceManager.GetResourceSet%2A>フランス語 (フランス) カルチャのカルチャに固有のリソースを取得します。 すべてのリソース セット内のリソースを列挙します。 実行可能ファイル ShowNumbers.exe という名前のソース コードが含まれています。 数値の名前を格納する次の 2 つのテキスト ファイルも含まれています。 まず、NumberResources.txt には、番号 1 から 10 まで英語での名前が含まれています。  
  
```  
  
one=one  
two=two  
three=three  
four=four  
five=five  
six=six  
seven=seven  
eight=eight  
nine=nine  
ten=ten  
  
```  
  
 2 つ目 NumberResources.fr ファイルに格納にはには、フランス語の言語で 4 つに 1 つの数字の名前が含まれています。  
  
```  
  
one=un  
two=deux  
three=trois  
four=quatre  
  
```  
  
 バッチ ファイルを使用して、リソース ファイルを生成し、英語の言語リソース ファイルを実行可能ファイルに埋め込む、フランス語の言語リソースのサテライト アセンブリを作成することができます。 Visual Basic コンパイラを使用して、実行可能ファイルを生成するバッチ ファイルを次に示します。  
  
```  
  
resgen NumberResources.txt  
vbc shownumbers.vb /resource:NumberResources.resources  
  
md fr-FR  
resgen NumberResources.fr-FR.txt  
al /out:fr-FR\ShowNumbers.resources.dll /culture:fr-FR /embed:NumberResources.fr-FR.resources  
```  
  
 C# コンパイラでは、次のバッチ ファイルを使用できます。  
  
```  
  
resgen NumberResources.txt  
csc shownumbers.cs /resource:NumberResources.resources  
  
md fr-FR  
resgen NumberResources.fr-FR.txt  
al /out:fr-FR\ShowNumbers.resources.dll /culture:fr-FR /embed:NumberResources.fr-FR.resources  
  
```  
  
 [!code-csharp[System.Resources.ResourceManager.GetResourceSet#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.getresourceset/cs/shownumbers.cs#1)]
 [!code-vb[System.Resources.ResourceManager.GetResourceSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.getresourceset/vb/shownumbers.vb#1)]  
  
 値を変更する場合、`createIfNotExists`引数`false`、メソッド呼び出しから制御`null`リソース マネージャーで、フランス語の言語リソースがまだロードされていないため、します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="culture" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.Resources.MissingManifestResourceException"><paramref name="tryParents" /> が <see langword="true" /> で、使用できるリソースのセットが見つからず、既定のカルチャ リソースもありません。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />します。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /> (関連する列挙体)</permission>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <related type="Article" href="~/docs/standard/globalization-localization/index.md">.NET アプリケーションのグローバライズとローカライズ</related>
      </Docs>
    </Member>
    <Member MemberName="GetSatelliteContractVersion">
      <MemberSignature Language="C#" Value="protected static Version GetSatelliteContractVersion (System.Reflection.Assembly a);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig class System.Version GetSatelliteContractVersion(class System.Reflection.Assembly a) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetSatelliteContractVersion(System.Reflection.Assembly)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function GetSatelliteContractVersion (a As Assembly) As Version" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static Version ^ GetSatelliteContractVersion(System::Reflection::Assembly ^ a);" />
      <MemberSignature Language="F#" Value="static member GetSatelliteContractVersion : System.Reflection.Assembly -&gt; Version" Usage="System.Resources.ResourceManager.GetSatelliteContractVersion a" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Reflection.Assembly" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="a"><see cref="T:System.Resources.SatelliteContractVersionAttribute" /> 属性を確認する対象のアセンブリ。</param>
        <summary>指定したアセンブリの <see cref="T:System.Resources.SatelliteContractVersionAttribute" /> 属性で指定されたバージョンを返します。</summary>
        <returns>指定したアセンブリのサテライト コントラクト バージョン。バージョンが見つからなかった場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 サテライト アセンブリのバージョン管理の詳細については、次を参照してください。、<xref:System.Resources.SatelliteContractVersionAttribute>リファレンス トピック。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">アセンブリの <paramref name="a" /> で見つかった <see cref="T:System.Version" /> が無効です。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="a" /> は <see langword="null" />です。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />します。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /> (関連する列挙体)</permission>
        <altmember cref="T:System.Resources.SatelliteContractVersionAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetStream">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定したリソースからアンマネージ メモリ ストリーム オブジェクトを返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetStream">
      <MemberSignature Language="C#" Value="public System.IO.UnmanagedMemoryStream GetStream (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.UnmanagedMemoryStream GetStream(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetStream(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetStream (name As String) As UnmanagedMemoryStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::UnmanagedMemoryStream ^ GetStream(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GetStream : string -&gt; System.IO.UnmanagedMemoryStream" Usage="resourceManager.GetStream name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.UnmanagedMemoryStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">リソースの名前。</param>
        <summary>指定したリソースからアンマネージ メモリ ストリーム オブジェクトを返します。</summary>
        <returns>リソースを表すアンマネージ メモリ ストリーム オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceManager.GetStream%2A>メソッドとして格納されているリソースの名前を受け取り、<xref:System.IO.MemoryStream>オブジェクトの値を取得、<xref:System.Object>リソース、および返します、<xref:System.IO.UnmanagedMemoryStream>オブジェクト。 オブジェクトに変換し、バイトのストリームを直接操作することが必要です。 このメソッドは主にパフォーマンス上の理由です。明示的なオブジェクトではなくバイト ストリームとしてリソースを取得すると、パフォーマンスを向上させることができます。  
  
 定義されている現在のスレッドの UI カルチャの返されたリソースのローカライズ、<xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType>プロパティ。 リソースがそのカルチャのローカライズされていない場合、リソース マネージャーは適切なリソースの読み込みにフォールバック規則を使用します。 使用できるローカライズされたリソースのセットが見つからない場合、<xref:System.Resources.ResourceManager>既定のカルチャのリソースにフォールバックします。 既定のカルチャのリソース セットが見つからない場合、メソッドがスローされます、<xref:System.Resources.MissingManifestResourceException>例外や、サテライト アセンブリ内に存在するリソース セットが予想される場合、<xref:System.Resources.MissingSatelliteAssemblyException>例外。 適切なリソースが設定という名前のリソースを見つけることができませんが、リソース マネージャーが読み込むことができる場合`name`、メソッドを返します`null`します。  
  
 <xref:System.Resources.ResourceManager.IgnoreCase%2A>プロパティを決定するかどうかの比較`name`リソースの名前を持つ大文字小文字が (既定値) または大文字小文字を区別します。  
  
   
  
## Examples  
 次の例では、 <xref:System.Resources.ResourceManager.GetStream%28System.String%29> メソッドを使用して、アプリの開始スプラッシュ ウィンドウで使用されるビットマップを取得します。 次のソース コードという名前のファイルから CreateResources.cs (C# の場合) または CreateResources.vb (Visual Basic) にシリアル化されたイメージを含む AppResources.resx をという名前の .resx ファイルが生成されます。 この場合、画像は SplashScreen.jpg という名前のファイルから読み込まれます。ファイル名を変更して、独自の画像に置き換えることができます。  
  
 [!code-csharp[Conceptual.Resources.Retrieving#4](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.retrieving/cs/createresources.cs#4)]
 [!code-vb[Conceptual.Resources.Retrieving#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.retrieving/vb/createresources.vb#4)]  
  
 次のコード (C#) の GetStream.cs をという名前のファイルまたは GetStream.vb (Visual Basic) のリソースを取得しでイメージを表示します、<xref:System.Windows.Forms.PictureBox?displayProperty=nameWithType>コントロール。  
  
 [!code-csharp[Conceptual.Resources.Retrieving#5](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.resources.retrieving/cs/getstream.cs#5)]
 [!code-vb[Conceptual.Resources.Retrieving#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.resources.retrieving/vb/getstream.vb#5)]  
  
 次のバッチ ファイルを使用すると、C# の例をビルドできます。 Visual Basic の場合は、 `csc` を `vbc`に変更し、さらにソース コード ファイルの拡張子を `.cs` から `.vb`に変更します。 
  
```  
  
csc CreateResources.cs  
CreateResources  
  
resgen AppResources.resx  
  
csc GetStream.cs /resource:AppResources.resources  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">指定されたリソースの値が <see cref="T:System.IO.MemoryStream" /> オブジェクトではありません。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Resources.MissingManifestResourceException">使用できるリソースのセットが見つからず、既定のリソースもありません。 この例外の処理方法の詳細については、<see cref="T:System.Resources.ResourceManager" /> クラスのトピックの MissingManifestResourceException 例外と MissingSatelliteAssemblyException 例外の処理に関するセクションを参照してください。</exception>
        <exception cref="T:System.Resources.MissingSatelliteAssemblyException">既定のカルチャのリソースがサテライト アセンブリに存在し、そのサテライト アセンブリが見つかりませんでした。 この例外の処理方法の詳細については、<see cref="T:System.Resources.ResourceManager" /> クラスのトピックの MissingManifestResourceException 例外と MissingSatelliteAssemblyException 例外の処理に関するセクションを参照してください。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />します。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /> (関連する列挙体)</permission>
      </Docs>
    </Member>
    <Member MemberName="GetStream">
      <MemberSignature Language="C#" Value="public System.IO.UnmanagedMemoryStream GetStream (string name, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.UnmanagedMemoryStream GetStream(string name, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetStream(System.String,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetStream (name As String, culture As CultureInfo) As UnmanagedMemoryStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::UnmanagedMemoryStream ^ GetStream(System::String ^ name, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.GetStream : string * System.Globalization.CultureInfo -&gt; System.IO.UnmanagedMemoryStream" Usage="resourceManager.GetStream (name, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.UnmanagedMemoryStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">リソースの名前。</param>
        <param name="culture">リソース検索に使用するカルチャを指定するオブジェクト。 <paramref name="culture" /> が <see langword="null" /> の場合は、現在のスレッドのカルチャが使用されます。</param>
        <summary>指定したカルチャを使用し、指定したリソースからアンマネージ メモリ ストリーム オブジェクトを返します。</summary>
        <returns>リソースを表すアンマネージ メモリ ストリーム オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceManager.GetStream%2A>メソッドとして格納されているリソースの名前を受け取り、<xref:System.IO.MemoryStream>オブジェクトの値を取得、<xref:System.Object>リソース、および返します、<xref:System.IO.UnmanagedMemoryStream>オブジェクト。 オブジェクトに変換し、バイトのストリームを直接操作することが必要です。 このメソッドは主にパフォーマンス上の理由です。明示的なオブジェクトではなくバイト ストリームとしてリソースを取得すると、パフォーマンスを向上させることができます。  
  
 指定されたカルチャ用に、返されたリソースがローカライズ`culture`、またはカルチャで指定されている、<xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType>プロパティ場合`culture`は`null`します。 リソースがそのカルチャのローカライズされていない場合、リソース マネージャーは適切なリソースの読み込みにフォールバック規則を使用します。 使用できるローカライズされたリソースのセットが見つからない場合、<xref:System.Resources.ResourceManager>既定のカルチャのリソースにフォールバックします。 既定のカルチャのリソース セットが見つからない場合、メソッドがスローされます、<xref:System.Resources.MissingManifestResourceException>例外や、サテライト アセンブリ内に存在するリソース セットが予想される場合、<xref:System.Resources.MissingSatelliteAssemblyException>例外。 適切なリソースが設定という名前のリソースを見つけることができませんが、リソース マネージャーが読み込むことができる場合`name`、メソッドを返します`null`します。  
  
 <xref:System.Resources.ResourceManager.IgnoreCase%2A>プロパティを決定するかどうかの比較`name`リソースの名前を持つ大文字小文字が (既定値) または大文字小文字を区別します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">指定されたリソースの値が <see cref="T:System.IO.MemoryStream" /> オブジェクトではありません。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Resources.MissingManifestResourceException">使用できるリソースのセットが見つからず、既定のリソースもありません。 この例外の処理方法の詳細については、<see cref="T:System.Resources.ResourceManager" /> クラスのトピックの MissingManifestResourceException 例外と MissingSatelliteAssemblyException 例外の処理に関するセクションを参照してください。</exception>
        <exception cref="T:System.Resources.MissingSatelliteAssemblyException">既定のカルチャのリソースがサテライト アセンブリに存在し、そのサテライト アセンブリが見つかりませんでした。 この例外の処理方法の詳細については、<see cref="T:System.Resources.ResourceManager" /> クラスのトピックの MissingManifestResourceException 例外と MissingSatelliteAssemblyException 例外の処理に関するセクションを参照してください。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />します。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /> (関連する列挙体)</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetString">
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定したカルチャまたは現在の UI カルチャの指定した文字列リソースを返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetString (name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetString(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetString : string -&gt; string&#xA;override this.GetString : string -&gt; string" Usage="resourceManager.GetString name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">取得するリソースの名前。</param>
        <summary>指定されている文字列リソースの値を返します。</summary>
        <returns>呼び出し元の現在の UI カルチャのためにローカライズされたリソースの値、または、リソース セットで <see langword="null" /> が見つからない場合は <paramref name="name" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="desktop-apps"></a>デスクトップ アプリ  
 デスクトップ アプリは、返されるリソースが、現在のスレッドの UI カルチャのローカライズで定義されている、<xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType>プロパティ。 次の「リソース フォールバック プロセス」セクションに記載されている手順に従って、resource manager がプローブ リソースの場合は、そのカルチャのリソースがローカライズされておらず、、 [Packaging and Deploying Resources](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md)記事。 使用できるローカライズされたリソースのセットが見つからない場合、リソース マネージャーの既定のカルチャのリソースにフォールバックします。 メソッドがスローする場合は、リソース マネージャーは、既定のカルチャのリソース セットを読み込むことができません、<xref:System.Resources.MissingManifestResourceException>例外や、サテライト アセンブリ内に存在するリソース セットが予想される場合、<xref:System.Resources.MissingSatelliteAssemblyException>例外。 適切なリソースが設定という名前のリソースを見つけることができませんが、リソース マネージャーが読み込むことができる場合`name`、メソッドを返します`null`します。  
  
 <xref:System.Resources.ResourceManager.IgnoreCase%2A>プロパティを決定するかどうかの比較`name`リソースの名前を持つ大文字小文字が (既定値) または大文字小文字を区別します。  
  
> [!CAUTION]
>  このメソッドは、表示されているもの以外の例外をスローできます。 これが発生する理由の 1 つは、このメソッドを呼び出すメソッドが例外をスローするかどうかです。  たとえば、<xref:System.IO.FileLoadException>の配置またはサテライト アセンブリのインストール エラーが行われた場合、例外がスローされる<xref:System.Runtime.Serialization.SerializationException>型が逆シリアル化時に、ユーザー定義型がユーザー定義の例外をスローした場合、例外がスローされる可能性が。  
  
## <a name="includewin8appnamelongincludeswin8-appname-long-mdmd-apps"></a>[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] アプリ  
  
> [!IMPORTANT]
>  <xref:System.Resources.ResourceManager> クラスは [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] アプリでサポートされていますが、その使用は推奨されていません。 [!INCLUDE[net_portable](~/includes/net-portable-md.md)] アプリで使用できる[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]を開発する場合にのみ、このクラスを使用します。 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] アプリのリソースを取得するには、[Windows.ApplicationModel.Resources.ResourceLoader](https://go.microsoft.com/fwlink/p/?LinkId=238182) クラスを代わりに使用します。  
  
 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]アプリ、<xref:System.Resources.ResourceManager.GetString%28System.String%29>メソッドの値を返します、`name`文字列リソース、呼び出し元の現在の UI カルチャ設定用にローカライズされています。 カルチャの一覧については、オペレーティング システムの推奨される UI 言語の一覧から派生します。 リソース マネージャーが一致しない場合`name`、メソッドを返します`null`します。  
  
   
  
## Examples  
 次の例では、<xref:System.Resources.ResourceManager.GetString%2A> メソッドを使用して、カルチャ固有のリソースを取得します。 これは、英語 (en)、フランス語 (フランス) (fr-FR)、およびロシア語 (ロシア) (ru-RU) の .txt ファイルからコンパイルされたリソースで構成されます。 例では、現在のカルチャと現在の UI カルチャを、英語 (米国)、フランス語 (フランス)、ロシア語 (ロシア)、およびスウェーデン語 (スウェーデン) に変更します。 それから、<xref:System.Resources.ResourceManager.GetString%2A> メソッドを呼び出して、ローカライズされた文字列を取得します。この文字列は現在の日付と月と一緒に表示されます。 現在の UI カルチャがスウェーデン語 (スウェーデン) である場合を除き、適切なローカライズされた文字列が出力に表示されることに注意してください。 スウェーデン語の言語リソースが利用できないため、アプリは代わりに既定のカルチャである英語のリソースを使用します。 例には、次の表に記載されたテキスト ベースのリソース ファイルが必要です。 それぞれには `DateStart` という名前の唯一の文字列リソースがあります。  
  
|カルチャ|ファイル名|リソース名|リソースの値|  
|-------------|---------------|-------------------|--------------------|  
|en-US|DateStrings.txt|`DateStart`|Today is|  
|fr-FR|DateStrings.fr-FR.txt|`DateStart`|Aujourd'hui, c'est le|  
|ru-RU|DateStrings.ru-RU.txt|`DateStart`|Сегодня|  
  
 次のバッチ ファイルを使用して、C# の例をコンパイルすることができます。 Visual Basic の場合は、 `csc` を `vbc`に変更し、さらにソース コード ファイルの拡張子を `.cs` から `.vb`に変更します。  
  
```  
resgen DateStrings.txt  
csc showdate.cs /resource:DateStrings.resources  
  
md fr-FR  
resgen DateStrings.fr-FR.txt  
al /out:fr-FR\Showdate.resources.dll /culture:fr-FR /embed:DateStrings.fr-FR.resources   
  
md ru-RU  
resgen DateStrings.ru-RU.txt  
al /out:ru-RU\Showdate.resources.dll /culture:ru-RU /embed:DateStrings.ru-RU.resources  
```  
  
 次の例では、(Visual Basic バージョンの ShowDate.vb) または ShowDate.cs C# バージョンのソース コードに示します。  
  
 [!code-csharp[System.Resources.ResourceManager.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.class/cs/showdate.cs#2)]
 [!code-vb[System.Resources.ResourceManager.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.class/vb/showdate.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">指定されたリソースの値が文字列ではありません。</exception>
        <exception cref="T:System.Resources.MissingManifestResourceException">使用できるリソースのセットが見つからず、既定のカルチャ用のリソースもありません。 この例外の処理方法の詳細については、<see cref="T:System.Resources.ResourceManager" /> クラスのトピックの MissingManifestResourceException 例外と MissingSatelliteAssemblyException 例外の処理に関するセクションを参照してください。</exception>
        <exception cref="T:System.Resources.MissingSatelliteAssemblyException">既定のカルチャのリソースがサテライト アセンブリに存在し、そのサテライト アセンブリが見つかりませんでした。 この例外の処理方法の詳細については、<see cref="T:System.Resources.ResourceManager" /> クラスのトピックの MissingManifestResourceException 例外と MissingSatelliteAssemblyException 例外の処理に関するセクションを参照してください。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />します。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /> (関連する列挙体)</permission>
        <threadsafe><see cref="M:System.Resources.ResourceManager.GetString(System.String)" />メソッドはスレッド セーフであります。</threadsafe>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">リソースのパッケージ化と配置</related>
        <related type="Article" href="https://msdn.microsoft.com/library/eca16922-1c46-4f68-aefe-e7a12283641f">サテライト アセンブリにリソースを取得します。</related>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (string name, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(string name, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.GetString(System.String,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetString (name As String, culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetString(System::String ^ name, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member GetString : string * System.Globalization.CultureInfo -&gt; string&#xA;override this.GetString : string * System.Globalization.CultureInfo -&gt; string" Usage="resourceManager.GetString (name, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="name">取得するリソースの名前。</param>
        <param name="culture">リソースのローカライズ先のカルチャを表すオブジェクト。</param>
        <summary>指定したカルチャにローカライズされている文字列リソースの値を返します。</summary>
        <returns>指定されたカルチャのためにローカライズされたリソースの値、または、リソース セットで <paramref name="name" /> が見つからない場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="desktop-apps"></a>デスクトップ アプリ  
 デスクトップ アプリ場合`culture`は`null`、<xref:System.Resources.ResourceManager.GetString%28System.String%2CSystem.Globalization.CultureInfo%29>メソッドから取得した現在の UI カルチャを使用して、<xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType>プロパティ。  
  
 返されるリソースがで指定されたカルチャのローカライズ、`culture`パラメーター。 リソースがローカライズされていない場合`culture`、リソースを次の「リソース フォールバック プロセス」セクションに記載されている手順に従って、リソース マネージャーは、プローブ、 [Packaging and Deploying Resources](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md)トピック。 使用できるリソースのセットが見つからない場合、リソース マネージャーの既定のカルチャのリソースにフォールバックします。 メソッドがスローする場合は、リソース マネージャーは、既定のカルチャのリソース セットを読み込むことができません、<xref:System.Resources.MissingManifestResourceException>例外や、サテライト アセンブリ内に存在するリソース セットが予想される場合、<xref:System.Resources.MissingSatelliteAssemblyException>例外。 適切なリソースが設定という名前のリソースを見つけることができませんが、リソース マネージャーが読み込むことができる場合`name`、メソッドを返します`null`します。  
  
 <xref:System.Resources.ResourceManager.IgnoreCase%2A>プロパティを決定するかどうかの比較`name`リソースの名前を持つ大文字小文字が (既定値) または大文字小文字を区別します。  
  
> [!CAUTION]
>  このメソッドは、表示されているもの以外の例外をスローできます。 これが発生する理由の 1 つは、このメソッドを呼び出すメソッドが例外をスローするかどうかです。  たとえば、<xref:System.IO.FileLoadException>の配置またはサテライト アセンブリのインストール エラーが行われた場合、例外がスローされる<xref:System.Runtime.Serialization.SerializationException>型が逆シリアル化時に、ユーザー定義型がユーザー定義の例外をスローした場合、例外がスローされる可能性が。  
  
## <a name="includewin8appnamelongincludeswin8-appname-long-mdmd-apps"></a>[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] アプリ  
  
> [!IMPORTANT]
>  <xref:System.Resources.ResourceManager> クラスは [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] アプリでサポートされていますが、その使用は推奨されていません。 [!INCLUDE[net_portable](~/includes/net-portable-md.md)] アプリで使用できる[!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]を開発する場合にのみ、このクラスを使用します。 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] アプリのリソースを取得するには、[Windows.ApplicationModel.Resources.ResourceLoader](https://go.microsoft.com/fwlink/p/?LinkId=238182) クラスを代わりに使用します。  
  
 [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] 、アプリ、<xref:System.Resources.ResourceManager.GetString%28System.String%2CSystem.Globalization.CultureInfo%29>メソッドの値を返します、`name`文字列で指定されたカルチャのローカライズされたリソース、`culture`パラメーター。 リソースがローカライズされていない場合、`culture`全体を使用するカルチャ、ルックアップ[!INCLUDE[win8](~/includes/win8-md.md)]言語フォールバックのリスト、および既定のカルチャで検索した後を停止します。 リソース マネージャーが一致しない場合`name`、メソッドを返します`null`します。  
  
   
  
## Examples  
 次の例では、<xref:System.Resources.ResourceManager.GetString%28System.String%2CSystem.Globalization.CultureInfo%29> メソッドを使用して、カルチャ固有のリソースを取得します。 例の既定のカルチャが英語 (en) とフランス語 (フランス) (FR-FR)、ロシア語 (ロシア) (RU-RU) のサテライト アセンブリが含まれていますカルチャ。 例は、変更、現在のカルチャと UI カルチャを現在ロシア語 (ロシア) を呼び出す前に<xref:System.Resources.ResourceManager.GetString%28System.String%2CSystem.Globalization.CultureInfo%29>します。 呼び出して、<xref:System.Resources.ResourceManager.GetString%2A>メソッドと<xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>メソッドを呼び出し<xref:System.Globalization.CultureInfo>各メソッドにフランス語 (フランス) とスウェーデン語 (スウェーデン) カルチャを表すオブジェクト。 出力では、月と日、月と同様に、その文字列のために表示、フランス語、<xref:System.Resources.ResourceManager.GetString%2A>メソッドは、フランス語の言語リソースを取得できません。 ただし、スウェーデン語 (スウェーデン) カルチャを使用したときに月と日、月の表示スウェーデン語では英語で入力して、その文字列が。 これは、します代わりに既定の英語カルチャのリソースを返すように、リソース マネージャーが、スウェーデン語のローカライズされたリソースを検出できないため。  
  
 例には、次の表に記載されたテキスト ベースのリソース ファイルが必要です。 それぞれには `DateStart` という名前の唯一の文字列リソースがあります。  
  
|カルチャ|ファイル名|リソース名|リソースの値|  
|-------------|---------------|-------------------|--------------------|  
|en-US|DateStrings.txt|`DateStart`|Today is|  
|fr-FR|DateStrings.fr-FR.txt|`DateStart`|Aujourd'hui, c'est le|  
|ru-RU|DateStrings.ru-RU.txt|`DateStart`|Сегодня|  
  
 次のバッチ ファイルを使用して、Visual Basic の例をコンパイルすることができます。 C# でコンパイルする`vbc`に`csc`からソース コード ファイルの拡張子を変更および`.vb`に`.cs`。  
  
```  
resgen DateStrings.txt  
vbc showdate.vb /resource:DateStrings.resources  
  
md fr-FR  
resgen DateStrings.fr-FR.txt  
al /out:fr-FR\Showdate.resources.dll /culture:fr-FR /embed:DateStrings.fr-FR.resources   
  
md ru-RU  
resgen DateStrings.ru-RU.txt  
al /out:ru-RU\Showdate.resources.dll /culture:ru-RU /embed:DateStrings.ru-RU.resources  
```  
  
 次の例では、(Visual Basic バージョンの ShowDate.vb) または ShowDate.cs C# バージョンのソース コードに示します。  
  
 [!code-csharp[System.Resources.ResourceManager.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcemanager.class/cs/showdate2.cs#3)]
 [!code-vb[System.Resources.ResourceManager.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcemanager.class/vb/showdate2.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.InvalidOperationException">指定されたリソースの値が文字列ではありません。</exception>
        <exception cref="T:System.Resources.MissingManifestResourceException">使用できるリソースのセットが見つからず、既定のカルチャ用のリソースもありません。 この例外の処理方法の詳細については、<see cref="T:System.Resources.ResourceManager" /> クラスのトピックの MissingManifestResourceException 例外と MissingSatelliteAssemblyException 例外の処理に関するセクションを参照してください。</exception>
        <exception cref="T:System.Resources.MissingSatelliteAssemblyException">既定のカルチャのリソースがサテライト アセンブリに存在し、そのサテライト アセンブリが見つかりませんでした。 この例外の処理方法の詳細については、<see cref="T:System.Resources.ResourceManager" /> クラスのトピックの MissingManifestResourceException 例外と MissingSatelliteAssemblyException 例外の処理に関するセクションを参照してください。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />します。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /> (関連する列挙体)</permission>
        <threadsafe><see cref="M:System.Resources.ResourceManager.GetString(System.String,System.Globalization.CultureInfo)" />メソッドはスレッド セーフであります。</threadsafe>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">リソースのパッケージ化と配置</related>
      </Docs>
    </Member>
    <Member MemberName="HeaderVersionNumber">
      <MemberSignature Language="C#" Value="public static readonly int HeaderVersionNumber;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int32 HeaderVersionNumber" />
      <MemberSignature Language="DocId" Value="F:System.Resources.ResourceManager.HeaderVersionNumber" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly HeaderVersionNumber As Integer " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly int HeaderVersionNumber;" />
      <MemberSignature Language="F#" Value=" staticval mutable HeaderVersionNumber : int" Usage="System.Resources.ResourceManager.HeaderVersionNumber" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Resources.ResourceManager" /> の現在の実装が解釈および作成できるリソース ファイル ヘッダーのバージョンを指定します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IgnoreCase">
      <MemberSignature Language="C#" Value="public virtual bool IgnoreCase { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IgnoreCase" />
      <MemberSignature Language="DocId" Value="P:System.Resources.ResourceManager.IgnoreCase" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property IgnoreCase As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IgnoreCase { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IgnoreCase : bool with get, set" Usage="System.Resources.ResourceManager.IgnoreCase" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>リソース マネージャーが <see cref="M:System.Resources.ResourceManager.GetString(System.String)" /> メソッドと <see cref="M:System.Resources.ResourceManager.GetObject(System.String)" /> メソッドで大文字と小文字を区別しないリソースの検索を許可しているかどうかを示す値を取得または設定します。</summary>
        <value>リソースの検索時に大文字と小文字の区別を無視する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合の値、<xref:System.Resources.ResourceManager.IgnoreCase%2A>プロパティは`false`、「リソース」という名前のリソースが「リソース」という名前のリソースと同じです。 場合<xref:System.Resources.ResourceManager.IgnoreCase%2A>は`true`、「リソース」という名前のリソースは「リソース」という名前のリソースと同じです。 ただし、時に<xref:System.Resources.ResourceManager.IgnoreCase%2A>は`true`、<xref:System.Resources.ResourceManager.GetString%2A?displayProperty=nameWithType>と<xref:System.Resources.ResourceManager.GetObject%2A?displayProperty=nameWithType>メソッドは、インバリアント カルチャを使用して大文字の文字列比較を実行します。 利点は、これらのメソッドによって実行される大文字の文字列比較の結果が、カルチャに関係なくすべてのコンピューターで同じになることです。 欠点は、結果、すべてのカルチャの大文字小文字の規則と一致しないことです。  
  
 たとえば、トルコ語のアルファベットは、ドットで I の文字の 2 つのバージョンとドットのない 1 つがあります。 トルコ語では、文字 I (Unicode 0049) と見なされます ı (Unicode 0131) 別の文字の大文字バージョン。 文字 i (Unicode 0069) は、さらに別の文字 İ (Unicode 0130) の小文字のバージョンと見なされます。 大文字の文字列比較をこれらの大文字小文字の区別規則に従って文字 (Unicode 0069) を i と I (Unicode 0049) が"TR-TR"(七面鳥のトルコ語) のカルチャの失敗する必要があります。 ただし、インバリアント カルチャの大文字小文字の規則を使用して、比較が実行されるため、<xref:System.Resources.ResourceManager.IgnoreCase%2A>は`true`、この比較は成功します。  
  
> [!NOTE]
>  パフォーマンス上の理由は、常に、リソース名の大文字小文字が正しくを指定することをお勧めします。 設定<xref:System.Resources.ResourceManager.IgnoreCase%2A>に`true`ワーキング セットとパフォーマンスの大幅な低下の大幅な増加が発生することができます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InternalGetResourceSet">
      <MemberSignature Language="C#" Value="protected virtual System.Resources.ResourceSet InternalGetResourceSet (System.Globalization.CultureInfo culture, bool createIfNotExists, bool tryParents);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Resources.ResourceSet InternalGetResourceSet(class System.Globalization.CultureInfo culture, bool createIfNotExists, bool tryParents) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.InternalGetResourceSet(System.Globalization.CultureInfo,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function InternalGetResourceSet (culture As CultureInfo, createIfNotExists As Boolean, tryParents As Boolean) As ResourceSet" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Resources::ResourceSet ^ InternalGetResourceSet(System::Globalization::CultureInfo ^ culture, bool createIfNotExists, bool tryParents);" />
      <MemberSignature Language="F#" Value="abstract member InternalGetResourceSet : System.Globalization.CultureInfo * bool * bool -&gt; System.Resources.ResourceSet&#xA;override this.InternalGetResourceSet : System.Globalization.CultureInfo * bool * bool -&gt; System.Resources.ResourceSet" Usage="resourceManager.InternalGetResourceSet (culture, createIfNotExists, tryParents)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Resources.ResourceSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="createIfNotExists" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="tryParents" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="culture">検索対象のカルチャ オブジェクト。</param>
        <param name="createIfNotExists">リソース セットがまだ読み込まれていなければ読み込む場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <param name="tryParents">リソース セットを読み込むことができないときに、親 <see cref="T:System.Globalization.CultureInfo" /> オブジェクトを確認する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>リソース セットを検索するための実装を提供します。</summary>
        <returns>指定されたリソース セット。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">メイン アセンブリに .resources ファイルが含まれていませんが、これはリソースの検索に必要です。</exception>
        <exception cref="T:System.ExecutionEngineException">ランタイムで、内部エラーが発生しました。</exception>
        <exception cref="T:System.Resources.MissingSatelliteAssemblyException"><paramref name="culture" /> に関連付けられているサテライト アセンブリを配置できません。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />します。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /> (関連する列挙体)</permission>
        <block subset="none" type="overrides"><para>このメソッドは、リソースの設定、ありことは再帰的な再入を検索するために必要なすべての作業を完了します。 アセンブリとトリガーつまり、このメソッドを読み込む可能性があります、<see cref="E:System.AppDomain.AssemblyLoad" />にコールバックする、イベント、<see cref="T:System.Resources.ResourceManager" />オブジェクトを完全に初期化されていません。 過剰なロックを防ぐためにこのメソッドはスレッド セーフではありません。 <see cref="M:System.Resources.ResourceManager.GetResourceSet(System.Globalization.CultureInfo,System.Boolean,System.Boolean)" />、 <see cref="M:System.Resources.ResourceManager.GetString(System.String)" />、および<see cref="M:System.Resources.ResourceManager.GetObject(System.String)" />メソッドは、必要なすべての同期を行います。</para></block>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <related type="Article" href="~/docs/standard/globalization-localization/index.md">.NET アプリケーションのグローバライズとローカライズ</related>
      </Docs>
    </Member>
    <Member MemberName="MagicNumber">
      <MemberSignature Language="C#" Value="public static readonly int MagicNumber;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int32 MagicNumber" />
      <MemberSignature Language="DocId" Value="F:System.Resources.ResourceManager.MagicNumber" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MagicNumber As Integer " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly int MagicNumber;" />
      <MemberSignature Language="F#" Value=" staticval mutable MagicNumber : int" Usage="System.Resources.ResourceManager.MagicNumber" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>リソース ファイルを識別するために使用する番号を保持します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 値は、0xBEEFCACE に設定されます。 システムの既定のファイル形式の最初の 4 バイトがリトル エンディアン形式の 32 ビット符号付き整数を含む (を参照してください<xref:System.Text.Encoding>)。  
  
 場合、<xref:System.Resources.ResourceManager.MagicNumber>が見つかると、それに続くバイトのバージョン番号になります、<xref:System.Resources.ResourceManager>と過去のこのヘッダーを取得するバイト数をスキップするかを示す番号が続くヘッダー。 次の番号は、のバージョンを示す、<xref:System.Resources.ResourceManager>バージョンについては後に、ヘッダーを作成します。  
  
 現在の実装のバージョン番号は、1 つです。 次のバイトは固定長の文字列の名前を含む、 <xref:System.Resources.IResourceReader>、このファイルの読み取りができます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MainAssembly">
      <MemberSignature Language="C#" Value="protected System.Reflection.Assembly MainAssembly;" />
      <MemberSignature Language="ILAsm" Value=".field family class System.Reflection.Assembly MainAssembly" />
      <MemberSignature Language="DocId" Value="F:System.Resources.ResourceManager.MainAssembly" />
      <MemberSignature Language="VB.NET" Value="Protected MainAssembly As Assembly " />
      <MemberSignature Language="C++ CLI" Value="protected: System::Reflection::Assembly ^ MainAssembly;" />
      <MemberSignature Language="F#" Value="val mutable MainAssembly : System.Reflection.Assembly" Usage="System.Resources.ResourceManager.MainAssembly" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>リソースを含むメイン アセンブリを指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceManager.MainAssembly>フィールドはから派生した独自のクラスを記述する場合にのみ役立ちますが、<xref:System.Resources.ResourceManager>クラス。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseAllResources">
      <MemberSignature Language="C#" Value="public virtual void ReleaseAllResources ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReleaseAllResources() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceManager.ReleaseAllResources" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ReleaseAllResources ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReleaseAllResources();" />
      <MemberSignature Language="F#" Value="abstract member ReleaseAllResources : unit -&gt; unit&#xA;override this.ReleaseAllResources : unit -&gt; unit" Usage="resourceManager.ReleaseAllResources " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>リソース マネージャーに、すべての <see cref="M:System.Resources.ResourceSet.Close" /> オブジェクトの <see cref="T:System.Resources.ResourceSet" /> メソッドを呼び出し、すべてのリソースを解放するように指示します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、実行中のアプリのワーキング セットに縮小されます。 これで、将来のリソース検索<xref:System.Resources.ResourceManager>リソース マネージャーを検索する必要があるためにオブジェクトが最初の参照としてコストがかかるするリソースを再度読み込むとします。 これは、役立ちます、複雑なスレッド シナリオで、新しい<xref:System.Resources.ResourceManager>オブジェクトが適切な動作です。  
  
> [!NOTE]
>  .NET Framework バージョン 2.0 以降、<xref:System.Resources.ResourceManager.ReleaseAllResources%2A>メソッドはスレッド セーフを<xref:System.Resources.ResourceManager.GetObject%2A>、 <xref:System.Resources.ResourceManager.GetString%2A>、および<xref:System.Resources.ResourceManager.GetStream%2A>操作。 この変更の利点は、リソースにアクセスする複数のスレッドのパフォーマンスの向上です。 ただし、呼び出した場合、<xref:System.Resources.ResourceManager.ReleaseAllResources%2A>メソッド別のスレッドで同時に、リソースを取得中に 1 つのスレッドで、get 操作をスローできます、<xref:System.ObjectDisposedException>例外。  
  
 リソース マネージャーは完全にスコープ外に出るし、ガベージ コレクションが待機することがなく、確定的にリリースされる、現在のリソース マネージャーで作成したリソースの管理対象のインスタンスがない状況でこのメソッドを使用することもできます。  
  
> [!NOTE]
>  このメソッドを呼び出す場合、サテライト アセンブリはアンロードされません。 サテライト アセンブリをアンロードするには使用、<xref:System.AppDomain.Unload%2A>メソッド。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />します。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /> (関連する列挙体)</permission>
      </Docs>
    </Member>
    <Member MemberName="ResourceSets">
      <MemberSignature Language="C#" Value="protected System.Collections.Hashtable ResourceSets;" />
      <MemberSignature Language="ILAsm" Value=".field family class System.Collections.Hashtable ResourceSets" />
      <MemberSignature Language="DocId" Value="F:System.Resources.ResourceManager.ResourceSets" />
      <MemberSignature Language="VB.NET" Value="Protected ResourceSets As Hashtable " />
      <MemberSignature Language="C++ CLI" Value="protected: System::Collections::Hashtable ^ ResourceSets;" />
      <MemberSignature Language="F#" Value="val mutable ResourceSets : System.Collections.Hashtable" Usage="System.Resources.ResourceManager.ResourceSets" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("call InternalGetResourceSet instead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Hashtable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>カルチャから <see cref="T:System.Collections.Hashtable" /> オブジェクトへの割り当てを返す <see cref="T:System.Resources.ResourceSet" /> を格納します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResourceSetType">
      <MemberSignature Language="C#" Value="public virtual Type ResourceSetType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ResourceSetType" />
      <MemberSignature Language="DocId" Value="P:System.Resources.ResourceManager.ResourceSetType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ResourceSetType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ResourceSetType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ResourceSetType : Type" Usage="System.Resources.ResourceManager.ResourceSetType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Resources.ResourceSet" /> オブジェクトの構築にリソース マネージャーが使用するリソース セット オブジェクトの型を取得します。</summary>
        <value><see cref="T:System.Resources.ResourceSet" /> オブジェクトの構築にリソース マネージャーが使用するリソース セット オブジェクトの型。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>