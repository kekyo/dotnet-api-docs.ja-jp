<Type Name="Semaphore" FullName="System.Threading.Semaphore">
  <Metadata><Meta Name="ms.openlocfilehash" Value="d638e7414db4766474b41ea6758371ad781b249c" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57934159" /></Metadata><TypeSignature Language="C#" Value="public sealed class Semaphore : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Semaphore extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Semaphore" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Semaphore&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class Semaphore sealed : System::Threading::WaitHandle" />
  <TypeSignature Language="F#" Value="type Semaphore = class&#xA;    inherit WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="7e7a3-101">リソースまたはリソースのプールに同時にアクセスできるスレッドの数を制限します。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-101">Limits the number of threads that can access a resource or pool of resources concurrently.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7e7a3-102">使用して、<xref:System.Threading.Semaphore>リソースのプールへのアクセスを制御するクラス。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-102">Use the <xref:System.Threading.Semaphore> class to control access to a pool of resources.</span></span> <span data-ttu-id="7e7a3-103">スレッドがセマフォに入る呼び出すことによって、<xref:System.Threading.WaitHandle.WaitOne%2A>から継承されるメソッド、<xref:System.Threading.WaitHandle>クラス、およびを呼び出してセマフォの解放、<xref:System.Threading.Semaphore.Release%2A>メソッド。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-103">Threads enter the semaphore by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method, which is inherited from the <xref:System.Threading.WaitHandle> class, and release the semaphore by calling the <xref:System.Threading.Semaphore.Release%2A> method.</span></span>  
  
 <span data-ttu-id="7e7a3-104">セマフォのカウントは、スレッドがセマフォに入るし、スレッドがセマフォを解放するときにインクリメントされますたびに減少します。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-104">The count on a semaphore is decremented each time a thread enters the semaphore, and incremented when a thread releases the semaphore.</span></span> <span data-ttu-id="7e7a3-105">カウントが 0 の場合、後続の要求は他のスレッドがセマフォを解放するまでブロックします。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-105">When the count is zero, subsequent requests block until other threads release the semaphore.</span></span> <span data-ttu-id="7e7a3-106">すべてのスレッドがセマフォを解放、ときにカウントが最大値で指定されて、セマフォが作成されたとき。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-106">When all threads have released the semaphore, the count is at the maximum value specified when the semaphore was created.</span></span>  
  
 <span data-ttu-id="7e7a3-107">FIFO や LIFO、ブロックされたスレッドがセマフォに入るなどの保証の順序はありません。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-107">There is no guaranteed order, such as FIFO or LIFO, in which blocked threads enter the semaphore.</span></span>  
  
 <span data-ttu-id="7e7a3-108">スレッドはセマフォに入る、複数回呼び出すことによって、<xref:System.Threading.WaitHandle.WaitOne%2A>メソッド繰り返し。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-108">A thread can enter the semaphore multiple times, by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method repeatedly.</span></span> <span data-ttu-id="7e7a3-109">これらのエントリの一部またはすべてをリリースするには、スレッドをパラメーターなしに呼び出すことができます<xref:System.Threading.Semaphore.Release>メソッドのオーバー ロードが複数回、またはそれが呼び出すことができます、<xref:System.Threading.Semaphore.Release%28System.Int32%29>メソッドのオーバー ロードが解放されるエントリの数を指定します。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-109">To release some or all of these entries, the thread can call the parameterless <xref:System.Threading.Semaphore.Release> method overload multiple times, or it can call the <xref:System.Threading.Semaphore.Release%28System.Int32%29> method overload that specifies the number of entries to be released.</span></span>  
  
 <span data-ttu-id="7e7a3-110"><xref:System.Threading.Semaphore>クラスへの呼び出しでスレッド id は強制されません<xref:System.Threading.WaitHandle.WaitOne%2A>または<xref:System.Threading.Semaphore.Release%2A>します。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-110">The <xref:System.Threading.Semaphore> class does not enforce thread identity on calls to <xref:System.Threading.WaitHandle.WaitOne%2A> or <xref:System.Threading.Semaphore.Release%2A>.</span></span> <span data-ttu-id="7e7a3-111">あるスレッドはセマフォの解放回数が多すぎますのプログラマの責任になります。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-111">It is the programmer's responsibility to ensure that threads do not release the semaphore too many times.</span></span> <span data-ttu-id="7e7a3-112">たとえば、セマフォの最大カウントが 2 で、スレッド A とスレッド B が両方ともセマフォに入るとします。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-112">For example, suppose a semaphore has a maximum count of two, and that thread A and thread B both enter the semaphore.</span></span> <span data-ttu-id="7e7a3-113">スレッド B でのプログラミング エラー原因を呼び出せるかどうか<xref:System.Threading.Semaphore.Release%2A>2 回、両方の呼び出しが成功します。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-113">If a programming error in thread B causes it to call <xref:System.Threading.Semaphore.Release%2A> twice, both calls succeed.</span></span> <span data-ttu-id="7e7a3-114">セマフォのカウントがいっぱいになっているときに、スレッド A も <xref:System.Threading.Semaphore.Release%2A> を呼び出すと、<xref:System.Threading.SemaphoreFullException> がスローされます。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-114">The count on the semaphore is full, and when thread A eventually calls <xref:System.Threading.Semaphore.Release%2A>, a <xref:System.Threading.SemaphoreFullException> is thrown.</span></span>  
  
 <span data-ttu-id="7e7a3-115">セマフォは次の 2 つの種類: ローカル セマフォおよび名前付きシステム セマフォです。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-115">Semaphores are of two types: local semaphores and named system semaphores.</span></span> <span data-ttu-id="7e7a3-116">作成する場合、<xref:System.Threading.Semaphore>オブジェクト、名前を受け入れるコンス トラクターを使用してその名前のオペレーティング システム セマフォに関連付けられています。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-116">If you create a <xref:System.Threading.Semaphore> object using a constructor that accepts a name, it is associated with an operating-system semaphore of that name.</span></span> <span data-ttu-id="7e7a3-117">名前付きシステム セマフォは、オペレーティング システム全体から参照でき、プロセスの動作を同期するために使用できます。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-117">Named system semaphores are visible throughout the operating system, and can be used to synchronize the activities of processes.</span></span> <span data-ttu-id="7e7a3-118">複数作成できます<xref:System.Threading.Semaphore>同じを表すオブジェクトの名前付きシステム セマフォの場合は、および使用することができます、<xref:System.Threading.Semaphore.OpenExisting%2A>メソッドを開き、既存の名前付きシステム セマフォです。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-118">You can create multiple <xref:System.Threading.Semaphore> objects that represent the same named system semaphore, and you can use the <xref:System.Threading.Semaphore.OpenExisting%2A> method to open an existing named system semaphore.</span></span>  
  
 <span data-ttu-id="7e7a3-119">プロセス内でのみ、ローカル セマフォが存在します。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-119">A local semaphore exists only within your process.</span></span> <span data-ttu-id="7e7a3-120">ローカル <xref:System.Threading.Semaphore> オブジェクトを参照するプロセス内のすべてのスレッドから使用できます。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-120">It can be used by any thread in your process that has a reference to the local <xref:System.Threading.Semaphore> object.</span></span> <span data-ttu-id="7e7a3-121">各<xref:System.Threading.Semaphore>オブジェクトが別のローカル セマフォです。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-121">Each <xref:System.Threading.Semaphore> object is a separate local semaphore.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7e7a3-122">次のコード例は、0 の最初の数の 3 つの最大数、およびセマフォを作成します。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-122">The following code example creates a semaphore with a maximum count of three and an initial count of zero.</span></span> <span data-ttu-id="7e7a3-123">例では、セマフォの待機をブロックする 5 つのスレッドを開始します。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-123">The example starts five threads, which block waiting for the semaphore.</span></span> <span data-ttu-id="7e7a3-124">メイン スレッドを使用して、<xref:System.Threading.Semaphore.Release%28System.Int32%29>メソッドのオーバー ロードは、次の 3 つのスレッドがセマフォに入るをできるように、最大容量にセマフォ カウントを増やします。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-124">The main thread uses the <xref:System.Threading.Semaphore.Release%28System.Int32%29> method overload to increase the semaphore count to its maximum, allowing three threads to enter the semaphore.</span></span> <span data-ttu-id="7e7a3-125">各スレッドを使用して、<xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>メソッドが、作業し、呼び出しをシミュレートするために、1 秒間待機する、<xref:System.Threading.Semaphore.Release>セマフォを解放するメソッドのオーバー ロードします。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-125">Each thread uses the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method to wait for one second, to simulate work, and then calls the <xref:System.Threading.Semaphore.Release> method overload to release the semaphore.</span></span> <span data-ttu-id="7e7a3-126">セマフォがリリースされるたびに、前のセマフォのカウントが表示されます。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-126">Each time the semaphore is released, the previous semaphore count is displayed.</span></span> <span data-ttu-id="7e7a3-127">コンソール メッセージ追跡セマフォを使用します。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-127">Console messages track semaphore use.</span></span> <span data-ttu-id="7e7a3-128">各スレッドは、出力を読みやすくするために、シミュレートされた動作の間隔が若干増加します。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-128">The simulated work interval is increased slightly for each thread, to make the output easier to read.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="7e7a3-129">この型はスレッド セーフです。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-129">This type is thread safe.</span></span></threadsafe>
    <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="7e7a3-130">マネージド スレッド処理</span><span class="sxs-lookup"><span data-stu-id="7e7a3-130">Managed Threading</span></span></related>
    <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md"><span data-ttu-id="7e7a3-131">Semaphore</span><span class="sxs-lookup"><span data-stu-id="7e7a3-131">Semaphore</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7e7a3-132"><see cref="T:System.Threading.Semaphore" /> クラスの新しいインスタンスを初期化します。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-132">Initializes a new instance of the <see cref="T:System.Threading.Semaphore" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="initialCount"><span data-ttu-id="7e7a3-133">同時に許可されるセマフォの要求の初期数。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-133">The initial number of requests for the semaphore that can be granted concurrently.</span></span></param>
        <param name="maximumCount"><span data-ttu-id="7e7a3-134">同時に許可されるセマフォの要求の最大数。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-134">The maximum number of requests for the semaphore that can be granted concurrently.</span></span></param>
        <summary><span data-ttu-id="7e7a3-135">エントリ数の初期値と同時実行エントリの最大数を指定して、<see cref="T:System.Threading.Semaphore" /> クラスの新しいインスタンスを初期化します。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-135">Initializes a new instance of the <see cref="T:System.Threading.Semaphore" /> class, specifying the initial number of entries and the maximum number of concurrent entries.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7e7a3-136">このコンス トラクターでは、無名のセマフォを初期化します。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-136">This constructor initializes an unnamed semaphore.</span></span> <span data-ttu-id="7e7a3-137">このようなセマフォのインスタンスを使用するすべてのスレッドには、インスタンスへの参照が必要です。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-137">All threads that use an instance of such a semaphore must have references to the instance.</span></span>  
  
 <span data-ttu-id="7e7a3-138">場合`initialCount`がより小さい`maximumCount`、現在のスレッドを呼び出した場合と同じ効果が<xref:System.Threading.WaitHandle.WaitOne%2A>(`maximumCount`マイナス`initialCount`) 時刻。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-138">If `initialCount` is less than `maximumCount`, the effect is the same as if the current thread had called <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) times.</span></span> <span data-ttu-id="7e7a3-139">セマフォを作成するスレッドのエントリを予約したくない場合の同じ番号を使用して、`maximumCount`と`initialCount`します。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-139">If you do not want to reserve any entries for the thread that creates the semaphore, use the same number for `maximumCount` and `initialCount`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7e7a3-140">次の例は、0 の最初の数の 3 つの最大数、およびセマフォを作成します。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-140">The following example creates a semaphore with a maximum count of three and an initial count of zero.</span></span> <span data-ttu-id="7e7a3-141">例では、セマフォの待機をブロックする 5 つのスレッドを開始します。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-141">The example starts five threads, which block waiting for the semaphore.</span></span> <span data-ttu-id="7e7a3-142">メイン スレッドを使用して、<xref:System.Threading.Semaphore.Release%28System.Int32%29>メソッドのオーバー ロードは、次の 3 つのスレッドがセマフォに入るをできるように、最大容量にセマフォ カウントを増やします。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-142">The main thread uses the <xref:System.Threading.Semaphore.Release%28System.Int32%29> method overload to increase the semaphore count to its maximum, allowing three threads to enter the semaphore.</span></span> <span data-ttu-id="7e7a3-143">各スレッドを使用して、<xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>メソッドが、作業し、呼び出しをシミュレートするために、1 秒間待機する、<xref:System.Threading.Semaphore.Release>セマフォを解放するメソッドのオーバー ロードします。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-143">Each thread uses the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method to wait for one second, to simulate work, and then calls the <xref:System.Threading.Semaphore.Release> method overload to release the semaphore.</span></span> <span data-ttu-id="7e7a3-144">セマフォがリリースされるたびに、前のセマフォのカウントが表示されます。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-144">Each time the semaphore is released, the previous semaphore count is displayed.</span></span> <span data-ttu-id="7e7a3-145">コンソール メッセージ追跡セマフォを使用します。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-145">Console messages track semaphore use.</span></span> <span data-ttu-id="7e7a3-146">各スレッドは、出力を読みやすくするために、シミュレートされた動作の間隔が若干増加します。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-146">The simulated work interval is increased slightly for each thread, to make the output easier to read.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7e7a3-147"><paramref name="initialCount" /> が <paramref name="maximumCount" /> より大きくなっています。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-147"><paramref name="initialCount" /> is greater than <paramref name="maximumCount" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="7e7a3-148"><paramref name="maximumCount" /> が 1 未満です。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-148"><paramref name="maximumCount" /> is less than 1.</span></span>  
  
<span data-ttu-id="7e7a3-149">または</span><span class="sxs-lookup"><span data-stu-id="7e7a3-149">-or-</span></span> 
 <span data-ttu-id="7e7a3-150"><paramref name="initialCount" /> が 0 未満です。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-150"><paramref name="initialCount" /> is less than 0.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="7e7a3-151">マネージド スレッド処理</span><span class="sxs-lookup"><span data-stu-id="7e7a3-151">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md"><span data-ttu-id="7e7a3-152">Semaphore</span><span class="sxs-lookup"><span data-stu-id="7e7a3-152">Semaphore</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount, System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int * string -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount, name)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initialCount"><span data-ttu-id="7e7a3-153">同時に許可されるセマフォの要求の初期数。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-153">The initial number of requests for the semaphore that can be granted concurrently.</span></span></param>
        <param name="maximumCount"><span data-ttu-id="7e7a3-154">同時に許可されるセマフォの要求の最大数。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-154">The maximum number of requests for the semaphore that can be granted concurrently.</span></span></param>
        <param name="name"><span data-ttu-id="7e7a3-155">名前付きシステム セマフォ オブジェクトの名前。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-155">The name of a named system semaphore object.</span></span></param>
        <summary><span data-ttu-id="7e7a3-156">エントリ数の初期値と同時実行エントリの最大数を指定し、オプションでシステム セマフォ オブジェクトの名前を指定して、<see cref="T:System.Threading.Semaphore" /> クラスの新しいインスタンスを初期化します。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-156">Initializes a new instance of the <see cref="T:System.Threading.Semaphore" /> class, specifying the initial number of entries and the maximum number of concurrent entries, and optionally specifying the name of a system semaphore object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7e7a3-157">このコンス トラクターの初期化を<xref:System.Threading.Semaphore>名前付きシステム セマフォを表すオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-157">This constructor initializes a <xref:System.Threading.Semaphore> object that represents a named system semaphore.</span></span> <span data-ttu-id="7e7a3-158">複数作成できます<xref:System.Threading.Semaphore>名前付きシステム セマフォが同じを表すオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-158">You can create multiple <xref:System.Threading.Semaphore> objects that represent the same named system semaphore.</span></span>  
  
 <span data-ttu-id="7e7a3-159">名前付きシステム セマフォが存在しない場合、最初の数で指定された最大数と作成`initialCount`と`maximumCount`します。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-159">If the named system semaphore does not exist, it is created with the initial count and maximum count specified by `initialCount` and `maximumCount`.</span></span> <span data-ttu-id="7e7a3-160">名前付きシステム セマフォが既に存在する場合`initialCount`と`maximumCount`を使用しないが、無効な値では例外が発生します。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-160">If the named system semaphore already exists, `initialCount` and `maximumCount` are not used, although invalid values still cause exceptions.</span></span> <span data-ttu-id="7e7a3-161">かどうか、名前付きシステム セマフォが作成を決定する必要がある場合、使用、<xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.String%2CSystem.Boolean%40%29>コンス トラクター オーバー ロードを代用します。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-161">If you need to determine whether or not a named system semaphore was created, use the <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.String%2CSystem.Boolean%40%29> constructor overload instead.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="7e7a3-162">同じ番号を指定する、推奨される方法は、このコンス トラクター オーバー ロードを使用して、`initialCount`と`maximumCount`します。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-162">When you use this constructor overload, the recommended practice is to specify the same number for `initialCount` and `maximumCount`.</span></span> <span data-ttu-id="7e7a3-163">場合`initialCount`がより小さい`maximumCount`、し、名前付きシステム セマフォが作成された、現在のスレッドを呼び出した場合と同じ効果が<xref:System.Threading.WaitHandle.WaitOne%2A>(`maximumCount`マイナス`initialCount`) 時刻。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-163">If `initialCount` is less than `maximumCount`, and a named system semaphore is created, the effect is the same as if the current thread had called <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) times.</span></span> <span data-ttu-id="7e7a3-164">ただし、このコンス トラクター オーバー ロードではありません、名前付きシステム セマフォが作成されたかどうかを判断する方法です。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-164">However, with this constructor overload there is no way to determine whether a named system semaphore was created.</span></span>  
  
 <span data-ttu-id="7e7a3-165">指定した場合`null`または空の文字列の`name`、ローカル セマフォが作成されたことを呼び出した場合と、<xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29>コンス トラクター オーバー ロードします。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-165">If you specify `null` or an empty string for `name`, a local semaphore is created, as if you had called the <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> constructor overload.</span></span>  
  
 <span data-ttu-id="7e7a3-166">名前付きセマフォは、オペレーティング システム全体表示であるために、プロセス境界をまたいでリソースの使用を調整するため、使用できます。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-166">Because named semaphores are visible throughout the operating system, they can be used to coordinate resource use across process boundaries.</span></span>  
  
 <span data-ttu-id="7e7a3-167">名前付きシステム セマフォが存在するかどうかを確認、使用するかどうか、<xref:System.Threading.Semaphore.OpenExisting%2A>メソッド。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-167">If you want to find out whether a named system semaphore exists, use the <xref:System.Threading.Semaphore.OpenExisting%2A> method.</span></span> <span data-ttu-id="7e7a3-168"><xref:System.Threading.Semaphore.OpenExisting%2A>メソッドは、既存の名前付きセマフォを開こうとすると、システム セマフォが存在しない場合は、例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-168">The <xref:System.Threading.Semaphore.OpenExisting%2A> method attempts to open an existing named semaphore, and throws an exception if the system semaphore does not exist.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7e7a3-169">次のコード例では、名前付きセマフォのプロセス間の動作を示します。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-169">The following code example demonstrates the cross-process behavior of a named semaphore.</span></span> <span data-ttu-id="7e7a3-170">例は、最大数が 5 つ、最大 5 人の最初の数と名前付きセマフォを作成します。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-170">The example creates a named semaphore with a maximum count of five and an initial count of five.</span></span> <span data-ttu-id="7e7a3-171">プログラムは、次の 3 つの呼び出し、<xref:System.Threading.WaitHandle.WaitOne%2A>メソッド。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-171">The program makes three calls to the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="7e7a3-172">このため、2 つのコマンド ウィンドウからコンパイル済みの例を実行する場合、2 番目のコピーが 3 番目の呼び出しでブロックは<xref:System.Threading.WaitHandle.WaitOne%2A>します。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-172">Thus, if you run the compiled example from two command windows, the second copy will block on the third call to <xref:System.Threading.WaitHandle.WaitOne%2A>.</span></span> <span data-ttu-id="7e7a3-173">2 番目のブロックを解除するプログラムの最初のコピーで 1 つまたは複数のエントリを解放します。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-173">Release one or more entries in the first copy of the program to unblock the second.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7e7a3-174"><paramref name="initialCount" /> が <paramref name="maximumCount" /> より大きくなっています。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-174"><paramref name="initialCount" /> is greater than <paramref name="maximumCount" />.</span></span>  
  
<span data-ttu-id="7e7a3-175">または</span><span class="sxs-lookup"><span data-stu-id="7e7a3-175">-or-</span></span> 
 <span data-ttu-id="7e7a3-176"><paramref name="name" /> が 260 文字を超えています。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-176"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="7e7a3-177"><paramref name="maximumCount" /> が 1 未満です。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-177"><paramref name="maximumCount" /> is less than 1.</span></span>  
  
<span data-ttu-id="7e7a3-178">または</span><span class="sxs-lookup"><span data-stu-id="7e7a3-178">-or-</span></span> 
 <span data-ttu-id="7e7a3-179"><paramref name="initialCount" /> が 0 未満です。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-179"><paramref name="initialCount" /> is less than 0.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="7e7a3-180">Win32 エラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-180">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="7e7a3-181">アクセス制御セキュリティを使用した名前付きセマフォが存在しており、ユーザーに <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" /> がありません。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-181">The named semaphore exists and has access control security, and the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</span></span></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException"><span data-ttu-id="7e7a3-182">名前付きセマフォを作成できません。原因として、別の型の待機ハンドルに同じ名前が付けられていることが考えられます。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-182">The named semaphore cannot be created, perhaps because a wait handle of a different type has the same name.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="7e7a3-183">名前付きシステム セマフォを作成するアンマネージ コードを呼び出す。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-183">for calling unmanaged code to create a named system semaphore.</span></span> <span data-ttu-id="7e7a3-184"><see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> (関連する列挙体)</span><span class="sxs-lookup"><span data-stu-id="7e7a3-184">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span></span>  
  
<span data-ttu-id="7e7a3-185">セキュリティ アクション:<see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />します。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-185">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span></span></permission>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="7e7a3-186">マネージド スレッド処理</span><span class="sxs-lookup"><span data-stu-id="7e7a3-186">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md"><span data-ttu-id="7e7a3-187">Semaphore</span><span class="sxs-lookup"><span data-stu-id="7e7a3-187">Semaphore</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int * string *  -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount, name, createdNew)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initialCount"><span data-ttu-id="7e7a3-188">同時に満たされるセマフォの要求の初期数。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-188">The initial number of requests for the semaphore that can be satisfied concurrently.</span></span></param>
        <param name="maximumCount"><span data-ttu-id="7e7a3-189">同時に満たされるセマフォの要求の最大数。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-189">The maximum number of requests for the semaphore that can be satisfied concurrently.</span></span></param>
        <param name="name"><span data-ttu-id="7e7a3-190">名前付きシステム セマフォ オブジェクトの名前。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-190">The name of a named system semaphore object.</span></span></param>
        <param name="createdNew"><span data-ttu-id="7e7a3-191">このメソッドから制御が戻るときに、ローカル セマフォが作成された場合 (<paramref name="name" /> が <see langword="null" /> または空の文字列の場合)、または指定した名前付きシステム セマフォが作成された場合は <see langword="true" /> が格納されます。指定した名前付きシステム セマフォが既に存在する場合は <see langword="false" /> が格納されます。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-191">When this method returns, contains <see langword="true" /> if a local semaphore was created (that is, if <paramref name="name" /> is <see langword="null" /> or an empty string) or if the specified named system semaphore was created; <see langword="false" /> if the specified named system semaphore already existed.</span></span> <span data-ttu-id="7e7a3-192">このパラメーターは初期化せずに渡されます。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-192">This parameter is passed uninitialized.</span></span></param>
        <summary><span data-ttu-id="7e7a3-193">エントリ数の初期値と同時実行エントリの最大数を指定し、オプションでシステム セマフォ オブジェクトの名前を指定し、新しいシステム セマフォが作成されたかどうかを示す値を受け取る変数を指定して、<see cref="T:System.Threading.Semaphore" /> クラスの新しいインスタンスを初期化します。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-193">Initializes a new instance of the <see cref="T:System.Threading.Semaphore" /> class, specifying the initial number of entries and the maximum number of concurrent entries, optionally specifying the name of a system semaphore object, and specifying a variable that receives a value indicating whether a new system semaphore was created.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7e7a3-194">このコンス トラクターの初期化を<xref:System.Threading.Semaphore>名前付きシステム セマフォを表すオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-194">This constructor initializes a <xref:System.Threading.Semaphore> object that represents a named system semaphore.</span></span> <span data-ttu-id="7e7a3-195">複数作成できます<xref:System.Threading.Semaphore>名前付きシステム セマフォが同じを表すオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-195">You can create multiple <xref:System.Threading.Semaphore> objects that represent the same named system semaphore.</span></span>  
  
 <span data-ttu-id="7e7a3-196">名前付きシステム セマフォが存在しない場合、最初の数で指定された最大数と作成`initialCount`と`maximumCount`します。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-196">If the named system semaphore does not exist, it is created with the initial count and maximum count specified by `initialCount` and `maximumCount`.</span></span> <span data-ttu-id="7e7a3-197">名前付きシステム セマフォが既に存在する場合`initialCount`と`maximumCount`を使用しないが、無効な値では例外が発生します。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-197">If the named system semaphore already exists, `initialCount` and `maximumCount` are not used, although invalid values still cause exceptions.</span></span> <span data-ttu-id="7e7a3-198">使用`createdNew`システム セマフォが作成されたかどうかを判断します。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-198">Use `createdNew` to determine whether the system semaphore was created.</span></span>  
  
 <span data-ttu-id="7e7a3-199">場合`initialCount`がより小さい`maximumCount`、および`createdNew`は`true`、現在のスレッドを呼び出した場合と同じ効果が<xref:System.Threading.WaitHandle.WaitOne%2A>(`maximumCount`マイナス`initialCount`) 回。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-199">If `initialCount` is less than `maximumCount`, and `createdNew` is `true`, the effect is the same as if the current thread had called <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) times.</span></span>  
  
 <span data-ttu-id="7e7a3-200">指定した場合`null`または空の文字列の`name`、ローカル セマフォが作成されたことを呼び出した場合と、<xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29>コンス トラクター オーバー ロードします。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-200">If you specify `null` or an empty string for `name`, a local semaphore is created, as if you had called the <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> constructor overload.</span></span> <span data-ttu-id="7e7a3-201">この場合、`createdNew`は常に`true`します。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-201">In this case, `createdNew` is always `true`.</span></span>  
  
 <span data-ttu-id="7e7a3-202">名前付きセマフォは、オペレーティング システム全体表示であるために、プロセス境界をまたいでリソースの使用を調整するため、使用できます。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-202">Because named semaphores are visible throughout the operating system, they can be used to coordinate resource use across process boundaries.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7e7a3-203">次のコード例では、名前付きセマフォのプロセス間の動作を示します。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-203">The following code example demonstrates the cross-process behavior of a named semaphore.</span></span> <span data-ttu-id="7e7a3-204">例では、最大数が 5 つ、2 つの最初の数と名前付きセマフォを作成します。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-204">The example creates a named semaphore with a maximum count of five and an initial count of two.</span></span> <span data-ttu-id="7e7a3-205">つまり、コンス トラクターを呼び出すスレッドの 3 つのエントリを予約します。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-205">That is, it reserves three entries for the thread that calls the constructor.</span></span> <span data-ttu-id="7e7a3-206">場合`createNew`は`false`、プログラムは、次の 3 つの呼び出し、<xref:System.Threading.WaitHandle.WaitOne%2A>メソッド。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-206">If `createNew` is `false`, the program makes three calls to the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="7e7a3-207">このため、2 つのコマンド ウィンドウからコンパイル済みの例を実行する場合、2 番目のコピーが 3 番目の呼び出しでブロックは<xref:System.Threading.WaitHandle.WaitOne%2A>します。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-207">Thus, if you run the compiled example from two command windows, the second copy will block on the third call to <xref:System.Threading.WaitHandle.WaitOne%2A>.</span></span> <span data-ttu-id="7e7a3-208">2 番目のブロックを解除するプログラムの最初のコピーで 1 つまたは複数のエントリを解放します。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-208">Release one or more entries in the first copy of the program to unblock the second.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7e7a3-209"><paramref name="initialCount" /> が <paramref name="maximumCount" /> より大きくなっています。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-209"><paramref name="initialCount" /> is greater than <paramref name="maximumCount" />.</span></span>  
  
<span data-ttu-id="7e7a3-210">または</span><span class="sxs-lookup"><span data-stu-id="7e7a3-210">-or-</span></span> 
 <span data-ttu-id="7e7a3-211"><paramref name="name" /> が 260 文字を超えています。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-211"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="7e7a3-212"><paramref name="maximumCount" /> が 1 未満です。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-212"><paramref name="maximumCount" /> is less than 1.</span></span>  
  
<span data-ttu-id="7e7a3-213">または</span><span class="sxs-lookup"><span data-stu-id="7e7a3-213">-or-</span></span> 
 <span data-ttu-id="7e7a3-214"><paramref name="initialCount" /> が 0 未満です。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-214"><paramref name="initialCount" /> is less than 0.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="7e7a3-215">Win32 エラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-215">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="7e7a3-216">アクセス制御セキュリティを使用した名前付きセマフォが存在しており、ユーザーに <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" /> がありません。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-216">The named semaphore exists and has access control security, and the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</span></span></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException"><span data-ttu-id="7e7a3-217">名前付きセマフォを作成できません。原因として、別の型の待機ハンドルに同じ名前が付けられていることが考えられます。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-217">The named semaphore cannot be created, perhaps because a wait handle of a different type has the same name.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="7e7a3-218">名前付きシステム セマフォを作成するアンマネージ コードを呼び出す。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-218">for calling unmanaged code to create a named system semaphore.</span></span> <span data-ttu-id="7e7a3-219"><see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> (関連する列挙体)</span><span class="sxs-lookup"><span data-stu-id="7e7a3-219">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span></span>  
  
<span data-ttu-id="7e7a3-220">セキュリティ アクション:<see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />します。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-220">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span></span></permission>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="7e7a3-221">マネージド スレッド処理</span><span class="sxs-lookup"><span data-stu-id="7e7a3-221">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md"><span data-ttu-id="7e7a3-222">Semaphore</span><span class="sxs-lookup"><span data-stu-id="7e7a3-222">Semaphore</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name, out bool createdNew, System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::SemaphoreSecurity ^ semaphoreSecurity);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int * string *  * System.Security.AccessControl.SemaphoreSecurity -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount, name, createdNew, semaphoreSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="maximumCount" Type="System.Int32" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="name" Type="System.String" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="semaphoreSecurity" Type="System.Security.AccessControl.SemaphoreSecurity" Index="4" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="initialCount"><span data-ttu-id="7e7a3-223">同時に満たされるセマフォの要求の初期数。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-223">The initial number of requests for the semaphore that can be satisfied concurrently.</span></span></param>
        <param name="maximumCount"><span data-ttu-id="7e7a3-224">同時に満たされるセマフォの要求の最大数。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-224">The maximum number of requests for the semaphore that can be satisfied concurrently.</span></span></param>
        <param name="name"><span data-ttu-id="7e7a3-225">名前付きシステム セマフォ オブジェクトの名前。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-225">The name of a named system semaphore object.</span></span></param>
        <param name="createdNew"><span data-ttu-id="7e7a3-226">このメソッドから制御が戻るときに、ローカル セマフォが作成された場合 (<paramref name="name" /> が <see langword="null" /> または空の文字列の場合)、または指定した名前付きシステム セマフォが作成された場合は <see langword="true" /> が格納されます。指定した名前付きシステム セマフォが既に存在する場合は <see langword="false" /> が格納されます。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-226">When this method returns, contains <see langword="true" /> if a local semaphore was created (that is, if <paramref name="name" /> is <see langword="null" /> or an empty string) or if the specified named system semaphore was created; <see langword="false" /> if the specified named system semaphore already existed.</span></span> <span data-ttu-id="7e7a3-227">このパラメーターは初期化せずに渡されます。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-227">This parameter is passed uninitialized.</span></span></param>
        <param name="semaphoreSecurity"><span data-ttu-id="7e7a3-228">名前付きシステム セマフォに適用するアクセス制御セキュリティを表す <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-228">A <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> object that represents the access control security to be applied to the named system semaphore.</span></span></param>
        <summary><span data-ttu-id="7e7a3-229">エントリ数の初期値と同時実行エントリの最大数を指定し、オプションでシステム セマフォ オブジェクトの名前を指定し、新しいシステム セマフォが作成されたかどうかを示す値を受け取る変数を指定し、システム セマフォのセキュリティ アクセス制御を指定して、<see cref="T:System.Threading.Semaphore" /> クラスの新しいインスタンスを初期化します。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-229">Initializes a new instance of the <see cref="T:System.Threading.Semaphore" /> class, specifying the initial number of entries and the maximum number of concurrent entries, optionally specifying the name of a system semaphore object, specifying a variable that receives a value indicating whether a new system semaphore was created, and specifying security access control for the system semaphore.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7e7a3-230">このコンス トラクターを使用すると、作成時、他のコードがセマフォを乗っ取ることを防止、アクセス制御セキュリティを名前付きシステム セマフォに適用できます。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-230">Use this constructor to apply access control security to a named system semaphore when it is created, preventing other code from taking control of the semaphore.</span></span>  
  
 <span data-ttu-id="7e7a3-231">このコンス トラクターの初期化を<xref:System.Threading.Semaphore>名前付きシステム セマフォを表すオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-231">This constructor initializes a <xref:System.Threading.Semaphore> object that represents a named system semaphore.</span></span> <span data-ttu-id="7e7a3-232">複数作成できます<xref:System.Threading.Semaphore>名前付きシステム セマフォが同じを表すオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-232">You can create multiple <xref:System.Threading.Semaphore> objects that represent the same named system semaphore.</span></span>  
  
 <span data-ttu-id="7e7a3-233">名前付きシステム セマフォが存在しない場合は、指定したアクセス制御セキュリティで作成されます。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-233">If the named system semaphore does not exist, it is created with the specified access control security.</span></span> <span data-ttu-id="7e7a3-234">名前付きセマフォが存在する場合は、指定したアクセス制御セキュリティが無視されます。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-234">If the named semaphore exists, the specified access control security is ignored.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="7e7a3-235">呼び出し元が新しく作成された完全な制御<xref:System.Threading.Semaphore>オブジェクトいて`semaphoreSecurity`拒否するか、現在のユーザーへのいくつかのアクセス権の付与に失敗しました。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-235">The caller has full control over the newly created <xref:System.Threading.Semaphore> object even if `semaphoreSecurity` denies or fails to grant some access rights to the current user.</span></span> <span data-ttu-id="7e7a3-236">ただし場合は、現在のユーザーが別の取得を試みます<xref:System.Threading.Semaphore>オブジェクトを表す、同じ名前付きセマフォをいずれかを使用して、コンス トラクターまたは<xref:System.Threading.Semaphore.OpenExisting%2A>メソッドでは、Windows アクセス制御セキュリティを適用します。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-236">However, if the current user attempts to get another <xref:System.Threading.Semaphore> object to represent the same named semaphore, using either a constructor or the <xref:System.Threading.Semaphore.OpenExisting%2A> method, Windows access control security is applied.</span></span>  
  
 <span data-ttu-id="7e7a3-237">名前付きシステム セマフォが存在しない場合、最初の数で指定された最大数と作成`initialCount`と`maximumCount`します。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-237">If the named system semaphore does not exist, it is created with the initial count and maximum count specified by `initialCount` and `maximumCount`.</span></span> <span data-ttu-id="7e7a3-238">名前付きシステム セマフォが既に存在する場合`initialCount`と`maximumCount`を使用しないが、無効な値では例外が発生します。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-238">If the named system semaphore already exists, `initialCount` and `maximumCount` are not used, although invalid values still cause exceptions.</span></span> <span data-ttu-id="7e7a3-239">使用して、`createdNew`パラメーターをこのコンス トラクターによって、システム セマフォが作成されたかどうかを判断します。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-239">Use the `createdNew` parameter to determine whether the system semaphore was created by this constructor.</span></span>  
  
 <span data-ttu-id="7e7a3-240">場合`initialCount`がより小さい`maximumCount`、および`createdNew`は`true`、現在のスレッドを呼び出した場合と同じ効果が<xref:System.Threading.WaitHandle.WaitOne%2A>(`maximumCount`マイナス`initialCount`) 回。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-240">If `initialCount` is less than `maximumCount`, and `createdNew` is `true`, the effect is the same as if the current thread had called <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) times.</span></span>  
  
 <span data-ttu-id="7e7a3-241">指定した場合`null`または空の文字列の`name`、ローカル セマフォが作成されたことを呼び出した場合と、<xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29>コンス トラクター オーバー ロードします。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-241">If you specify `null` or an empty string for `name`, a local semaphore is created, as if you had called the <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> constructor overload.</span></span> <span data-ttu-id="7e7a3-242">この場合、`createdNew`は常に`true`します。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-242">In this case, `createdNew` is always `true`.</span></span>  
  
 <span data-ttu-id="7e7a3-243">名前付きセマフォは、オペレーティング システム全体表示であるために、プロセス境界をまたいでリソースの使用を調整するため、使用できます。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-243">Because named semaphores are visible throughout the operating system, they can be used to coordinate resource use across process boundaries.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7e7a3-244">次のコード例では、アクセス制御セキュリティを名前付きセマフォのプロセス間の動作を示します。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-244">The following code example demonstrates the cross-process behavior of a named semaphore with access control security.</span></span> <span data-ttu-id="7e7a3-245">この例では、<xref:System.Threading.Semaphore.OpenExisting%28System.String%29>名前付きセマフォの存在をテストするメソッドのオーバー ロードします。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-245">The example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload to test for the existence of a named semaphore.</span></span> <span data-ttu-id="7e7a3-246">セマフォが存在しない場合、2 つの最大数と、セマフォを使用する権利を現在のユーザーに拒否の読み取りし、セマフォのアクセス許可を変更する権限を付与するアクセス制御セキュリティが作成されます。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-246">If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore but grants the right to read and change permissions on the semaphore.</span></span> <span data-ttu-id="7e7a3-247">2 つのコマンド ウィンドウからコンパイル済みの例を実行する場合、2 番目のコピーへの呼び出しでアクセス違反例外がスローされます、<xref:System.Threading.Semaphore.OpenExisting%28System.String%29>メソッド。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-247">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method.</span></span> <span data-ttu-id="7e7a3-248">例外がキャッチされ、例では、<xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29>メソッドのオーバー ロードを読み取って、アクセス許可を変更するために必要な権限を持つ、セマフォを開きます。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-248">The exception is caught, and the example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> method overload to open the semaphore with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="7e7a3-249">アクセス許可が変更された後、セマフォは、入力し、解放に必要な権限で開かれます。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-249">After the permissions are changed, the semaphore is opened with the rights required to enter and release.</span></span> <span data-ttu-id="7e7a3-250">3 番目のコマンド ウィンドウからコンパイル済みの例を実行する場合は、新しいアクセス許可を使用してを実行します。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-250">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7e7a3-251"><paramref name="initialCount" /> が <paramref name="maximumCount" /> より大きくなっています。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-251"><paramref name="initialCount" /> is greater than <paramref name="maximumCount" />.</span></span>  
  
<span data-ttu-id="7e7a3-252">または</span><span class="sxs-lookup"><span data-stu-id="7e7a3-252">-or-</span></span> 
 <span data-ttu-id="7e7a3-253"><paramref name="name" /> が 260 文字を超えています。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-253"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="7e7a3-254"><paramref name="maximumCount" /> が 1 未満です。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-254"><paramref name="maximumCount" /> is less than 1.</span></span>  
  
<span data-ttu-id="7e7a3-255">または</span><span class="sxs-lookup"><span data-stu-id="7e7a3-255">-or-</span></span> 
 <span data-ttu-id="7e7a3-256"><paramref name="initialCount" /> が 0 未満です。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-256"><paramref name="initialCount" /> is less than 0.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="7e7a3-257">アクセス制御セキュリティを使用した名前付きセマフォが存在しており、ユーザーに <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" /> がありません。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-257">The named semaphore exists and has access control security, and the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="7e7a3-258">Win32 エラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-258">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException"><span data-ttu-id="7e7a3-259">名前付きセマフォを作成できません。原因として、別の型の待機ハンドルに同じ名前が付けられていることが考えられます。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-259">The named semaphore cannot be created, perhaps because a wait handle of a different type has the same name.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="7e7a3-260">名前付きシステム セマフォを作成するアンマネージ コードを呼び出す。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-260">for calling unmanaged code to create a named system semaphore.</span></span> <span data-ttu-id="7e7a3-261"><see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> (関連する列挙体)</span><span class="sxs-lookup"><span data-stu-id="7e7a3-261">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span></span> <span data-ttu-id="7e7a3-262">セキュリティ アクション:<see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />します。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-262">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span></span></permission>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="7e7a3-263">マネージド スレッド処理</span><span class="sxs-lookup"><span data-stu-id="7e7a3-263">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md"><span data-ttu-id="7e7a3-264">Semaphore</span><span class="sxs-lookup"><span data-stu-id="7e7a3-264">Semaphore</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.SemaphoreSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.SemaphoreSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As SemaphoreSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::SemaphoreSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.SemaphoreSecurity" Usage="semaphore.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.SemaphoreSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="7e7a3-265">名前付きシステム セマフォのアクセス制御セキュリティを取得します。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-265">Gets the access control security for a named system semaphore.</span></span></summary>
        <returns><span data-ttu-id="7e7a3-266">名前付きシステム セマフォのアクセス制御セキュリティを表す <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-266">A <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> object that represents the access control security for the named system semaphore.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7e7a3-267"><xref:System.Threading.Semaphore.GetAccessControl%2A>メソッドは次のフラグ (ビットごとの OR 演算を使用して結合) の組み合わせを使用してアクセス許可を検索する: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>、 <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>、および<xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>します。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-267">The <xref:System.Threading.Semaphore.GetAccessControl%2A> method uses the following combination of flags (combined using the bitwise OR operation) to search for permissions: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, and <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="7e7a3-268">ユーザーがいる必要があります<xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType>でこのメソッドでは、およびセマフォを呼び出す権限が開かれている必要があります<xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType>権限。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-268">The user must have <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType> rights to call this method, and the semaphore must have been opened with <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType> rights.</span></span>  
  
 <span data-ttu-id="7e7a3-269">ローカルのセマフォでアクセス制御セキュリティは関係ありません。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-269">On a local semaphore, access control security is irrelevant.</span></span> <span data-ttu-id="7e7a3-270">場合、<xref:System.Threading.Semaphore>オブジェクトは、名前付きシステム セマフォを表していません、このメソッドが戻る、<xref:System.Security.AccessControl.SemaphoreSecurity>任意のユーザーにすべての権限を付与するオブジェクトです。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-270">If the <xref:System.Threading.Semaphore> object does not represent a named system semaphore, this method returns a <xref:System.Security.AccessControl.SemaphoreSecurity> object that grants all rights to any user.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7e7a3-271">次のコード例では、アクセス制御セキュリティを名前付きセマフォのプロセス間の動作を示します。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-271">The following code example demonstrates the cross-process behavior of a named semaphore with access control security.</span></span> <span data-ttu-id="7e7a3-272">この例では、<xref:System.Threading.Semaphore.OpenExisting%28System.String%29>名前付きセマフォの存在をテストするメソッドのオーバー ロードします。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-272">The example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload to test for the existence of a named semaphore.</span></span>  
  
 <span data-ttu-id="7e7a3-273">セマフォが存在しない場合、2 つの最大数と、セマフォを使用する権利を現在のユーザーに拒否の読み取りし、セマフォのアクセス許可を変更する権限を付与するアクセス制御セキュリティが作成されます。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-273">If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore, but grants the right to read and change permissions on the semaphore.</span></span>  
  
 <span data-ttu-id="7e7a3-274">2 つのコマンド ウィンドウからコンパイル済みの例を実行する場合、2 番目のコピーへの呼び出しでアクセス違反例外がスローされます、<xref:System.Threading.Semaphore.OpenExisting%28System.String%29>メソッド。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-274">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method.</span></span> <span data-ttu-id="7e7a3-275">例外がキャッチされ、例では、<xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29>メソッドのオーバー ロードを読み取って、アクセス許可を変更するために必要な権限を持つ、セマフォを開きます。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-275">The exception is caught, and the example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> method overload to open the semaphore with the rights needed to read and change the permissions.</span></span> <span data-ttu-id="7e7a3-276">使用して、システム セマフォのアクセス制御セキュリティを取得、<xref:System.Threading.Semaphore.GetAccessControl%2A>メソッド。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-276">The access control security for the system semaphore is obtained using the <xref:System.Threading.Semaphore.GetAccessControl%2A> method.</span></span>  
  
 <span data-ttu-id="7e7a3-277">アクセス許可が変更された後、セマフォは、入力し、解放に必要な権限で開かれます。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-277">After the permissions are changed, the semaphore is opened with the rights required to enter and release.</span></span> <span data-ttu-id="7e7a3-278">3 番目のコマンド ウィンドウからコンパイル済みの例を実行する場合は、新しいアクセス許可を使用してを実行します。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-278">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="7e7a3-279">現在の <see cref="T:System.Threading.Semaphore" /> オブジェクトは名前付きシステム セマフォを表していますが、ユーザーに <see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" /> 権限がありません。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-279">The current <see cref="T:System.Threading.Semaphore" /> object represents a named system semaphore, and the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" /> rights.</span></span>  
  
<span data-ttu-id="7e7a3-280">または</span><span class="sxs-lookup"><span data-stu-id="7e7a3-280">-or-</span></span> 
<span data-ttu-id="7e7a3-281">現在の <see cref="T:System.Threading.Semaphore" /> オブジェクトは名前付きシステム セマフォを表しており、<see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" /> 権限で開かれませんでした。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-281">The current <see cref="T:System.Threading.Semaphore" /> object represents a named system semaphore and was not opened with <see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" /> rights.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="7e7a3-282">Windows 98 または Windows Millennium Edition はサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-282">Not supported for Windows 98 or Windows Millennium Edition.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="7e7a3-283">マネージド スレッド処理</span><span class="sxs-lookup"><span data-stu-id="7e7a3-283">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md"><span data-ttu-id="7e7a3-284">Semaphore</span><span class="sxs-lookup"><span data-stu-id="7e7a3-284">Semaphore</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7e7a3-285">既に存在する場合は、指定した名前付きセマフォを開きます。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-285">Opens a specified named semaphore, if it already exists.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Semaphore OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Semaphore OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As Semaphore" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Semaphore ^ OpenExisting(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string -&gt; System.Threading.Semaphore" Usage="System.Threading.Semaphore.OpenExisting name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Semaphore</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="7e7a3-286">開くシステム セマフォの名前。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-286">The name of the system semaphore to open.</span></span></param>
        <summary><span data-ttu-id="7e7a3-287">既に存在する場合は、指定した名前付きセマフォを開きます。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-287">Opens the specified named semaphore, if it already exists.</span></span></summary>
        <returns><span data-ttu-id="7e7a3-288">名前付きシステム セマフォを表すオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-288">An object that represents the named system semaphore.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7e7a3-289"><xref:System.Threading.Semaphore.OpenExisting%2A>メソッドが指定した名前付きセマフォを開こうとします。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-289">The <xref:System.Threading.Semaphore.OpenExisting%2A> method tries to open the specified named semaphore.</span></span> <span data-ttu-id="7e7a3-290">システム セマフォが存在しない場合、このメソッドは、システム セマフォを作成する代わりに、例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-290">If the system semaphore does not exist, this method throws an exception instead of creating the system semaphore.</span></span> <span data-ttu-id="7e7a3-291">既に存在しない場合にシステム セマフォを作成するには、いずれかを使用、<xref:System.Threading.Semaphore.%23ctor%2A>コンス トラクターを持つ、`name`パラメーター。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-291">To create the system semaphore when it does not already exist, use one of the <xref:System.Threading.Semaphore.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="7e7a3-292">このメソッドに同じ値を使用する複数の呼び出し`name`必ずしも返さない同じ<xref:System.Threading.Semaphore>場合でも、表現が返されるオブジェクトと同じ名前付きシステム セマフォ オブジェクトします。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-292">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Semaphore> object, even though the objects that are returned represent the same named system semaphore.</span></span>  
  
 <span data-ttu-id="7e7a3-293">このメソッドのオーバー ロードの呼び出しと同じですが、<xref:System.Threading.Semaphore.OpenExisting%2A>メソッドのオーバー ロードを指定して<xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType>と<xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType>権限、ビットごとの OR 演算を使用して結合します。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-293">This method overload is equivalent to calling the <xref:System.Threading.Semaphore.OpenExisting%2A> method overload and specifying <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> and <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> rights, combined by using the bitwise OR operation.</span></span>  
  
 <span data-ttu-id="7e7a3-294">指定する、<xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType>フラグによって、セマフォに入るためのスレッドを指定して、<xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType>フラグによって、スレッドを呼び出す、<xref:System.Threading.Semaphore.Release%2A>メソッド。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-294">Specifying the <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> flag allows a thread to enter the semaphore, and specifying the <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> flag allows a thread to call the <xref:System.Threading.Semaphore.Release%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7e7a3-295">次のコード例では、アクセス制御セキュリティを名前付きセマフォのプロセス間の動作を示します。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-295">The following code example demonstrates the cross-process behavior of a named semaphore with access control security.</span></span> <span data-ttu-id="7e7a3-296">この例では、<xref:System.Threading.Semaphore.OpenExisting%28System.String%29>名前付きセマフォの存在をテストするメソッドのオーバー ロードします。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-296">The example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload to test for the existence of a named semaphore.</span></span>  
  
 <span data-ttu-id="7e7a3-297">セマフォが存在しない場合、2 つの最大数と、セマフォを使用する権利が、現在のユーザーを拒否しますが、読み取りし、セマフォのアクセス許可を変更する権限を付与するアクセス制御のセキュリティが作成されます。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-297">If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore, but which grants the right to read and change permissions on the semaphore.</span></span>  
  
 <span data-ttu-id="7e7a3-298">2 つのコマンド ウィンドウからコンパイル済みの例を実行する場合、2 番目のコピーへの呼び出しでアクセス違反例外がスローされます、<xref:System.Threading.Semaphore.OpenExisting%28System.String%29>メソッドのオーバー ロードします。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-298">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload.</span></span> <span data-ttu-id="7e7a3-299">例外がキャッチされ、例では、<xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29>メソッドのオーバー ロードを読み取って、アクセス許可を変更するために必要な権限を持つ、セマフォを開きます。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-299">The exception is caught, and the example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> method overload to open the semaphore with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="7e7a3-300">アクセス許可が変更された後、セマフォを入力し、それを解放するために必要な権限で開きます。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-300">After the permissions are changed, the semaphore is opened with the rights required to enter and release it.</span></span> <span data-ttu-id="7e7a3-301">3 番目のコマンド ウィンドウからコンパイル済みの例を実行する場合は、新しいアクセス許可を使用してを実行します。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-301">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7e7a3-302"><paramref name="name" /> が空の文字列です。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-302"><paramref name="name" /> is an empty string.</span></span>  
  
<span data-ttu-id="7e7a3-303">または</span><span class="sxs-lookup"><span data-stu-id="7e7a3-303">-or-</span></span> 
 <span data-ttu-id="7e7a3-304"><paramref name="name" /> が 260 文字を超えています。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-304"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7e7a3-305"><paramref name="name" /> は <see langword="null" />です。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-305"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException"><span data-ttu-id="7e7a3-306">名前付きセマフォが存在しません。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-306">The named semaphore does not exist.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="7e7a3-307">Win32 エラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-307">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="7e7a3-308">名前付きセマフォは存在しますが、それを使用するために必要なセキュリティ アクセスがユーザーにありません。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-308">The named semaphore exists, but the user does not have the security access required to use it.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="7e7a3-309">名前付きシステム セマフォを開きをアンマネージ コードを呼び出す。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-309">for calling unmanaged code to open a named system semaphore.</span></span> <span data-ttu-id="7e7a3-310"><see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> (関連する列挙体)</span><span class="sxs-lookup"><span data-stu-id="7e7a3-310">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span></span>  
  
<span data-ttu-id="7e7a3-311">セキュリティ アクション:<see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />します。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-311">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span></span></permission>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="7e7a3-312">マネージド スレッド処理</span><span class="sxs-lookup"><span data-stu-id="7e7a3-312">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md"><span data-ttu-id="7e7a3-313">Semaphore</span><span class="sxs-lookup"><span data-stu-id="7e7a3-313">Semaphore</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Semaphore OpenExisting (string name, System.Security.AccessControl.SemaphoreRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Semaphore OpenExisting(string name, valuetype System.Security.AccessControl.SemaphoreRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As SemaphoreRights) As Semaphore" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Semaphore ^ OpenExisting(System::String ^ name, System::Security::AccessControl::SemaphoreRights rights);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.Security.AccessControl.SemaphoreRights -&gt; System.Threading.Semaphore" Usage="System.Threading.Semaphore.OpenExisting (name, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Semaphore</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rights" Type="System.Security.AccessControl.SemaphoreRights" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="7e7a3-314">開くシステム セマフォの名前。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-314">The name of the system semaphore to open.</span></span></param>
        <param name="rights"><span data-ttu-id="7e7a3-315">必要なセキュリティ アクセス権を表す列挙値のビットごとの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-315">A bitwise combination of the enumeration values that represent the desired security access.</span></span></param>
        <summary><span data-ttu-id="7e7a3-316">既に存在する場合は、必要なセキュリティ アクセスで指定した名前付きセマフォを開きます。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-316">Opens the specified named semaphore, if it already exists, with the desired security access.</span></span></summary>
        <returns><span data-ttu-id="7e7a3-317">名前付きシステム セマフォを表すオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-317">An object that represents the named system semaphore.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7e7a3-318">`rights`パラメーターを含める必要があります、 <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> 、セマフォに入るためのスレッドを許可するフラグ、<xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType>を呼び出すスレッドを許可するフラグ、<xref:System.Threading.Semaphore.Release%2A>メソッド。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-318">The `rights` parameter must include the <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> flag to allow threads to enter the semaphore, and the <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> flag to allow threads to call the <xref:System.Threading.Semaphore.Release%2A> method.</span></span>  
  
 <span data-ttu-id="7e7a3-319"><xref:System.Threading.Semaphore.OpenExisting%2A>メソッドが、既存の名前付きセマフォを開こうとします。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-319">The <xref:System.Threading.Semaphore.OpenExisting%2A> method tries to open an existing named semaphore.</span></span> <span data-ttu-id="7e7a3-320">システム セマフォが存在しない場合、このメソッドは、システム セマフォを作成する代わりに、例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-320">If the system semaphore does not exist, this method throws an exception instead of creating the system semaphore.</span></span> <span data-ttu-id="7e7a3-321">既に存在しない場合にシステム セマフォを作成するには、いずれかを使用、<xref:System.Threading.Semaphore.%23ctor%2A>コンス トラクターを持つ、`name`パラメーター。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-321">To create the system semaphore when it does not already exist, use one of the <xref:System.Threading.Semaphore.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="7e7a3-322">このメソッドに同じ値を使用する複数の呼び出し`name`必ずしも返さない同じ<xref:System.Threading.Semaphore>場合でも、表現が返されるオブジェクトと同じ名前付きシステム セマフォ オブジェクトします。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-322">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Semaphore> object, even though the objects that are returned represent the same named system semaphore.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7e7a3-323">次のコード例では、アクセス制御セキュリティを名前付きセマフォのプロセス間の動作を示します。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-323">The following code example demonstrates the cross-process behavior of a named semaphore with access control security.</span></span> <span data-ttu-id="7e7a3-324">この例では、<xref:System.Threading.Semaphore.OpenExisting%28System.String%29>名前付きセマフォの存在をテストするメソッドのオーバー ロードします。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-324">The example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload to test for the existence of a named semaphore.</span></span>  
  
 <span data-ttu-id="7e7a3-325">セマフォが存在しない場合、2 つの最大数と、セマフォを使用する権利を現在のユーザーに拒否の読み取りし、セマフォのアクセス許可を変更する権限を付与するアクセス制御セキュリティが作成されます。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-325">If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore, but grants the right to read and change permissions on the semaphore.</span></span>  
  
 <span data-ttu-id="7e7a3-326">2 つのコマンド ウィンドウからコンパイル済みの例を実行する場合、2 番目のコピーへの呼び出しでアクセス違反例外がスローされます、<xref:System.Threading.Semaphore.OpenExisting%28System.String%29>メソッド。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-326">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method.</span></span> <span data-ttu-id="7e7a3-327">例外がキャッチされ、例では、<xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29>メソッドのオーバー ロードを読み取って、アクセス許可を変更するために必要な権限を持つ、セマフォを開きます。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-327">The exception is caught, and the example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> method overload to open the semaphore with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="7e7a3-328">アクセス許可が変更された後、セマフォを入力し、それを解放するために必要な権限で開きます。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-328">After the permissions are changed, the semaphore is opened with the rights required to enter and release it.</span></span> <span data-ttu-id="7e7a3-329">3 番目のコマンド ウィンドウからコンパイル済みの例を実行する場合は、新しいアクセス許可を使用してを実行します。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-329">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7e7a3-330"><paramref name="name" /> が空の文字列です。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-330"><paramref name="name" /> is an empty string.</span></span>  
  
<span data-ttu-id="7e7a3-331">または</span><span class="sxs-lookup"><span data-stu-id="7e7a3-331">-or-</span></span> 
 <span data-ttu-id="7e7a3-332"><paramref name="name" /> が 260 文字を超えています。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-332"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7e7a3-333"><paramref name="name" /> は <see langword="null" />です。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-333"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException"><span data-ttu-id="7e7a3-334">名前付きセマフォが存在しません。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-334">The named semaphore does not exist.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="7e7a3-335">Win32 エラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-335">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="7e7a3-336">名前付きセマフォは存在しますが、必要なセキュリティ アクセス権がユーザーにありません。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-336">The named semaphore exists, but the user does not have the desired security access rights.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="7e7a3-337">名前付きシステム セマフォを作成するアンマネージ コードを呼び出す。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-337">for calling unmanaged code to create a named system semaphore.</span></span> <span data-ttu-id="7e7a3-338"><see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> (関連する列挙体)</span><span class="sxs-lookup"><span data-stu-id="7e7a3-338">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span></span>  
  
<span data-ttu-id="7e7a3-339">セキュリティ アクション:<see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />します。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-339">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span></span></permission>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="7e7a3-340">マネージド スレッド処理</span><span class="sxs-lookup"><span data-stu-id="7e7a3-340">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md"><span data-ttu-id="7e7a3-341">Semaphore</span><span class="sxs-lookup"><span data-stu-id="7e7a3-341">Semaphore</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Release">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7e7a3-342">セマフォから出ます。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-342">Exits the semaphore.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Release">
      <MemberSignature Language="C#" Value="public int Release ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Release() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.Release" />
      <MemberSignature Language="VB.NET" Value="Public Function Release () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Release();" />
      <MemberSignature Language="F#" Value="member this.Release : unit -&gt; int" Usage="semaphore.Release " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.PrePrepareMethod</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="7e7a3-343">セマフォから出て、前のカウントを返します。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-343">Exits the semaphore and returns the previous count.</span></span></summary>
        <returns><span data-ttu-id="7e7a3-344"><see cref="Overload:System.Threading.Semaphore.Release" /> メソッドが呼び出される前のセマフォのカウント。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-344">The count on the semaphore before the <see cref="Overload:System.Threading.Semaphore.Release" /> method was called.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7e7a3-345">スレッドを使用して、通常、<xref:System.Threading.WaitHandle.WaitOne%2A>セマフォ、およびそれらを通常入力する方法では、このメソッドのオーバー ロードを使用して、終了します。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-345">Threads typically use the <xref:System.Threading.WaitHandle.WaitOne%2A> method to enter the semaphore, and they typically use this method overload to exit.</span></span>  
  
 <span data-ttu-id="7e7a3-346">場合、<xref:System.Threading.SemaphoreFullException>によってスローされる、<xref:System.Threading.Semaphore.Release%2A>メソッドを呼び出し元のスレッドに問題が必ずしも可能性はありません。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-346">If a <xref:System.Threading.SemaphoreFullException> is thrown by the <xref:System.Threading.Semaphore.Release%2A> method, it does not necessarily indicate a problem with the calling thread.</span></span> <span data-ttu-id="7e7a3-347">別のスレッドでのプログラミング エラーによって、そのスレッドがセマフォに回よりも、入力した原因と考えです。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-347">A programming error in another thread might have caused that thread to exit the semaphore more times than it entered.</span></span>  
  
 <span data-ttu-id="7e7a3-348">場合、現在<xref:System.Threading.Semaphore>オブジェクトは、名前付きシステム セマフォを表す、ユーザーがいる必要があります<xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType>にする必要がありますに開かれた権限と、セマフォ<xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType>権限。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-348">If the current <xref:System.Threading.Semaphore> object represents a named system semaphore, the user must have <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> rights and the semaphore must have been opened with <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> rights.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7e7a3-349">次のコード例は、0 の最初の数の 3 つの最大数、およびセマフォを作成します。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-349">The following code example creates a semaphore with a maximum count of three and an initial count of zero.</span></span> <span data-ttu-id="7e7a3-350">例では、セマフォの待機をブロックする 5 つのスレッドを開始します。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-350">The example starts five threads, which block waiting for the semaphore.</span></span> <span data-ttu-id="7e7a3-351">メイン スレッドを使用して、<xref:System.Threading.Semaphore.Release%28System.Int32%29>メソッドのオーバー ロードは、次の 3 つのスレッドがセマフォに入るをできるように、最大容量にセマフォ カウントを増やします。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-351">The main thread uses the <xref:System.Threading.Semaphore.Release%28System.Int32%29> method overload to increase the semaphore count to its maximum, allowing three threads to enter the semaphore.</span></span> <span data-ttu-id="7e7a3-352">各スレッドを使用して、<xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>メソッドが、作業し、呼び出しをシミュレートするために、1 秒間待機する、<xref:System.Threading.Semaphore.Release>セマフォを解放するメソッドのオーバー ロードします。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-352">Each thread uses the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method to wait for one second, to simulate work, and then calls the <xref:System.Threading.Semaphore.Release> method overload to release the semaphore.</span></span>  
  
 <span data-ttu-id="7e7a3-353">セマフォがリリースされるたびに、前のセマフォのカウントが表示されます。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-353">Each time the semaphore is released, the previous semaphore count is displayed.</span></span> <span data-ttu-id="7e7a3-354">コンソール メッセージ追跡セマフォを使用します。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-354">Console messages track semaphore use.</span></span> <span data-ttu-id="7e7a3-355">各スレッドは、出力を読みやすくするために、シミュレートされた動作の間隔が若干増加します。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-355">The simulated work interval is increased slightly for each thread, to make the output easier to read.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SemaphoreFullException"><span data-ttu-id="7e7a3-356">セマフォのカウントは既に最大値です。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-356">The semaphore count is already at the maximum value.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="7e7a3-357">名前付きセマフォで Win32 エラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-357">A Win32 error occurred with a named semaphore.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="7e7a3-358">現在のセマフォは名前付きシステム セマフォを表していますが、ユーザーに <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /> がありません。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-358">The current semaphore represents a named system semaphore, but the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</span></span>  
  
<span data-ttu-id="7e7a3-359">または</span><span class="sxs-lookup"><span data-stu-id="7e7a3-359">-or-</span></span> 
<span data-ttu-id="7e7a3-360">現在のセマフォは名前付きシステム セマフォを表していますが、<see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /> で開かれませんでした。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-360">The current semaphore represents a named system semaphore, but it was not opened with <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="7e7a3-361">マネージド スレッド処理</span><span class="sxs-lookup"><span data-stu-id="7e7a3-361">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md"><span data-ttu-id="7e7a3-362">Semaphore</span><span class="sxs-lookup"><span data-stu-id="7e7a3-362">Semaphore</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Release">
      <MemberSignature Language="C#" Value="public int Release (int releaseCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Release(int32 releaseCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.Release(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Release (releaseCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Release(int releaseCount);" />
      <MemberSignature Language="F#" Value="member this.Release : int -&gt; int" Usage="semaphore.Release releaseCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="releaseCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="releaseCount"><span data-ttu-id="7e7a3-363">セマフォから出る回数。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-363">The number of times to exit the semaphore.</span></span></param>
        <summary><span data-ttu-id="7e7a3-364">指定した回数だけセマフォから出て、前のカウントを返します。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-364">Exits the semaphore a specified number of times and returns the previous count.</span></span></summary>
        <returns><span data-ttu-id="7e7a3-365"><see cref="Overload:System.Threading.Semaphore.Release" /> メソッドが呼び出される前のセマフォのカウント。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-365">The count on the semaphore before the <see cref="Overload:System.Threading.Semaphore.Release" /> method was called.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7e7a3-366">スレッドは、セマフォを複数回入力が、このメソッドのオーバー ロードでは、全体のセマフォのカウントを 1 回の呼び出しで復元するができます。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-366">If a thread has entered the semaphore multiple times, this method overload allows the entire semaphore count to be restored with one call.</span></span>  
  
 <span data-ttu-id="7e7a3-367">場合、<xref:System.Threading.SemaphoreFullException>によってスローされる、<xref:System.Threading.Semaphore.Release%2A>メソッドを呼び出し元のスレッドに問題が必ずしも可能性はありません。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-367">If a <xref:System.Threading.SemaphoreFullException> is thrown by the <xref:System.Threading.Semaphore.Release%2A> method, it does not necessarily indicate a problem with the calling thread.</span></span> <span data-ttu-id="7e7a3-368">別のスレッドでのプログラミング エラーによって、そのスレッドがセマフォに回よりも、入力した原因と考えです。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-368">A programming error in another thread might have caused that thread to exit the semaphore more times than it entered.</span></span>  
  
 <span data-ttu-id="7e7a3-369">場合、現在<xref:System.Threading.Semaphore>オブジェクトは、名前付きシステム セマフォを表す、ユーザーがいる必要があります<xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType>にする必要がありますに開かれた権限と、セマフォ<xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType>権限。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-369">If the current <xref:System.Threading.Semaphore> object represents a named system semaphore, the user must have <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> rights and the semaphore must have been opened with <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> rights.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7e7a3-370">次のコード例は、0 の最初の数の 3 つの最大数、およびセマフォを作成します。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-370">The following code example creates a semaphore with a maximum count of three and an initial count of zero.</span></span> <span data-ttu-id="7e7a3-371">例では、セマフォの待機をブロックする 5 つのスレッドを開始します。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-371">The example starts five threads, which block waiting for the semaphore.</span></span> <span data-ttu-id="7e7a3-372">メイン スレッドを使用して、<xref:System.Threading.Semaphore.Release%28System.Int32%29>メソッドのオーバー ロードは、次の 3 つのスレッドがセマフォに入るをできるように、最大容量にセマフォ カウントを増やします。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-372">The main thread uses the <xref:System.Threading.Semaphore.Release%28System.Int32%29> method overload to increase the semaphore count to its maximum, allowing three threads to enter the semaphore.</span></span> <span data-ttu-id="7e7a3-373">各スレッドを使用して、<xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>メソッドが、作業し、呼び出しをシミュレートするために、1 秒間待機する、<xref:System.Threading.Semaphore.Release>セマフォを解放するメソッドのオーバー ロードします。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-373">Each thread uses the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method to wait for one second, to simulate work, and then calls the <xref:System.Threading.Semaphore.Release> method overload to release the semaphore.</span></span>  
  
 <span data-ttu-id="7e7a3-374">セマフォがリリースされるたびに、前のセマフォのカウントが表示されます。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-374">Each time the semaphore is released, the previous semaphore count is displayed.</span></span> <span data-ttu-id="7e7a3-375">コンソール メッセージ追跡セマフォを使用します。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-375">Console messages track semaphore use.</span></span> <span data-ttu-id="7e7a3-376">各スレッドは、出力を読みやすくするために、シミュレートされた動作の間隔が若干増加します。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-376">The simulated work interval is increased slightly for each thread, to make the output easier to read.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="7e7a3-377"><paramref name="releaseCount" /> が 1 未満です。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-377"><paramref name="releaseCount" /> is less than 1.</span></span></exception>
        <exception cref="T:System.Threading.SemaphoreFullException"><span data-ttu-id="7e7a3-378">セマフォのカウントは既に最大値です。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-378">The semaphore count is already at the maximum value.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="7e7a3-379">名前付きセマフォで Win32 エラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-379">A Win32 error occurred with a named semaphore.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="7e7a3-380">現在のセマフォは名前付きシステム セマフォを表していますが、ユーザーに <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /> 権限がありません。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-380">The current semaphore represents a named system semaphore, but the user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /> rights.</span></span>  
  
<span data-ttu-id="7e7a3-381">または</span><span class="sxs-lookup"><span data-stu-id="7e7a3-381">-or-</span></span> 
<span data-ttu-id="7e7a3-382">現在のセマフォは名前付きシステム セマフォを表していますが、<see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /> 権限で開かれませんでした。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-382">The current semaphore represents a named system semaphore, but it was not opened with <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /> rights.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="7e7a3-383">マネージド スレッド処理</span><span class="sxs-lookup"><span data-stu-id="7e7a3-383">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md"><span data-ttu-id="7e7a3-384">Semaphore</span><span class="sxs-lookup"><span data-stu-id="7e7a3-384">Semaphore</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::SemaphoreSecurity ^ semaphoreSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.SemaphoreSecurity -&gt; unit" Usage="semaphore.SetAccessControl semaphoreSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semaphoreSecurity" Type="System.Security.AccessControl.SemaphoreSecurity" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="semaphoreSecurity"><span data-ttu-id="7e7a3-385">名前付きシステム セマフォに適用するアクセス制御セキュリティを表す <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-385">A <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> object that represents the access control security to be applied to the named system semaphore.</span></span></param>
        <summary><span data-ttu-id="7e7a3-386">名前付きシステム セマフォのアクセス制御セキュリティを設定します。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-386">Sets the access control security for a named system semaphore.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7e7a3-387">のみアクセス制御セキュリティを設定する<xref:System.Threading.Semaphore>名前付きシステム セマフォを表すオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-387">You can set access control security only on <xref:System.Threading.Semaphore> objects that represent named system semaphores.</span></span>  
  
 <span data-ttu-id="7e7a3-388">ユーザーがいる必要があります<xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType>でこのメソッドでは、およびセマフォを呼び出す権限が開かれている必要があります<xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType>権限。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-388">The user must have <xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType> rights to call this method, and the semaphore must have been opened with <xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType> rights.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7e7a3-389">次のコード例では、アクセス制御セキュリティを名前付きセマフォのプロセス間の動作を示します。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-389">The following code example demonstrates the cross-process behavior of a named semaphore with access control security.</span></span> <span data-ttu-id="7e7a3-390">この例では、<xref:System.Threading.Semaphore.OpenExisting%28System.String%29>名前付きセマフォの存在をテストするメソッドのオーバー ロードします。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-390">The example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload to test for the existence of a named semaphore.</span></span>  
  
 <span data-ttu-id="7e7a3-391">セマフォが存在しない場合、2 つの最大数と、セマフォを使用する権利を現在のユーザーに拒否の読み取りし、セマフォのアクセス許可を変更する権限を付与するアクセス制御セキュリティが作成されます。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-391">If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore but grants the right to read and change permissions on the semaphore.</span></span>  
  
 <span data-ttu-id="7e7a3-392">2 つのコマンド ウィンドウからコンパイル済みの例を実行する場合、2 番目のコピーへの呼び出しでアクセス違反例外がスローされます、<xref:System.Threading.Semaphore.OpenExisting%28System.String%29>メソッド。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-392">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method.</span></span> <span data-ttu-id="7e7a3-393">例外がキャッチされ、例では、<xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29>メソッドのオーバー ロードを読み取って、アクセス許可を変更するために必要な権限を持つ、セマフォを開きます。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-393">The exception is caught, and the example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> method overload to open the semaphore with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="7e7a3-394">使用して、アクセス許可が変更した後、<xref:System.Threading.Semaphore.SetAccessControl%2A>セマフォ、メソッドは入力し、解放に必要な権限によって開かれます。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-394">After the permissions are changed, using the <xref:System.Threading.Semaphore.SetAccessControl%2A> method, the semaphore is opened with the rights required to enter and release.</span></span> <span data-ttu-id="7e7a3-395">3 番目のコマンド ウィンドウからコンパイル済みの例を実行する場合は、新しいアクセス許可を使用してを実行します。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-395">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7e7a3-396"><paramref name="semaphoreSecurity" /> は <see langword="null" />です。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-396"><paramref name="semaphoreSecurity" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="7e7a3-397">ユーザーに <see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" /> 権限がありません。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-397">The user does not have <see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" /> rights.</span></span>  
  
<span data-ttu-id="7e7a3-398">または</span><span class="sxs-lookup"><span data-stu-id="7e7a3-398">-or-</span></span> 
<span data-ttu-id="7e7a3-399">セマフォは <see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" /> 権限で開かれませんでした。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-399">The semaphore was not opened with <see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" /> rights.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="7e7a3-400">現在の <see cref="T:System.Threading.Semaphore" /> オブジェクトは名前付きシステム セマフォを表していません。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-400">The current <see cref="T:System.Threading.Semaphore" /> object does not represent a named system semaphore.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="7e7a3-401">マネージド スレッド処理</span><span class="sxs-lookup"><span data-stu-id="7e7a3-401">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md"><span data-ttu-id="7e7a3-402">Semaphore</span><span class="sxs-lookup"><span data-stu-id="7e7a3-402">Semaphore</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="7e7a3-403">既に存在する場合は、指定した名前付きセマフォを開き操作が成功したかどうかを示す値を返します。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-403">Opens a specified named semaphore, if it already exists, and returns a value that indicates whether the operation succeeded.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.Semaphore result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.Semaphore&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As Semaphore) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::Semaphore ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string *  -&gt; bool" Usage="System.Threading.Semaphore.TryOpenExisting (name, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Threading.Semaphore" RefType="out" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="7e7a3-404">開くシステム セマフォの名前。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-404">The name of the system semaphore to open.</span></span></param>
        <param name="result"><span data-ttu-id="7e7a3-405">このメソッドから制御が戻るときに、呼び出しに成功した場合は名前付きセマフォを表す <see cref="T:System.Threading.Semaphore" /> オブジェクトが格納されます。呼び出しに失敗した場合は <see langword="null" /> が格納されます。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-405">When this method returns, contains a <see cref="T:System.Threading.Semaphore" /> object that represents the named semaphore if the call succeeded, or <see langword="null" /> if the call failed.</span></span> <span data-ttu-id="7e7a3-406">このパラメーターは初期化前として処理されます。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-406">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="7e7a3-407">既に存在する場合は、指定した名前付きセマフォを開き操作が成功したかどうかを示す値を返します。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-407">Opens the specified named semaphore, if it already exists, and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="7e7a3-408">名前付きのセマフォが正常に開かれた場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-408"><see langword="true" /> if the named semaphore was opened successfully; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7e7a3-409">名前付きセマフォが存在しない場合このメソッドはいない作成しません。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-409">If the named semaphore does not exist, this method does not create it.</span></span> <span data-ttu-id="7e7a3-410">既に存在しない場合にシステム セマフォを作成するには、いずれかを使用、<xref:System.Threading.Semaphore.%23ctor%2A>コンス トラクターを持つ、`name`パラメーター。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-410">To create the system semaphore when it does not already exist, use one of the <xref:System.Threading.Semaphore.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="7e7a3-411">名前付きセマフォが存在するかどうかが不明な場合は、代わりにこのメソッドのオーバー ロードを使用して、<xref:System.Threading.Semaphore.OpenExisting%28System.String%29>メソッド オーバー ロードで、セマフォが存在しない場合は、例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-411">If you are uncertain whether a named semaphore exists, use this method overload instead of the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload, which throws an exception if the semaphore does not exist.</span></span>  
  
 <span data-ttu-id="7e7a3-412">このメソッドのオーバー ロードの呼び出しと同じですが、<xref:System.Threading.Semaphore.TryOpenExisting%2A>メソッドのオーバー ロードを指定して<xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType>と<xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType>権限、ビットごとの OR 演算を使用して結合します。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-412">This method overload is equivalent to calling the <xref:System.Threading.Semaphore.TryOpenExisting%2A> method overload and specifying <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> and <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> rights, combined by using the bitwise OR operation.</span></span> <span data-ttu-id="7e7a3-413">指定する、<xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType>フラグによって、セマフォに入るためのスレッドを指定して、<xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType>フラグによって、スレッドを呼び出す、<xref:System.Threading.Semaphore.Release%2A>メソッド。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-413">Specifying the <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> flag allows a thread to enter the semaphore, and specifying the   <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> flag allows a thread to call the <xref:System.Threading.Semaphore.Release%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7e7a3-414"><paramref name="name" /> が空の文字列です。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-414"><paramref name="name" /> is an empty string.</span></span>  
  
<span data-ttu-id="7e7a3-415">または</span><span class="sxs-lookup"><span data-stu-id="7e7a3-415">-or-</span></span> 
 <span data-ttu-id="7e7a3-416"><paramref name="name" /> が 260 文字を超えています。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-416"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7e7a3-417"><paramref name="name" /> は <see langword="null" />です。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-417"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="7e7a3-418">Win32 エラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-418">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="7e7a3-419">名前付きセマフォは存在しますが、それを使用するために必要なセキュリティ アクセスがユーザーにありません。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-419">The named semaphore exists, but the user does not have the security access required to use it.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.SemaphoreRights rights, out System.Threading.Semaphore result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.SemaphoreRights rights, [out] class System.Threading.Semaphore&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As SemaphoreRights, ByRef result As Semaphore) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::SemaphoreRights rights, [Runtime::InteropServices::Out] System::Threading::Semaphore ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * System.Security.AccessControl.SemaphoreRights *  -&gt; bool" Usage="System.Threading.Semaphore.TryOpenExisting (name, rights, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rights" Type="System.Security.AccessControl.SemaphoreRights" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Threading.Semaphore" RefType="out" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="7e7a3-420">開くシステム セマフォの名前。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-420">The name of the system semaphore to open.</span></span></param>
        <param name="rights"><span data-ttu-id="7e7a3-421">必要なセキュリティ アクセス権を表す列挙値のビットごとの組み合わせ。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-421">A bitwise combination of the enumeration values that represent the desired security access.</span></span></param>
        <param name="result"><span data-ttu-id="7e7a3-422">このメソッドから制御が戻るときに、呼び出しに成功した場合は名前付きセマフォを表す <see cref="T:System.Threading.Semaphore" /> オブジェクトが格納されます。呼び出しに失敗した場合は <see langword="null" /> が格納されます。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-422">When this method returns, contains a <see cref="T:System.Threading.Semaphore" /> object that represents the named semaphore if the call succeeded, or <see langword="null" /> if the call failed.</span></span> <span data-ttu-id="7e7a3-423">このパラメーターは初期化前として処理されます。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-423">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="7e7a3-424">既に存在する場合は、必要なセキュリティ アクセスを使って指定した名前付きセマフォを開き、操作が成功したかどうかを示す値を返します。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-424">Opens the specified named semaphore, if it already exists, with the desired security access, and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="7e7a3-425">名前付きのセマフォが正常に開かれた場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-425"><see langword="true" /> if the named semaphore was opened successfully; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7e7a3-426">名前付きセマフォが存在しない場合このメソッドはいない作成しません。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-426">If the named semaphore does not exist, this method does not create it.</span></span> <span data-ttu-id="7e7a3-427">既に存在しない場合にシステム セマフォを作成するには、いずれかを使用、<xref:System.Threading.Semaphore.%23ctor%2A>コンス トラクターを持つ、`name`パラメーター。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-427">To create the system semaphore when it does not already exist, use one of the <xref:System.Threading.Semaphore.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="7e7a3-428">名前付きセマフォが存在するかどうかが不明な場合は、代わりにこのメソッドのオーバー ロードを使用して、<xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29>メソッド オーバー ロードで、セマフォが存在しない場合は、例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-428">If you are uncertain whether a named semaphore exists, use this method overload instead of the <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> method overload, which throws an exception if the semaphore does not exist.</span></span>  
  
 <span data-ttu-id="7e7a3-429">`rights`パラメーターを含める必要があります、 <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> 、セマフォに入るためのスレッドを許可するフラグ、<xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType>を呼び出すスレッドを許可するフラグ、<xref:System.Threading.Semaphore.Release%2A>メソッド。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-429">The `rights` parameter must include the <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> flag to allow threads to enter the semaphore, and the <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> flag to allow threads to call the <xref:System.Threading.Semaphore.Release%2A> method.</span></span>  
  
 <span data-ttu-id="7e7a3-430">このメソッドに同じ値を使用する複数の呼び出し`name`必ずしも返さない同じ<xref:System.Threading.Semaphore>場合でも、表現が返されるオブジェクトと同じ名前付きシステム セマフォ オブジェクトします。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-430">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Semaphore> object, even though the objects that are returned represent the same named system semaphore.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="7e7a3-431"><paramref name="name" /> が空の文字列です。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-431"><paramref name="name" /> is an empty string.</span></span>  
  
<span data-ttu-id="7e7a3-432">または</span><span class="sxs-lookup"><span data-stu-id="7e7a3-432">-or-</span></span> 
 <span data-ttu-id="7e7a3-433"><paramref name="name" /> が 260 文字を超えています。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-433"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="7e7a3-434"><paramref name="name" /> は <see langword="null" />です。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-434"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="7e7a3-435">Win32 エラーが発生しました。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-435">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="7e7a3-436">名前付きセマフォは存在しますが、それを使用するために必要なセキュリティ アクセスがユーザーにありません。</span><span class="sxs-lookup"><span data-stu-id="7e7a3-436">The named semaphore exists, but the user does not have the security access required to use it.</span></span></exception>
      </Docs>
    </Member>
  </Members>
</Type>