<Type Name="AppDomain" FullName="System.AppDomain">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="81d3a8e6f1125a524e6327e997dd7eec6ba5840d" />
    <Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ja-JP" />
    <Meta Name="ms.lasthandoff" Value="11/17/2018" />
    <Meta Name="ms.locfileid" Value="51932506" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class AppDomain : MarshalByRefObject, _AppDomain, System.Security.IEvidenceFactory" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit AppDomain extends System.MarshalByRefObject implements class System._AppDomain, class System.Security.IEvidenceFactory" />
  <TypeSignature Language="DocId" Value="T:System.AppDomain" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class AppDomain&#xA;Inherits MarshalByRefObject&#xA;Implements _AppDomain, IEvidenceFactory" />
  <TypeSignature Language="C++ CLI" Value="public ref class AppDomain sealed : MarshalByRefObject, _AppDomain, System::Security::IEvidenceFactory" />
  <TypeSignature Language="F#" Value="type AppDomain = class&#xA;    inherit MarshalByRefObject&#xA;    interface _AppDomain&#xA;    interface IEvidenceFactory" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System._AppDomain</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.IEvidenceFactory</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System._AppDomain))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>アプリケーション ドメインを表します。アプリケーション ドメインとは、アプリケーションが実行される分離された環境です。 このクラスは継承できません。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 によって表されるアプリケーション ドメイン<xref:System.AppDomain>オブジェクト、ヘルプ、マネージ コードの実行の分離性、アンロード、およびセキュリティの境界を提供します。  
  
-   アプリケーション ドメインを使用すると、プロセスを引き起こす可能性のあるタスクを分離できます。 場合の状態、<xref:System.AppDomain>タスクを実行しているが、不安定になります、<xref:System.AppDomain>プロセス与えずアンロードできます。 再起動しなくても、プロセスが長時間にわたって実行する必要がありますこれは重要です。 データを共有しないようにタスクを分離するのにアプリケーション ドメインを使用することもできます。  
  
-   アセンブリが既定のアプリケーション ドメインに読み込まれている場合は、ことはできませんメモリからアンロード、プロセスの実行中にします。 ただし、読み込み、アセンブリを実行する 2 つ目のアプリケーション ドメインを開いた場合、アセンブリが読み込まれないそのアプリケーション ドメインが読み込まれるとします。 場合によっては大きな Dll を使用する実行時間の長いプロセスのワーキング セットを最小限に抑えるには、この手法を使用します。  
  
 複数のアプリケーション ドメインが 1 つのプロセスで実行できます。ただし、アプリケーション ドメインとスレッド間の一対一の相関関係はありません。 複数のスレッドが 1 つのアプリケーション ドメインに属することができ、スレッドが 1 つのアプリケーション ドメインで実行中に、特定のスレッドが、特定の時点を 1 つのアプリケーション ドメインに限定されていません。  
  
 使用してアプリケーション ドメインが作成された、<xref:System.AppDomain.CreateDomain%2A>メソッド。 <xref:System.AppDomain> インスタンスが読み込まれ、アセンブリを実行するために使用 (<xref:System.Reflection.Assembly>)。 ときに、<xref:System.AppDomain>が不要になった使用中で、アンロードできます。  
  
 <xref:System.AppDomain>クラスは、アプリケーション ドメインが、アンロードされるときに、アセンブリが読み込まれるときに、または未処理の例外がスローされたときに応答するアプリケーションを有効にするイベントのセットを実装します。  
  
 アプリケーション ドメインの使用の詳細については、次を参照してください。[アプリケーション ドメイン](~/docs/framework/app-domains/application-domains.md)します。  
  
 このクラスは、実装、 <xref:System.MarshalByRefObject>、 <xref:System._AppDomain>、および<xref:System.Security.IEvidenceFactory>インターフェイス。  
  
 リモート処理可能なラッパーを作成する必要がありますしない、<xref:System.AppDomain>オブジェクト。 リモート参照を公開そうでした<xref:System.AppDomain>などのメソッドを公開する<xref:System.AppDomain.CreateInstance%2A>リモート アクセスを効果的にコード アクセス セキュリティを破棄して<xref:System.AppDomain>します。 悪意のあるクライアントが、リモートに接続する<xref:System.AppDomain>任意のリソースへのアクセスを取得する可能性があります、<xref:System.AppDomain>自体へのアクセスに含まれています。 拡張する型のリモート処理可能なラッパーを作成しない<xref:System.MarshalByRefObject>セキュリティ システムをバイパスする悪意のあるクライアントで使用できるメソッドを実装するとします。  
  
> [!CAUTION]
>  既定値、<xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=nameWithType>プロパティは`false`します。 この設定は、サービスの安全ではありません。 サービスを防ぐため、部分的に信頼されたコードをダウンロードしてから、このプロパティを設定`true`します。  
  
   
  
## Examples  
 この例は、新たに作成する方法を示しています。 <xref:System.AppDomain>、を内の型の新しいインスタンスを作成<xref:System.AppDomain>、し、その型のオブジェクトと通信します。 さらに、この例はアンロードする方法を示しています。、<xref:System.AppDomain>原因でガベージ コレクション オブジェクト。  
  
 [!code-cpp[AppDomainX#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomainX/cpp/AppDomainX.cpp#1)]
 [!code-csharp[AppDomainX#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomainX/cs/AppDomainX.cs#1)]
 [!code-vb[AppDomainX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomainX/VB/AppDomainX.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/07ea8438-7a34-49f0-a7e8-3d6ff7e4a482">アプリケーション ドメインを構成する方法</related>
    <related type="Article" href="https://msdn.microsoft.com/library/ba1fa43e-49f5-47d9-bd7f-3024af16f4ba">アプリケーション ドメインを作成する方法</related>
    <related type="Article" href="https://msdn.microsoft.com/library/1432aa2d-bd83-4346-bf3b-a1b7920e2aa9">方法 : アプリケーション ドメインにアセンブリを読み込む</related>
    <related type="Article" href="https://msdn.microsoft.com/library/f356116d-e415-4f7c-a332-6e6a60227192">方法 : アプリケーション ドメインをアンロードする</related>
  </Docs>
  <Members>
    <Member MemberName="ActivationContext">
      <MemberSignature Language="C#" Value="public ActivationContext ActivationContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ActivationContext ActivationContext" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ActivationContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ActivationContext As ActivationContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property ActivationContext ^ ActivationContext { ActivationContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ActivationContext : ActivationContext" Usage="System.AppDomain.ActivationContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ActivationContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のアプリケーション ドメインのアクティベーション コンテキストを取得します。</summary>
        <value>現在のアプリケーション ドメインのアクティベーション コンテキストを表すオブジェクト。ドメインにアクティベーション コンテキストが存在しない場合は <see langword="null" />。</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="AppendPrivatePath">
      <MemberSignature Language="C#" Value="public void AppendPrivatePath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AppendPrivatePath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.AppendPrivatePath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendPrivatePath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AppendPrivatePath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="abstract member AppendPrivatePath : string -&gt; unit&#xA;override this.AppendPrivatePath : string -&gt; unit" Usage="appDomain.AppendPrivatePath path" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.AppendPrivatePath(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("AppDomain.AppendPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Obsolete("AppDomain.AppendPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">プライベート パスに追加するディレクトリ名。</param>
        <summary>指定されたディレクトリ名をプライベート パス リストに追加します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティの使用は推奨されませんが既に読み込まれている後にアセンブリのプローブのパスが変わる可能性があります。 代わりに、<xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType> プロパティを使用してください。  
  
 プライベートのパスまたは相対検索パスには、アセンブリ リゾルバーがプライベート アセンブリをプローブするベース ディレクトリに対する相対パスです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作が試行されています。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="ApplicationIdentity">
      <MemberSignature Language="C#" Value="public ApplicationIdentity ApplicationIdentity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ApplicationIdentity ApplicationIdentity" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ApplicationIdentity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ApplicationIdentity As ApplicationIdentity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property ApplicationIdentity ^ ApplicationIdentity { ApplicationIdentity ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationIdentity : ApplicationIdentity" Usage="System.AppDomain.ApplicationIdentity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ApplicationIdentity</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーション ドメイン内のアプリケーションの ID を取得します。</summary>
        <value>アプリケーション ドメイン内のアプリケーションを識別するオブジェクト。</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="ApplicationTrust">
      <MemberSignature Language="C#" Value="public System.Security.Policy.ApplicationTrust ApplicationTrust { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.ApplicationTrust ApplicationTrust" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ApplicationTrust" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ApplicationTrust As ApplicationTrust" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Policy::ApplicationTrust ^ ApplicationTrust { System::Security::Policy::ApplicationTrust ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationTrust : System.Security.Policy.ApplicationTrust" Usage="System.AppDomain.ApplicationTrust" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Policy.ApplicationTrust</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションに付与されているアクセス許可の情報を取得し、実行に必要な信頼レベルがそのアプリケーションにあるかどうかを調べます。</summary>
        <value>アプリケーション ドメインにおけるアプリケーションのアクセス許可および信頼情報をカプセル化するオブジェクト。</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="ApplyPolicy">
      <MemberSignature Language="C#" Value="public string ApplyPolicy (string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ApplyPolicy(string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ApplyPolicy(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ApplyPolicy (assemblyName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ApplyPolicy(System::String ^ assemblyName);" />
      <MemberSignature Language="F#" Value="member this.ApplyPolicy : string -&gt; string" Usage="appDomain.ApplyPolicy assemblyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">アセンブリの表示名。<see cref="P:System.Reflection.Assembly.FullName" /> プロパティによって返される表示名と同じ形式で指定します。</param>
        <summary>ポリシーが適用された後のアセンブリの表示名を返します。</summary>
        <returns>ポリシーが適用された後のアセンブリの表示名を保持する文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomain.ApplyPolicy%2A>メソッドは、アセンブリの表示名とポリシー適用後の表示名を返します。 これは、リフレクションのみのコンテキストでポリシーが適用されないため、ポリシーを使用してアセンブリを読み込む必要がある場合に便利です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyLoad">
      <MemberSignature Language="C#" Value="public event AssemblyLoadEventHandler AssemblyLoad;" />
      <MemberSignature Language="ILAsm" Value=".event class System.AssemblyLoadEventHandler AssemblyLoad" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.AssemblyLoad" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AssemblyLoad As AssemblyLoadEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event AssemblyLoadEventHandler ^ AssemblyLoad;" />
      <MemberSignature Language="F#" Value="member this.AssemblyLoad : AssemblyLoadEventHandler " Usage="member this.AssemblyLoad : System.AssemblyLoadEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.AssemblyLoad</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AssemblyLoadEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アセンブリが読み込まれたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AssemblyLoadEventHandler>デリゲートに対して、このイベントは、どのようなアセンブリが読み込まれたことを示します。  
  
 このイベントのイベント ハンドラーを登録するには、必要なアクセス許可が必要または<xref:System.Security.SecurityException>がスローされます。  
  
 イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。  
  
   
  
## Examples  
 次のサンプルでは、<xref:System.AppDomain.AssemblyLoad>イベント。  
  
 このコード例を実行するには、完全修飾アセンブリ名を指定する必要があります。 完全修飾アセンブリ名を取得する方法については、次を参照してください。[アセンブリ名](~/docs/framework/app-domains/assembly-names.md)します。  
  
 [!code-cpp[AppDomain_AssemblyLoad#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_AssemblyLoad/CPP/assemblyload.cpp#1)]
 [!code-csharp[AppDomain_AssemblyLoad#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_AssemblyLoad/CS/assemblyload.cs#1)]
 [!code-vb[AppDomain_AssemblyLoad#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_AssemblyLoad/VB/assemblyload.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="AssemblyResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler AssemblyResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler AssemblyResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.AssemblyResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AssemblyResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event ResolveEventHandler ^ AssemblyResolve;" />
      <MemberSignature Language="F#" Value="member this.AssemblyResolve : ResolveEventHandler " Usage="member this.AssemblyResolve : System.ResolveEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.AssemblyResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アセンブリの解決が失敗したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 役割です、<xref:System.ResolveEventHandler>で指定されているアセンブリを返すには、このイベントの<xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType>プロパティ、またはアセンブリが認識されない場合は null を返します。 アセンブリは実行コンテキストに読み込まれる必要があります。リフレクション専用コンテキストに読み込まれる、負荷が発生します。 このイベントを発生させたは失敗します。  
  
 このイベントの使用に関するガイダンスについては、次を参照してください。[アセンブリ読み込みの解決](~/docs/framework/app-domains/resolve-assembly-loads.md)します。  
  
 以降では、 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]、<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>プロパティは、解決できなかったアセンブリの読み込みを要求したアセンブリを返します。 たとえば、ローダーが、プローブ パスに要求元のアセンブリとその依存関係はないため、要求元のアセンブリの依存関係を読み込めませんしない場合もあります。 依存関係の 1 つ以上のバージョンが利用可能な場合は、要求元のアセンブリの id を知ることが、依存関係を検出するか、適切なバージョンを識別するときに便利な可能性がありますに。 詳細については、「<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>」を参照してください。  
  
> [!IMPORTANT]
>  以降では、 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]、<xref:System.ResolveEventHandler>リソース アセンブリを含め、すべてのアセンブリのイベントが発生します。 以前のバージョンでは、リソース アセンブリに対して、イベントが生成されません。 オペレーティング システムがローカライズされている場合、ハンドラーが複数回を呼び出すことがあります。 各カルチャ フォールバック チェーン内に 1 回です。  
  
 このイベントで、<xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType>プロパティは、ポリシーが適用される前に、アセンブリ名を返します。  
  
> [!IMPORTANT]
>  このイベントは、複数のイベント ハンドラーが登録している場合、イベント ハンドラーが値を返すまでの順序でイベント handlersarecalled わけではありません`null`します。 後続のイベント ハンドラーは無視されます。  
  
 イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。  
  
   
  
## Examples  
 次のサンプルでは、<xref:System.AppDomain.AssemblyResolve>イベント。  
  
 このコード例を実行するには、完全修飾アセンブリ名を指定する必要があります。 完全修飾アセンブリ名を取得する方法については、次を参照してください。[アセンブリ名](~/docs/framework/app-domains/assembly-names.md)します。  
  
 [!code-cpp[AssemblyResolve#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyResolve/CPP/assemblyresolve.cpp#1)]
 [!code-csharp[AssemblyResolve#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyResolve/CS/assemblyresolve.cs#1)]
 [!code-vb[AssemblyResolve#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyResolve/VB/assemblyresolve.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
        <related type="Article" href="https://msdn.microsoft.com/library/5099e549-f4fd-49fb-a290-549edd456c6a">解決 (アセンブリ読み込みを)</related>
      </Docs>
    </Member>
    <Member MemberName="BaseDirectory">
      <MemberSignature Language="C#" Value="public string BaseDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BaseDirectory" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.BaseDirectory" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ BaseDirectory { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseDirectory : string" Usage="System.AppDomain.BaseDirectory" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.BaseDirectory</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アセンブリを探すためにアセンブリ リゾルバーが使用したベース ディレクトリを取得します。</summary>
        <value>アセンブリを探すためにアセンブリ リゾルバーが使用するベース ディレクトリ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティに対応、<xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>プロパティ。 これも取得できますを使用して、<xref:System.AppDomain.GetData%2A>文字列"APPBASE"を持つメソッド。  
  
   
  
## Examples  
 次のコード例は、ドメインに読み込むアセンブリを検索するときに使用するベース ディレクトリを指定する、新しいアプリケーション ドメインを作成します。 使用して、<xref:System.AppDomain.BaseDirectory%2A>プロパティをコンソールに表示するためのベース ディレクトリ パスを取得します。  
  
 [!code-cpp[ADSetup#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADSetup/CPP/adsetup.cpp#1)]
 [!code-csharp[ADSetup#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADSetup/CS/adsetup.cs#1)]
 [!code-vb[ADSetup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADSetup/VB/adsetup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作が試行されています。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">パス自体の情報へのアクセスを含め、パスはフォーム file:// でまたは\\\UNC\dir または"c:\\"。 列挙体に関連付けられている:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />します。</permission>
        <altmember cref="P:System.AppDomainSetup.ApplicationBase" />
      </Docs>
    </Member>
    <Member MemberName="ClearPrivatePath">
      <MemberSignature Language="C#" Value="public void ClearPrivatePath ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ClearPrivatePath() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ClearPrivatePath" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearPrivatePath ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ClearPrivatePath();" />
      <MemberSignature Language="F#" Value="abstract member ClearPrivatePath : unit -&gt; unit&#xA;override this.ClearPrivatePath : unit -&gt; unit" Usage="appDomain.ClearPrivatePath " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ClearPrivatePath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("AppDomain.ClearPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Obsolete("AppDomain.ClearPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>プライベート アセンブリの場所を指定するパスを空の文字列 ("") にリセットします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プライベート パスは、プライベート アセンブリを検索する、共通言語ランタイムが検索するベース ディレクトリの相対パスです。  
  
 詳細については、「<xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>」を参照してください。  
  
   
  
## Examples  
 次のコード例は、使用する方法を示します、<xref:System.AppDomain.ClearPrivatePath%2A>アセンブリが読み込まれるときに検索するプライベート パスの一覧からすべてのエントリを削除する方法。  
  
 このメソッドは、廃止されており新しい開発ないで使用する必要があります。  
  
 [!code-cpp[ADClearPrivatePath#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADClearPrivatePath/CPP/adclearprivatepath.cpp#1)]
 [!code-csharp[ADClearPrivatePath#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADClearPrivatePath/CS/adclearprivatepath.cs#1)]
 [!code-vb[ADClearPrivatePath#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADClearPrivatePath/VB/adclearprivatepath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作が試行されています。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</permission>
        <altmember cref="F:System.String.Empty" />
      </Docs>
    </Member>
    <Member MemberName="ClearShadowCopyPath">
      <MemberSignature Language="C#" Value="public void ClearShadowCopyPath ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ClearShadowCopyPath() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ClearShadowCopyPath" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearShadowCopyPath ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ClearShadowCopyPath();" />
      <MemberSignature Language="F#" Value="abstract member ClearShadowCopyPath : unit -&gt; unit&#xA;override this.ClearShadowCopyPath : unit -&gt; unit" Usage="appDomain.ClearShadowCopyPath " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ClearShadowCopyPath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyDirectories")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Obsolete("AppDomain.ClearShadowCopyPath has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyDirectories instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>シャドウ コピーされたアセンブリが含まれているディレクトリのリストを空の文字列 ("") にリセットします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 シャドウ コピーのパスは、シャドウ コピーされたアセンブリのディレクトリのリストが格納されます。  
  
 詳細については、次を参照してください。<xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=nameWithType>と[アセンブリのシャドウ コピー](~/docs/framework/app-domains/shadow-copy-assemblies.md)します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作が試行されています。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</permission>
        <altmember cref="F:System.String.Empty" />
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">アセンブリのシャドウ コピー</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateComInstanceFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定した COM 型の新しいインスタンスを作成します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateComInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateComInstanceFrom (assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateComInstanceFrom(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="member this.CreateComInstanceFrom : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateComInstanceFrom (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">要求された型を定義するアセンブリが格納されているファイルの名前。</param>
        <param name="typeName">要求された型の名前。</param>
        <summary>指定した COM 型の新しいインスタンスを作成します。 パラメーターには、型を含んでいるアセンブリのファイルの名前および型の名前を指定します。</summary>
        <returns>
          <paramref name="typeName" /> で指定した新しいインスタンスのラッパーであるオブジェクト。 実際のオブジェクトにアクセスするには、戻り値のラップを解除する必要があります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、ローカル型を読み込むことがなく、リモート オブジェクトを作成します。  
  
 戻り値は、実際のオブジェクトにアクセスするラップ解除する必要があります。  
  
 A<xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType>属性の値`true`; 型のインスタンスを作成するこのメソッドの COM 型を明示的にまたは既定で適用する必要がありますそれ以外の場合、<xref:System.TypeLoadException>がスローされます。  
  
   
  
## Examples  
 次の例します。  
  
 [!code-cpp[AppDomain_CreateComInstanceFrom#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_CreateComInstanceFrom/CPP/createcominstancefrom.cpp#1)]
 [!code-csharp[AppDomain_CreateComInstanceFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_CreateComInstanceFrom/CS/createcominstancefrom.cs#1)]
 [!code-vb[AppDomain_CreateComInstanceFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_CreateComInstanceFrom/VB/createcominstancefrom.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> または <paramref name="typeName" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.TypeLoadException">型を読み込むことができません。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作が試行されています。</exception>
        <exception cref="T:System.MissingMethodException">パラメーターなしのパブリック コンストラクターが見つかりませんでした。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> が見つかりません。</exception>
        <exception cref="T:System.MemberAccessException">
          <paramref name="typeName" /> は抽象クラスです。  
  
または 
このメンバーは、遅延バインディング メカニズムで呼び出されました。</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.MarshalByRefObject" /> から継承されていないオブジェクトに対して、呼び出し元がアクティベーション属性を与えることはできません。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyName" /> が空の文字列 ("") です。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> が有効なアセンブリではありません。</exception>
        <exception cref="T:System.IO.FileLoadException">1 つのアセンブリまたはモジュールが 2 つの異なる証拠を使用して 2 回読み込まれました。</exception>
        <exception cref="T:System.NullReferenceException">参照されている COM オブジェクトが <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">アセンブリ マニフェストを含むファイルの読み取りに必要なアクセス許可。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">アセンブリがローカルでない場合、アセンブリの場所にアクセスする機能。</permission>
        <altmember cref="M:System.Activator.CreateComInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateComInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyFile, string typeName, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyFile, string typeName, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateComInstanceFrom (assemblyFile As String, typeName As String, hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateComInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="member this.CreateComInstanceFrom : string * string * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateComInstanceFrom (assemblyFile, typeName, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">要求された型を定義するアセンブリが格納されているファイルの名前。</param>
        <param name="typeName">要求された型の名前。</param>
        <param name="hashValue">計算されたハッシュ コードの値を表します。</param>
        <param name="hashAlgorithm">アセンブリ マニフェストが使用するハッシュ アルゴリズムを表します。</param>
        <summary>指定した COM 型の新しいインスタンスを作成します。 パラメーターには、型を含んでいるアセンブリのファイルの名前および型の名前を指定します。</summary>
        <returns>
          <paramref name="typeName" /> で指定した新しいインスタンスのラッパーであるオブジェクト。 実際のオブジェクトにアクセスするには、戻り値のラップを解除する必要があります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、ローカル型を読み込むことがなく、リモート オブジェクトを作成します。  
  
 戻り値は、実際のオブジェクトにアクセスするラップ解除する必要があります。  
  
 A<xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType>属性の値`true`; 型のインスタンスを作成するこのメソッドの COM 型を明示的にまたは既定で適用する必要がありますそれ以外の場合、<xref:System.TypeLoadException>がスローされます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> または <paramref name="typeName" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.TypeLoadException">型を読み込むことができません。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作が試行されています。</exception>
        <exception cref="T:System.MissingMethodException">パラメーターなしのパブリック コンストラクターが見つかりませんでした。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> が見つかりません。</exception>
        <exception cref="T:System.MemberAccessException">
          <paramref name="typeName" /> は抽象クラスです。  
  
または 
このメンバーは、遅延バインディング メカニズムで呼び出されました。</exception>
        <exception cref="T:System.NotSupportedException">呼び出し元は、<see cref="T:System.MarshalByRefObject" /> を継承しないオブジェクトのアクティベーション属性を提供できません。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyFile" /> が空の文字列 ("") です。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> が有効なアセンブリではありません。</exception>
        <exception cref="T:System.IO.FileLoadException">1 つのアセンブリまたはモジュールが 2 つの異なる証拠を使用して 2 回読み込まれました。</exception>
        <exception cref="T:System.NullReferenceException">参照されている COM オブジェクトが <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">アセンブリ マニフェストを含むファイルの読み取りに必要なアクセス許可。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">アセンブリがローカルでない場合、アセンブリの場所にアクセスする機能。</permission>
        <altmember cref="M:System.Activator.CreateComInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDomain">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>新しいアプリケーション ドメインを作成します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string -&gt; AppDomain" Usage="System.AppDomain.CreateDomain friendlyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="friendlyName">ドメインの表示名。</param>
        <summary>名前を指定して新しいアプリケーション ドメインを作成します。</summary>
        <returns>新しく作成されたアプリケーション ドメイン。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `friendlyName`人間にわかりやすい方法でドメインを識別するパラメーターが対象としています。 この文字列は、ユーザー インターフェイスに表示するための適切なである必要があります。  
  
 このメソッドのオーバー ロードを使用して、<xref:System.AppDomainSetup>既定のアプリケーション ドメインからの情報。  
  
   
  
## Examples  
 次の例を示します、一般のいずれかを使用してドメインを作成する方法、<xref:System.AppDomain.CreateDomain%2A>オーバー ロードします。  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> は <see langword="null" />です。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">証拠を提供します。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /> (関連する列挙体)</permission>
        <altmember cref="P:System.AppDomain.FriendlyName" />
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="friendlyName">ドメインの表示名。 この表示名は、ドメインを識別するためにユーザー インターフェイスに表示できます。 詳細については、「<see cref="P:System.AppDomain.FriendlyName" />」を参照してください。</param>
        <param name="securityInfo">アプリケーション ドメインで実行されるコードの ID を確立する証拠。 現在のアプリケーション ドメインの証拠を使用するには、<see langword="null" /> を渡します。</param>
        <summary>名前および証拠を指定して新しいアプリケーション ドメインを作成します。</summary>
        <returns>新しく作成されたアプリケーション ドメイン。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドのオーバー ロードを使用して、<xref:System.AppDomainSetup>既定のアプリケーション ドメインからの情報。  
  
 場合`securityInfo`は省略すると、現在のアプリケーション ドメインから証拠を使用します。  
  
> [!IMPORTANT]
>  サンド ボックス アプリケーション ドメインを作成するのには、このメソッドのオーバー ロードを使わないでください。 以降では、 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]、指定されている証拠`securityInfo`不要になったアプリケーション ドメインの許可セットに影響します。 使用して、<xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29>サンド ボックス アプリケーション ドメインを作成するメソッドのオーバー ロードします。  
  
   
  
## Examples  
 次の例を示します、一般のいずれかを使用してドメインを作成する方法、<xref:System.AppDomain.CreateDomain%2A>オーバー ロードします。  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> は <see langword="null" />です。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">証拠を提供します。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /> (関連する列挙体)</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, AppDomainSetup info);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, class System.AppDomainSetup info) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, info As AppDomainSetup) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, AppDomainSetup ^ info);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence * AppDomainSetup -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo, info)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="info" Type="System.AppDomainSetup" />
      </Parameters>
      <Docs>
        <param name="friendlyName">ドメインの表示名。 この表示名は、ドメインを識別するためにユーザー インターフェイスに表示できます。 詳細については、「<see cref="P:System.AppDomain.FriendlyName" />」を参照してください。</param>
        <param name="securityInfo">アプリケーション ドメインで実行されるコードの ID を確立する証拠。 現在のアプリケーション ドメインの証拠を使用するには、<see langword="null" /> を渡します。</param>
        <param name="info">アプリケーション ドメインの初期化情報を格納しているオブジェクト。</param>
        <summary>名前、証拠、およびアプリケーション ドメイン設定情報を指定して、新しいアプリケーション ドメインを作成します。</summary>
        <returns>新しく作成されたアプリケーション ドメイン。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合`info`は省略すると、このメソッドのオーバー ロードを使用して、<xref:System.AppDomainSetup>既定のアプリケーション ドメインからの情報。  
  
 場合`securityInfo`は省略すると、現在のアプリケーション ドメインから証拠を使用します。  
  
> [!IMPORTANT]
>  サンド ボックス アプリケーション ドメインを作成するのには、このメソッドのオーバー ロードを使わないでください。 以降では、 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]、指定されている証拠`securityInfo`不要になったアプリケーション ドメインの許可セットに影響します。 使用して、<xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29>サンド ボックス アプリケーション ドメインを作成するメソッドのオーバー ロードします。  
  
   
  
## Examples  
 次の例を示します、一般のいずれかを使用してドメインを作成する方法、<xref:System.AppDomain.CreateDomain%2A>オーバー ロードします。  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> は <see langword="null" />です。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">証拠を提供します。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /> (関連する列挙体)</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, AppDomainSetup info, System.Security.PermissionSet grantSet, params System.Security.Policy.StrongName[] fullTrustAssemblies);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, class System.AppDomainSetup info, class System.Security.PermissionSet grantSet, class System.Security.Policy.StrongName[] fullTrustAssemblies) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, info As AppDomainSetup, grantSet As PermissionSet, ParamArray fullTrustAssemblies As StrongName()) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, AppDomainSetup ^ info, System::Security::PermissionSet ^ grantSet, ... cli::array &lt;System::Security::Policy::StrongName ^&gt; ^ fullTrustAssemblies);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence * AppDomainSetup * System.Security.PermissionSet * System.Security.Policy.StrongName[] -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo, info, grantSet, fullTrustAssemblies)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="info" Type="System.AppDomainSetup" />
        <Parameter Name="grantSet" Type="System.Security.PermissionSet" />
        <Parameter Name="fullTrustAssemblies" Type="System.Security.Policy.StrongName[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="friendlyName">ドメインの表示名。 この表示名は、ドメインを識別するためにユーザー インターフェイスに表示できます。 詳細については、<see cref="P:System.AppDomain.FriendlyName" /> のトピックを参照してください。</param>
        <param name="securityInfo">アプリケーション ドメインで実行されるコードの ID を確立する証拠。 現在のアプリケーション ドメインの証拠を使用するには、<see langword="null" /> を渡します。</param>
        <param name="info">アプリケーション ドメインの初期化情報を格納しているオブジェクト。</param>
        <param name="grantSet">新しいアプリケーション ドメインに読み込まれた、特定のアクセス許可を持たないすべてのアセンブリに付与される既定のアクセス許可セット。</param>
        <param name="fullTrustAssemblies">新しいアプリケーション ドメインで、完全に信頼されていると見なされるアセンブリを表す厳密名の配列。</param>
        <summary>指定された名前、証拠、アプリケーション ドメインの設定情報、既定のアクセス許可セット、および完全信頼されたアセンブリの配列を使用して、新しいアプリケーション ドメインを作成します。</summary>
        <returns>新しく作成されたアプリケーション ドメイン。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 設定する必要があります、<xref:System.AppDomainSetup.ApplicationBase%2A>のプロパティ、<xref:System.AppDomainSetup>オブジェクトに対して指定する`info`します。 それ以外の場合は、例外がスローされます。  
  
 場合`securityInfo`は省略すると、現在のアプリケーション ドメインから証拠を使用します。  
  
 提供情報`grantSet`と`fullTrustAssemblies`を作成するために使用する<xref:System.Security.Policy.ApplicationTrust>新しいアプリケーション ドメインのオブジェクト。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.InvalidOperationException">アプリケーション ドメインが <see langword="null" /> です。  
  
または 
<see cref="P:System.AppDomainSetup.ApplicationBase" /> プロパティは、<paramref name="info" /> 用に提供される <see cref="T:System.AppDomainSetup" /> オブジェクトでは設定されません。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">作成し、アプリケーション ドメインを操作する権限です。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain" /> (関連する列挙体) セキュリティ アクション:<see cref="F:System.Security.Permissions.SecurityAction.Demand" />します。</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, appBasePath As String, appRelativeSearchPath As String, shadowCopyFiles As Boolean) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, System::String ^ appBasePath, System::String ^ appRelativeSearchPath, bool shadowCopyFiles);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence * string * string * bool -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo, appBasePath, appRelativeSearchPath, shadowCopyFiles)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="appBasePath" Type="System.String" />
        <Parameter Name="appRelativeSearchPath" Type="System.String" />
        <Parameter Name="shadowCopyFiles" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="friendlyName">ドメインの表示名。 この表示名は、ドメインを識別するためにユーザー インターフェイスに表示できます。 詳細については、「<see cref="P:System.AppDomain.FriendlyName" />」を参照してください。</param>
        <param name="securityInfo">アプリケーション ドメインで実行されるコードの ID を確立する証拠。 現在のアプリケーション ドメインの証拠を使用するには、<see langword="null" /> を渡します。</param>
        <param name="appBasePath">アセンブリを探すためにアセンブリ リゾルバーが使用するベース ディレクトリ。 詳細については、「<see cref="P:System.AppDomain.BaseDirectory" />」を参照してください。</param>
        <param name="appRelativeSearchPath">アセンブリ リゾルバーがプライベート アセンブリを調べる場所を示す、ベース ディレクトリを基準とした相対パス。 詳細については、「<see cref="P:System.AppDomain.RelativeSearchPath" />」を参照してください。</param>
        <param name="shadowCopyFiles">
          <see langword="true" /> の場合、アセンブリのシャドウ コピーはこのアプリケーション ドメインに読み込まれます。</param>
        <summary>名前、証拠、アプリケーション ベース パス、相対検索パス、およびアセンブリのシャドウ コピーをアプリケーション ドメインに読み込むかどうかを示すパラメーターを指定して、新しいアプリケーション ドメインを作成します。</summary>
        <returns>新しく作成されたアプリケーション ドメイン。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合`securityInfo`は省略すると、現在のアプリケーション ドメインから証拠を使用します。  
  
 シャドウ コピーの詳細については、次を参照してください。<xref:System.AppDomain.ShadowCopyFiles%2A>と[アセンブリのシャドウ コピー](~/docs/framework/app-domains/shadow-copy-assemblies.md)します。  
  
> [!IMPORTANT]
>  サンド ボックス アプリケーション ドメインを作成するのには、このメソッドのオーバー ロードを使わないでください。 以降では、 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]、指定されている証拠`securityInfo`不要になったアプリケーション ドメインの許可セットに影響します。 使用して、<xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29>サンド ボックス アプリケーション ドメインを作成するメソッドのオーバー ロードします。  
  
   
  
## Examples  
 次の例を示します、一般のいずれかを使用してドメインを作成する方法、<xref:System.AppDomain.CreateDomain%2A>オーバー ロードします。  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> は <see langword="null" />です。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">証拠を提供します。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /> (関連する列挙体)</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles, AppDomainInitializer adInit, string[] adInitArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles, class System.AppDomainInitializer adInit, string[] adInitArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, appBasePath As String, appRelativeSearchPath As String, shadowCopyFiles As Boolean, adInit As AppDomainInitializer, adInitArgs As String()) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, System::String ^ appBasePath, System::String ^ appRelativeSearchPath, bool shadowCopyFiles, AppDomainInitializer ^ adInit, cli::array &lt;System::String ^&gt; ^ adInitArgs);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence * string * string * bool * AppDomainInitializer * string[] -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo, appBasePath, appRelativeSearchPath, shadowCopyFiles, adInit, adInitArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="appBasePath" Type="System.String" />
        <Parameter Name="appRelativeSearchPath" Type="System.String" />
        <Parameter Name="shadowCopyFiles" Type="System.Boolean" />
        <Parameter Name="adInit" Type="System.AppDomainInitializer" />
        <Parameter Name="adInitArgs" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="friendlyName">ドメインの表示名。 この表示名は、ドメインを識別するためにユーザー インターフェイスに表示できます。 詳細については、「<see cref="P:System.AppDomain.FriendlyName" />」を参照してください。</param>
        <param name="securityInfo">アプリケーション ドメインで実行されるコードの ID を確立する証拠。 現在のアプリケーション ドメインの証拠を使用するには、<see langword="null" /> を渡します。</param>
        <param name="appBasePath">アセンブリを探すためにアセンブリ リゾルバーが使用するベース ディレクトリ。 詳細については、「<see cref="P:System.AppDomain.BaseDirectory" />」を参照してください。</param>
        <param name="appRelativeSearchPath">アセンブリ リゾルバーがプライベート アセンブリを調べる場所を示す、ベース ディレクトリを基準とした相対パス。 詳細については、「<see cref="P:System.AppDomain.RelativeSearchPath" />」を参照してください。</param>
        <param name="shadowCopyFiles">アプリケーション ドメインにアセンブリのシャドウ コピーを読み込む場合は <see langword="true" />。</param>
        <param name="adInit">新しい <see cref="T:System.AppDomain" /> オブジェクトの初期化時に呼び出されるコールバック メソッドを表す <see cref="T:System.AppDomainInitializer" /> デリゲート。</param>
        <param name="adInitArgs">新しい <see cref="T:System.AppDomain" /> オブジェクトの初期化時にコールバック (<paramref name="adInit" />) に渡される文字列型引数の配列。</param>
        <summary>名前、証拠、アプリケーション ベース パス、相対検索パス、およびアセンブリのシャドウ コピーをアプリケーション ドメインに読み込むかどうかを示すパラメーターを指定して、新しいアプリケーション ドメインを作成します。 アプリケーション ドメインを初期化したときに呼び出されるコールバック メソッドと、そのコールバック メソッドに渡す文字列型引数の配列を指定します。</summary>
        <returns>新しく作成されたアプリケーション ドメイン。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 によって表されるメソッド`adInit`新しく作成されたアプリケーション ドメインのコンテキストで実行されます。  
  
 場合`securityInfo`は省略すると、現在のアプリケーション ドメインから証拠を使用します。  
  
 シャドウ コピーの詳細については、次を参照してください。<xref:System.AppDomain.ShadowCopyFiles%2A>と[アセンブリのシャドウ コピー](~/docs/framework/app-domains/shadow-copy-assemblies.md)します。  
  
> [!IMPORTANT]
>  サンド ボックス アプリケーション ドメインを作成するのには、このメソッドのオーバー ロードを使わないでください。 以降では、 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]、指定されている証拠`securityInfo`不要になったアプリケーション ドメインの許可セットに影響します。 使用して、<xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29>サンド ボックス アプリケーション ドメインを作成するメソッドのオーバー ロードします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> は <see langword="null" />です。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">証拠を提供します。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /> (関連する列挙体)</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定したアセンブリで定義されている、指定した型の新しいインスタンスを作成します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * string -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstance : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstance(System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">アセンブリの表示名。 「<see cref="P:System.Reflection.Assembly.FullName" />」を参照してください。</param>
        <param name="typeName">要求する型の完全修飾名。アセンブリは指定せずに、名前空間だけを指定します。この名前は、<see cref="P:System.Type.FullName" /> プロパティによって返されます。</param>
        <summary>指定したアセンブリで定義されている、指定した型の新しいインスタンスを作成します。</summary>
        <returns>
          <paramref name="typeName" /> で指定した新しいインスタンスのラッパーであるオブジェクト。 実際のオブジェクトにアクセスするには、戻り値のラップを解除する必要があります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドの既定のコンス トラクターを呼び出す`typeName`します。  
  
 参照してください<xref:System.Reflection.AssemblyName>の形式に関する`assemblyName`します。  
  
 呼び出そうとすると<xref:System.AppDomain.CreateInstance%2A>ターゲット上で対象のアプリケーション ドメイン内のアセンブリの読み込みが成功した現在のアプリケーション ドメインではないアプリケーション ドメインが発生します。 <xref:System.Reflection.Assembly>でない<xref:System.MarshalByRefObject>、このメソッドが返すしようとした場合、 <xref:System.Reflection.Assembly> 、現在のアプリケーション ドメインに読み込まれたアセンブリ、共通言語ランタイムが、現在のアプリケーション ドメインにアセンブリを読み込むにしてください、。負荷が失敗する可能性があります。 現在のアプリケーション ドメインに読み込まれるアセンブリは、2 つのアプリケーション ドメインのパスの設定が異なる場合、最初に読み込まれたアセンブリから異なる可能性があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作が試行されています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> または <paramref name="typeName" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> が有効なアセンブリではありません。  
  
または 
共通言語ランタイムのバージョン 2.0 以降が現在読み込まれていますが、<paramref name="assemblyName" /> はさらに新しいバージョンでコンパイルされています。</exception>
        <exception cref="T:System.IO.FileLoadException">1 つのアセンブリまたはモジュールが 2 つの異なる証拠を使用して 2 回読み込まれました。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> が見つかりませんでした。</exception>
        <exception cref="T:System.MethodAccessException">呼び出し元に、このコンストラクターを呼び出すためのアクセス許可がありません。</exception>
        <exception cref="T:System.MissingMethodException">一致するパブリック コンストラクターが見つかりませんでした。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> で、<paramref name="assemblyName" /> が見つかりませんでした。</exception>
        <exception cref="T:System.NullReferenceException">このインスタンスが <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">ファイルまたはディレクトリからと、パス自体の情報にアクセスするための読み取りにアクセスします。 列挙体に関連付けられている: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />、<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />します。</permission>
        <permission cref="T:System.Net.WebPermission">アセンブリがローカルでない場合、アセンブリの場所にアクセスする機能。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">デリゲートのインスタンスを作成するときに、アンマネージ コードを呼び出す機能。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (assemblyName As String, typeName As String, activationAttributes As Object()) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstance : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstance(System.String,System.String,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">アセンブリの表示名。 「<see cref="P:System.Reflection.Assembly.FullName" />」を参照してください。</param>
        <param name="typeName">要求する型の完全修飾名。アセンブリは指定せずに、名前空間だけを指定します。この名前は、<see cref="P:System.Type.FullName" /> プロパティによって返されます。</param>
        <param name="activationAttributes">アクティべーションに参加できる 1 つ以上の属性の配列。 通常、リモート オブジェクトをアクティブ化するために必要な URL を指定する 1 つの <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> オブジェクトを含む配列。  
  
このパラメーターは、クライアント側でアクティブ化されるオブジェクトに関連しています。クライアント アクティベーションは、下位互換性のために残されているレガシ テクノロジです。新規の開発には使用しないでください。 分散アプリケーションは、代わりに Windows Communication Foundation (WCF) を使用する必要があります。</param>
        <summary>指定したアセンブリで定義されている、指定した型の新しいインスタンスを作成します。 アクティベーション属性の配列をパラメーターで指定します。</summary>
        <returns>
          <paramref name="typeName" /> で指定した新しいインスタンスのラッパーであるオブジェクト。 実際のオブジェクトにアクセスするには、戻り値のラップを解除する必要があります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドの既定のコンス トラクターを呼び出す`typeName`します。  
  
 参照してください<xref:System.Reflection.AssemblyName>の形式に関する`assemblyName`します。  
  
 呼び出そうとすると<xref:System.AppDomain.CreateInstance%2A>ターゲット上で対象のアプリケーション ドメイン内のアセンブリの読み込みが成功した現在のアプリケーション ドメインではないアプリケーション ドメインが発生します。 <xref:System.Reflection.Assembly>でない<xref:System.MarshalByRefObject>、このメソッドが返すしようとした場合、 <xref:System.Reflection.Assembly> 、現在のアプリケーション ドメインに読み込まれたアセンブリ、共通言語ランタイムが、現在のアプリケーション ドメインにアセンブリを読み込むにしてください、。負荷が失敗する可能性があります。 現在のアプリケーション ドメインに読み込まれるアセンブリは、2 つのアプリケーション ドメインのパスの設定が異なる場合、最初に読み込まれたアセンブリから異なる可能性があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作が試行されています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> または <paramref name="typeName" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> が有効なアセンブリではありません。  
  
または 
共通言語ランタイムのバージョン 2.0 以降が現在読み込まれていますが、<paramref name="assemblyName" /> はさらに新しいバージョンでコンパイルされています。</exception>
        <exception cref="T:System.IO.FileLoadException">1 つのアセンブリまたはモジュールが 2 つの異なる証拠を使用して 2 回読み込まれました。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> が見つかりませんでした。</exception>
        <exception cref="T:System.MethodAccessException">呼び出し元に、このコンストラクターを呼び出すためのアクセス許可がありません。</exception>
        <exception cref="T:System.MissingMethodException">一致するパブリック コンストラクターが見つかりませんでした。</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.MarshalByRefObject" /> から継承されていないオブジェクトに対して、呼び出し元がアクティベーション属性を与えることはできません。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> で、<paramref name="assemblyName" /> が見つかりませんでした。</exception>
        <exception cref="T:System.NullReferenceException">このインスタンスが <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">アセンブリ マニフェストを含むファイルの読み取りに必要なアクセス許可。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">アセンブリがローカルでない場合、アセンブリの場所にアクセスする機能。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">デリゲートのインスタンスを作成するときに、アンマネージ コードを呼び出す機能。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">すべての型のメンバーに対して操作を呼び出す権限です。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstance : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">アセンブリの表示名。 「<see cref="P:System.Reflection.Assembly.FullName" />」を参照してください。</param>
        <param name="typeName">要求する型の完全修飾名。アセンブリは指定せずに、名前空間だけを指定します。この名前は、<see cref="P:System.Type.FullName" /> プロパティによって返されます。</param>
        <param name="ignoreCase">検索で大文字と小文字を区別するかどうかを指定する Boolean 値。</param>
        <param name="bindingAttr">
          <paramref name="typeName" /> コンストラクターの検索に影響を与える 0 個以上のビット フラグの組み合わせ。 <paramref name="bindingAttr" /> が 0 の場合は、大文字と小文字を区別してパブリック コンストラクターを検索します。</param>
        <param name="binder">バインディング、引数型の強制変換、メンバーの呼び出し、および、リフレクションを使用した <see cref="T:System.Reflection.MemberInfo" /> オブジェクトの取得を有効にするオブジェクト。 <paramref name="binder" /> が null の場合は、既定のバインダーが使用されます。</param>
        <param name="args">コンストラクターに渡される引数。 この引数の配列は、呼び出すコンストラクターのパラメーターに対して、数、順序、および型を一致させる必要があります。 既定のコンストラクターを優先する場合は、<paramref name="args" /> を空の配列または null にする必要があります。</param>
        <param name="culture">
          <paramref name="args" /> から <paramref name="typeName" /> コンストラクターに対して宣言された仮引数型への強制変換を制御するカルチャ固有の情報。 <paramref name="culture" /> が <see langword="null" /> の場合は、現在のスレッドの <see cref="T:System.Globalization.CultureInfo" /> が使用されます。</param>
        <param name="activationAttributes">アクティべーションに参加できる 1 つ以上の属性の配列。 通常、リモート オブジェクトをアクティブ化するために必要な URL を指定する 1 つの <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> オブジェクトを含む配列。  
  
このパラメーターは、クライアント側でアクティブ化されるオブジェクトに関連しています。 クライアント アクティベーションは、下位互換性のために残されているレガシ テクノロジです。新規の開発には使用しないでください。 分散アプリケーションは、代わりに Windows Communication Foundation (WCF) を使用する必要があります。</param>
        <summary>指定したアセンブリで定義されている、指定した型の新しいインスタンスを作成します。 バインダー、バインディング フラグ、コンストラクター引数、引数を解釈するために使用するカルチャ固有の情報、および省略可能なアクティベーション属性をパラメーターで指定します。</summary>
        <returns>
          <paramref name="typeName" /> で指定した新しいインスタンスのラッパーであるオブジェクト。 実際のオブジェクトにアクセスするには、戻り値のラップを解除する必要があります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 参照してください<xref:System.Reflection.AssemblyName>の形式に関する`assemblyName`します。  
  
 呼び出そうとすると<xref:System.AppDomain.CreateInstance%2A>ターゲット上で対象のアプリケーション ドメイン内のアセンブリの読み込みが成功した現在のアプリケーション ドメインではないアプリケーション ドメインが発生します。 <xref:System.Reflection.Assembly>でない<xref:System.MarshalByRefObject>、このメソッドが返すしようとした場合、 <xref:System.Reflection.Assembly> 、現在のアプリケーション ドメインに読み込まれたアセンブリ、共通言語ランタイムが、現在のアプリケーション ドメインにアセンブリを読み込むにしてください、。負荷が失敗する可能性があります。 現在のアプリケーション ドメインに読み込まれるアセンブリは、2 つのアプリケーション ドメインのパスの設定が異なる場合、最初に読み込まれたアセンブリから異なる可能性があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作が試行されています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> または <paramref name="typeName" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> が有効なアセンブリではありません。  
  
または 
 現在読み込まれているバージョンよりも新しいバージョンの共通言語ランタイムで、<paramref name="assemblyName" /> がコンパイルされました。</exception>
        <exception cref="T:System.IO.FileLoadException">1 つのアセンブリまたはモジュールが 2 つの異なる証拠を使用して 2 回読み込まれました。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> が見つかりませんでした。</exception>
        <exception cref="T:System.MethodAccessException">呼び出し元に、このコンストラクターを呼び出すためのアクセス許可がありません。</exception>
        <exception cref="T:System.MissingMethodException">一致するコンストラクターが見つかりませんでした。</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.MarshalByRefObject" /> から継承されていないオブジェクトに対して、呼び出し元がアクティベーション属性を与えることはできません。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> で、<paramref name="assemblyName" /> が見つかりませんでした。</exception>
        <exception cref="T:System.NullReferenceException">このインスタンスが <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">アセンブリ マニフェストを含むファイルの読み取りに必要なアクセス許可。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">アセンブリがローカルでない場合、アセンブリの場所にアクセスする機能。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">デリゲートのインスタンスを作成するときに、アンマネージ コードを呼び出す機能。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">すべての型のメンバーに対して操作を呼び出す権限です。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstance : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstance which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName">アセンブリの表示名。 「<see cref="P:System.Reflection.Assembly.FullName" />」を参照してください。</param>
        <param name="typeName">要求する型の完全修飾名。アセンブリは指定せずに、名前空間だけを指定します。この名前は、<see cref="P:System.Type.FullName" /> プロパティによって返されます。</param>
        <param name="ignoreCase">検索で大文字と小文字を区別するかどうかを指定する Boolean 値。</param>
        <param name="bindingAttr">
          <paramref name="typeName" /> コンストラクターの検索に影響を与える 0 個以上のビット フラグの組み合わせ。 <paramref name="bindingAttr" /> が 0 の場合は、大文字と小文字を区別してパブリック コンストラクターを検索します。</param>
        <param name="binder">バインディング、引数型の強制変換、メンバーの呼び出し、および、リフレクションを使用した <see cref="T:System.Reflection.MemberInfo" /> オブジェクトの取得を有効にするオブジェクト。 <paramref name="binder" /> が null の場合は、既定のバインダーが使用されます。</param>
        <param name="args">コンストラクターに渡される引数。 この引数の配列は、呼び出すコンストラクターのパラメーターに対して、数、順序、および型を一致させる必要があります。 既定のコンストラクターを優先する場合は、<paramref name="args" /> を空の配列または null にする必要があります。</param>
        <param name="culture">
          <paramref name="args" /> から <paramref name="typeName" /> コンストラクターに対して宣言された仮引数型への強制変換を制御するカルチャ固有の情報。 <paramref name="culture" /> が <see langword="null" /> の場合は、現在のスレッドの <see cref="T:System.Globalization.CultureInfo" /> が使用されます。</param>
        <param name="activationAttributes">アクティべーションに参加できる 1 つ以上の属性の配列。 通常、リモート オブジェクトをアクティブ化するために必要な URL を指定する 1 つの <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> オブジェクトを含む配列。  
  
このパラメーターは、クライアント側でアクティブ化されるオブジェクトに関連しています。クライアント アクティベーションは、下位互換性のために残されているレガシ テクノロジです。新規の開発には使用しないでください。 分散アプリケーションは、代わりに Windows Communication Foundation (WCF) を使用する必要があります。</param>
        <param name="securityAttributes">
          <paramref name="typeName" /> の作成を承認するために使用される情報。</param>
        <summary>指定したアセンブリで定義されている、指定した型の新しいインスタンスを作成します。 バインダー、バインディング フラグ、コンストラクター引数、引数を解釈するために使用するカルチャ固有の情報、アクティベーション属性、型を作成するために必要な承認情報をパラメーターで指定します。</summary>
        <returns>
          <paramref name="typeName" /> で指定した新しいインスタンスのラッパーであるオブジェクト。 実際のオブジェクトにアクセスするには、戻り値のラップを解除する必要があります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 参照してください<xref:System.Reflection.AssemblyName>の形式に関する`assemblyName`します。  
  
 呼び出そうとすると<xref:System.AppDomain.CreateInstance%2A>ターゲット上で対象のアプリケーション ドメイン内のアセンブリの読み込みが成功した現在のアプリケーション ドメインではないアプリケーション ドメインが発生します。 <xref:System.Reflection.Assembly>でない<xref:System.MarshalByRefObject>、このメソッドが返すしようとした場合、 <xref:System.Reflection.Assembly> 、現在のアプリケーション ドメインに読み込まれたアセンブリ、共通言語ランタイムが、現在のアプリケーション ドメインにアセンブリを読み込むにしてください、。負荷が失敗する可能性があります。 現在のアプリケーション ドメインに読み込まれるアセンブリは、2 つのアプリケーション ドメインのパスの設定が異なる場合、最初に読み込まれたアセンブリから異なる可能性があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作が試行されています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> または <paramref name="typeName" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> が有効なアセンブリではありません。  
  
または 
共通言語ランタイムのバージョン 2.0 以降が現在読み込まれていますが、<paramref name="assemblyName" /> はさらに新しいバージョンでコンパイルされています。</exception>
        <exception cref="T:System.IO.FileLoadException">1 つのアセンブリまたはモジュールが 2 つの異なる証拠を使用して 2 回読み込まれました。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> が見つかりませんでした。</exception>
        <exception cref="T:System.MethodAccessException">呼び出し元に、このコンストラクターを呼び出すためのアクセス許可がありません。</exception>
        <exception cref="T:System.MissingMethodException">一致するコンストラクターが見つかりませんでした。</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.MarshalByRefObject" /> から継承されていないオブジェクトに対して、呼び出し元がアクティベーション属性を与えることはできません。  
  
または 
 <paramref name="securityAttributes" /> が <see langword="null" /> ではありません。 レガシ CAS ポリシーが有効になっていない場合は、<paramref name="securityAttributes" /> を <see langword="null." /> にする必要があります</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> で、<paramref name="assemblyName" /> が見つかりませんでした。</exception>
        <exception cref="T:System.NullReferenceException">このインスタンスが <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">アセンブリ マニフェストを含むファイルの読み取りに必要なアクセス許可。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">アセンブリがローカルでない場合、アセンブリの場所にアクセスする機能。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">証拠を提供します。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /> (関連する列挙体)</permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">すべての型のメンバーに対して操作を呼び出す権限です。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceAndUnwrap">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定した型の新しいインスタンスを作成します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceAndUnwrap (assemblyName As String, typeName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceAndUnwrap : string * string -&gt; obj" Usage="appDomain.CreateInstanceAndUnwrap (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">アセンブリの表示名。 「<see cref="P:System.Reflection.Assembly.FullName" />」を参照してください。</param>
        <param name="typeName">要求する型の完全修飾名。アセンブリは指定せずに、名前空間だけを指定します。この名前は、<see cref="P:System.Type.FullName" /> プロパティによって返されます。</param>
        <summary>指定した型の新しいインスタンスを作成します。 パラメーターには、型が定義されているアセンブリの名前と型の名前を指定します。</summary>
        <returns>
          <paramref name="typeName" /> で指定したオブジェクトのインスタンス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 これは、結合メソッドは<xref:System.AppDomain.CreateInstance%2A>と<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>します。 このメソッドの既定のコンス トラクターを呼び出す`typeName`します。  
  
 参照してください<xref:System.Reflection.AssemblyName>の形式に関する`assemblyName`します。 参照してください、<xref:System.Type.FullName%2A?displayProperty=nameWithType>プロパティの形式に関する`typeName`します。  
  
> [!NOTE]
>  メソッドへの事前バインディングされた呼び出しを行った場合`M`型のオブジェクトの`T1`によって返された<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>、メソッドは、型のオブジェクトのメソッドへの事前バインディングされた呼び出しをおよび`T2`アセンブリで`C`以外、現在のアセンブリまたはアセンブリを含む`T1`、アセンブリ`C`は現在のアプリケーション ドメインに読み込まれます。 事前バインディングされた呼び出し場合でも、この読み込みが行われます`T1.M()`の本体で行われた、 <xref:System.Reflection.Emit.DynamicMethod>、またはその他の動的に生成されたコード。 現在のドメインが既定のドメイン、アセンブリがかどうか`C`プロセスが終了するまでアンロードすることはできません。 後で、現在のドメインがアセンブリの読み込みを試みると`C`負荷が失敗する可能性があります。  
  
   
  
## Examples  
 次のコード例では、別のアプリケーション ドメインでコードを実行する最も簡単な方法を示します。 例では、という名前のクラスを定義する`Worker`から継承する<xref:System.MarshalByRefObject>します。 `Worker`クラスを実行しているアプリケーション ドメインの名前を表示するメソッドを定義します。 インスタンスを作成する例では、`Worker`既定のアプリケーション ドメインと、新しいアプリケーション ドメイン。  
  
> [!NOTE]
>  含むアセンブリ`Worker`両方のアプリケーション ドメインに読み込まれる必要がありますが、新しいアプリケーション ドメインにのみ存在する他のアセンブリを読み込むことができます。  
  
 [!code-cpp[CreateInstanceAndUnwrap2#1](~/samples/snippets/cpp/VS_Snippets_CLR/CreateInstanceAndUnwrap2/cpp/source.cpp#1)]
 [!code-csharp[CreateInstanceAndUnwrap2#1](~/samples/snippets/csharp/VS_Snippets_CLR/CreateInstanceAndUnwrap2/cs/source.cs#1)]
 [!code-vb[CreateInstanceAndUnwrap2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CreateInstanceAndUnwrap2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> または <paramref name="typeName" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.MissingMethodException">一致するパブリック コンストラクターが見つかりませんでした。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> で、<paramref name="assemblyName" /> が見つかりませんでした。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> が見つかりませんでした。</exception>
        <exception cref="T:System.MethodAccessException">呼び出し元に、このコンストラクターを呼び出すためのアクセス許可がありません。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作が試行されています。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> が有効なアセンブリではありません。  
  
または 
共通言語ランタイムのバージョン 2.0 以降が現在読み込まれていますが、<paramref name="assemblyName" /> はさらに新しいバージョンでコンパイルされています。</exception>
        <exception cref="T:System.IO.FileLoadException">1 つのアセンブリまたはモジュールが 2 つの異なる証拠を使用して 2 回読み込まれました。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">アセンブリ マニフェストを含むファイルを読み取るため、モジュール マニフェストのファイル以外から型を作成する場合またはします。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">アセンブリがローカルでない場合、アセンブリの場所にアクセスする機能。</permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceAndUnwrap (assemblyName As String, typeName As String, activationAttributes As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceAndUnwrap : string * string * obj[] -&gt; obj" Usage="appDomain.CreateInstanceAndUnwrap (assemblyName, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">アセンブリの表示名。 「<see cref="P:System.Reflection.Assembly.FullName" />」を参照してください。</param>
        <param name="typeName">要求する型の完全修飾名。アセンブリは指定せずに、名前空間だけを指定します。この名前は、<see cref="P:System.Type.FullName" /> プロパティによって返されます。</param>
        <param name="activationAttributes">アクティべーションに参加できる 1 つ以上の属性の配列。 通常、リモート オブジェクトをアクティブ化するために必要な URL を指定する 1 つの <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> オブジェクトを含む配列。  
  
このパラメーターは、クライアント側でアクティブ化されるオブジェクトに関連しています。クライアント アクティベーションは、下位互換性のために残されているレガシ テクノロジです。新規の開発には使用しないでください。 分散アプリケーションは、代わりに Windows Communication Foundation (WCF) を使用する必要があります。</param>
        <summary>指定した型の新しいインスタンスを作成します。 パラメーターには、型が定義されているアセンブリの名前、型の名前、およびアクティベーション属性の配列を指定します。</summary>
        <returns>
          <paramref name="typeName" /> で指定したオブジェクトのインスタンス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 これは、結合メソッドは<xref:System.AppDomain.CreateInstance%2A>と<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>します。 このメソッドの既定のコンス トラクターを呼び出す`typeName`します。  
  
 参照してください<xref:System.Reflection.AssemblyName>の形式に関する`assemblyName`します。 参照してください、<xref:System.Type.FullName%2A?displayProperty=nameWithType>プロパティの形式に関する`typeName`します。  
  
> [!NOTE]
>  メソッドへの事前バインディングされた呼び出しを行った場合`M`型のオブジェクトの`T1`によって返された<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>、メソッドは、型のオブジェクトのメソッドへの事前バインディングされた呼び出しをおよび`T2`アセンブリで`C`以外、現在のアセンブリまたはアセンブリを含む`T1`、アセンブリ`C`は現在のアプリケーション ドメインに読み込まれます。 事前バインディングされた呼び出し場合でも、この読み込みが行われます`T1.M()`の本体で行われた、 <xref:System.Reflection.Emit.DynamicMethod>、またはその他の動的に生成されたコード。 現在のドメインが既定のドメイン、アセンブリがかどうか`C`プロセスが終了するまでアンロードすることはできません。 後で、現在のドメインがアセンブリの読み込みを試みると`C`負荷が失敗する可能性があります。  
  
   
  
## Examples  
 [!code-cpp[ADDyno#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDyno/CPP/addyno.cpp#1)]
 [!code-csharp[ADDyno#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDyno/CS/addyno.cs#1)]
 [!code-vb[ADDyno#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDyno/VB/addyno.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> または <paramref name="typeName" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.MissingMethodException">一致するパブリック コンストラクターが見つかりませんでした。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> で、<paramref name="assemblyName" /> が見つかりませんでした。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> が見つかりませんでした。</exception>
        <exception cref="T:System.MethodAccessException">呼び出し元に、このコンストラクターを呼び出すためのアクセス許可がありません。</exception>
        <exception cref="T:System.NotSupportedException">呼び出し元は、<see cref="T:System.MarshalByRefObject" /> を継承しないオブジェクトのアクティベーション属性を提供できません。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作が試行されています。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> が有効なアセンブリではありません。  
  
または 
共通言語ランタイムのバージョン 2.0 以降が現在読み込まれていますが、<paramref name="assemblyName" /> はさらに新しいバージョンでコンパイルされています。</exception>
        <exception cref="T:System.IO.FileLoadException">1 つのアセンブリまたはモジュールが 2 つの異なる証拠を使用して 2 回読み込まれました。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">アセンブリ マニフェストを含むファイルの読み取りに必要なアクセス許可。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">アセンブリがローカルでない場合、アセンブリの場所にアクセスする機能。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">デリゲートのインスタンスを作成するときに、アンマネージ コードを呼び出す機能。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">すべての型のメンバーに対して操作を呼び出す権限です。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceAndUnwrap : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj" Usage="appDomain.CreateInstanceAndUnwrap (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">アセンブリの表示名。 「<see cref="P:System.Reflection.Assembly.FullName" />」を参照してください。</param>
        <param name="typeName">要求する型の完全修飾名。アセンブリは指定せずに、名前空間だけを指定します。この名前は、<see cref="P:System.Type.FullName" /> プロパティによって返されます。</param>
        <param name="ignoreCase">検索で大文字と小文字を区別するかどうかを指定する Boolean 値。</param>
        <param name="bindingAttr">
          <paramref name="typeName" /> コンストラクターの検索に影響を与える 0 個以上のビット フラグの組み合わせ。 <paramref name="bindingAttr" /> が 0 の場合は、大文字と小文字を区別してパブリック コンストラクターを検索します。</param>
        <param name="binder">バインディング、引数型の強制変換、メンバーの呼び出し、および、リフレクションを使用した <see cref="T:System.Reflection.MemberInfo" /> オブジェクトの取得を有効にするオブジェクト。 <paramref name="binder" /> が null の場合は、既定のバインダーが使用されます。</param>
        <param name="args">コンストラクターに渡される引数。 この引数の配列は、呼び出すコンストラクターのパラメーターに対して、数、順序、および型を一致させる必要があります。 既定のコンストラクターを優先する場合は、<paramref name="args" /> を空の配列または null にする必要があります。</param>
        <param name="culture">型の強制変換を制御するために使用するカルチャ固有のオブジェクト。 <paramref name="culture" /> が <see langword="null" /> の場合は、現在のスレッドの <see langword="CultureInfo" /> が使用されます。</param>
        <param name="activationAttributes">アクティべーションに参加できる 1 つ以上の属性の配列。 一般的に、1 つの配列に 1 つの <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> オブジェクトが含まれます。 リモート オブジェクトのアクティブ化に必要な URL を指定します。  
  
このパラメーターは、クライアント側でアクティブ化されるオブジェクトに関連しています。 クライアント アクティベーションは、下位互換性のために残されているレガシ テクノロジです。新規の開発には使用しないでください。 分散アプリケーションは、代わりに Windows Communication Foundation (WCF) を使用する必要があります。</param>
        <summary>指定したアセンブリで定義されている、指定した型の新しいインスタンスを作成します。型名の大文字と小文字の区別を無視するかどうか、作成する型を選択するために使用されるバインディング属性とバインダー、コンストラクターの引数、カルチャ、およびアクティベーション属性を指定します。</summary>
        <returns>
          <paramref name="typeName" /> で指定したオブジェクトのインスタンス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 これは、結合メソッドは<xref:System.AppDomain.CreateInstance%2A>と<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>します。  
  
 参照してください<xref:System.Reflection.AssemblyName>の形式に関する`assemblyName`します。 参照してください、<xref:System.Type.FullName%2A?displayProperty=nameWithType>プロパティの形式に関する`typeName`します。  
  
> [!NOTE]
>  メソッドへの事前バインディングされた呼び出しを行った場合`M`型のオブジェクトの`T1`によって返された<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>、メソッドは、型のオブジェクトのメソッドへの事前バインディングされた呼び出しをおよび`T2`アセンブリで`C`以外、現在のアセンブリまたはアセンブリを含む`T1`、アセンブリ`C`は現在のアプリケーション ドメインに読み込まれます。 事前バインディングされた呼び出し場合でも、この読み込みが行われます`T1.M()`の本体で行われた、 <xref:System.Reflection.Emit.DynamicMethod>、またはその他の動的に生成されたコード。 現在のドメインが既定のドメイン、アセンブリがかどうか`C`プロセスが終了するまでアンロードすることはできません。 後で、現在のドメインがアセンブリの読み込みを試みると`C`負荷が失敗する可能性があります。  
  
   
  
## Examples  
 次の例では、使用、`ignoreCase`パラメーター。  
  
 [!code-cpp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CPP/ignorecase.cpp#1)]
 [!code-csharp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CS/ignorecase.cs#1)]
 [!code-vb[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/VB/ignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> または <paramref name="typeName" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.MissingMethodException">一致するコンストラクターが見つかりませんでした。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> が <paramref name="assemblyName" /> に見つかりませんでした。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> が見つかりませんでした。</exception>
        <exception cref="T:System.MethodAccessException">呼び出し元に、このコンストラクターを呼び出すためのアクセス許可がありません。</exception>
        <exception cref="T:System.NotSupportedException">呼び出し元は、<see cref="T:System.MarshalByRefObject" /> を継承しないオブジェクトのアクティベーション属性を提供できません。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作が試行されています。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> が有効なアセンブリではありません。  
  
または 
 現在読み込まれているバージョンよりも新しいバージョンの共通言語ランタイムで、<paramref name="assemblyName" /> がコンパイルされました。</exception>
        <exception cref="T:System.IO.FileLoadException">1 つのアセンブリまたはモジュールが 2 つの異なる証拠を使用して 2 回読み込まれました。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">アセンブリ マニフェストを含むファイルの読み取りに必要なアクセス許可。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">アセンブリがローカルでない場合、アセンブリの場所にアクセスする機能。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">デリゲートのインスタンスを作成するときに、アンマネージ コードを呼び出す機能。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">すべての型のメンバーに対して操作を呼び出す権限です。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceAndUnwrap : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; obj" Usage="appDomain.CreateInstanceAndUnwrap (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceAndUnwrap which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName">アセンブリの表示名。 「<see cref="P:System.Reflection.Assembly.FullName" />」を参照してください。</param>
        <param name="typeName">要求する型の完全修飾名。アセンブリは指定せずに、名前空間だけを指定します。この名前は、<see cref="P:System.Type.FullName" /> プロパティによって返されます。</param>
        <param name="ignoreCase">検索で大文字と小文字を区別するかどうかを指定する Boolean 値。</param>
        <param name="bindingAttr">
          <paramref name="typeName" /> コンストラクターの検索に影響を与える 0 個以上のビット フラグの組み合わせ。 <paramref name="bindingAttr" /> が 0 の場合は、大文字と小文字を区別してパブリック コンストラクターを検索します。</param>
        <param name="binder">バインディング、引数型の強制変換、メンバーの呼び出し、および、リフレクションを使用した <see cref="T:System.Reflection.MemberInfo" /> オブジェクトの取得を有効にするオブジェクト。 <paramref name="binder" /> が null の場合は、既定のバインダーが使用されます。</param>
        <param name="args">コンストラクターに渡される引数。 この引数の配列は、呼び出すコンストラクターのパラメーターに対して、数、順序、および型を一致させる必要があります。 既定のコンストラクターを優先する場合は、<paramref name="args" /> を空の配列または null にする必要があります。</param>
        <param name="culture">型の強制変換を制御するために使用するカルチャ固有のオブジェクト。 <paramref name="culture" /> が <see langword="null" /> の場合は、現在のスレッドの <see langword="CultureInfo" /> が使用されます。</param>
        <param name="activationAttributes">アクティべーションに参加できる 1 つ以上の属性の配列。 通常、リモート オブジェクトをアクティブ化するために必要な URL を指定する 1 つの <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> オブジェクトを含む配列。  
  
このパラメーターは、クライアント側でアクティブ化されるオブジェクトに関連しています。 クライアント アクティベーションは、下位互換性のために残されているレガシ テクノロジです。新規の開発には使用しないでください。 分散アプリケーションは、代わりに Windows Communication Foundation (WCF) を使用する必要があります。</param>
        <param name="securityAttributes">
          <paramref name="typeName" /> の作成を承認するために使用される情報。</param>
        <summary>指定した型の新しいインスタンスを作成します。 パラメーターには、型の名前、およびその検索方法と作成方法を指定します。</summary>
        <returns>
          <paramref name="typeName" /> で指定したオブジェクトのインスタンス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 これは、結合メソッドは<xref:System.AppDomain.CreateInstance%2A>と<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>します。  
  
 参照してください<xref:System.Reflection.AssemblyName>の形式に関する`assemblyName`します。 参照してください、<xref:System.Type.FullName%2A?displayProperty=nameWithType>プロパティの形式に関する`typeName`します。  
  
> [!NOTE]
>  メソッドへの事前バインディングされた呼び出しを行った場合`M`型のオブジェクトの`T1`によって返された<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>、メソッドは、型のオブジェクトのメソッドへの事前バインディングされた呼び出しをおよび`T2`アセンブリで`C`以外、現在のアセンブリまたはアセンブリを含む`T1`、アセンブリ`C`は現在のアプリケーション ドメインに読み込まれます。 事前バインディングされた呼び出し場合でも、この読み込みが行われます`T1.M()`の本体で行われた、 <xref:System.Reflection.Emit.DynamicMethod>、またはその他の動的に生成されたコード。 現在のドメインが既定のドメイン、アセンブリがかどうか`C`プロセスが終了するまでアンロードすることはできません。 後で、現在のドメインがアセンブリの読み込みを試みると`C`負荷が失敗する可能性があります。  
  
   
  
## Examples  
 次の例では、使用、`ignoreCase`パラメーター。  
  
 [!code-cpp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CPP/ignorecase.cpp#1)]
 [!code-csharp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CS/ignorecase.cs#1)]
 [!code-vb[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/VB/ignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> または <paramref name="typeName" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.MissingMethodException">一致するコンストラクターが見つかりませんでした。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> が <paramref name="assemblyName" /> に見つかりませんでした。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> が見つかりませんでした。</exception>
        <exception cref="T:System.MethodAccessException">呼び出し元に、このコンストラクターを呼び出すためのアクセス許可がありません。</exception>
        <exception cref="T:System.NotSupportedException">呼び出し元は、<see cref="T:System.MarshalByRefObject" /> を継承しないオブジェクトのアクティベーション属性を提供できません。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作が試行されています。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> が有効なアセンブリではありません。  
  
または 
共通言語ランタイムのバージョン 2.0 以降が現在読み込まれていますが、<paramref name="assemblyName" /> はさらに新しいバージョンでコンパイルされています。</exception>
        <exception cref="T:System.IO.FileLoadException">1 つのアセンブリまたはモジュールが 2 つの異なる証拠を使用して 2 回読み込まれました。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">アセンブリ マニフェストを含むファイルの読み取りに必要なアクセス許可。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">アセンブリがローカルでない場合、アセンブリの場所にアクセスする機能。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">証拠とアセンブリの読み込み。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /> (関連する列挙体)</permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">すべての型のメンバーに対して操作を呼び出す権限です。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定したアセンブリ ファイルで定義されている、指定した型の新しいインスタンスを作成します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFrom (assemblyFile As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceFrom : string * string -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstanceFrom : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstanceFrom(System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">要求する型を定義しているアセンブリが格納されているファイルの名前 (パスを含む)。 アセンブリは <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> メソッドを使用して読み込まれます。</param>
        <param name="typeName">要求する型の完全修飾名。アセンブリは指定せずに、名前空間だけを指定します。この名前は、<see cref="P:System.Type.FullName" /> プロパティによって返されます。</param>
        <summary>指定したアセンブリ ファイルで定義されている、指定した型の新しいインスタンスを作成します。</summary>
        <returns>新しいインスタンスのラッパーであるオブジェクト。<paramref name="typeName" /> が見つからない場合は <see langword="null" />。 実際のオブジェクトにアクセスするには、戻り値のラップを解除する必要があります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既定のコンス トラクター`typeName`が呼び出されます。  
  
 詳細については、<xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> メソッドのトピックを参照してください。  
  
 ときに、<xref:System.AppDomain.CreateInstanceFrom%2A>メソッドは、呼び出しが行われる元のアプリケーション ドメイン以外、対象のアプリケーション ドメインでインスタンスを作成するために使用、アセンブリが対象のアプリケーション ドメインに読み込まれます。 ただし、呼び出し元のアプリケーション ドメインにインスタンスをラップされたない場合は、特定の方法でラップされていないインスタンスを使用して可能性があります、呼び出し元のアプリケーション ドメインに読み込まれるアセンブリ。 たとえば、インスタンスは、ラップされたが、その型の情報を要求する可能性があります、そのメソッドを呼び出すために遅延バインディング。 アセンブリが呼び出し元のアプリケーション ドメインに読み込まれると、例外が発生することができます。  
  
-   呼び出し元のアプリケーション ドメインに同じアセンブリの別のバージョンが以前に読み込まれた場合、または呼び出し元のアプリケーション ドメインの読み込みパスがなど、対象のアプリケーション ドメインを例外と異なる場合<xref:System.MissingMethodException>発生することができます。  
  
-   呼び出し元のアプリケーション ドメインが、インスタンスの型の事前バインディングされた呼び出しを行った場合<xref:System.InvalidCastException>インスタンスのキャストを試行したときにスローされることができます。  
  
   
  
## Examples  
 次の例は、使用する方法を示します、<xref:System.AppDomain.CreateInstanceFrom%28System.String%2CSystem.String%29>対象のアプリケーション ドメインでオブジェクトのインスタンスを作成し、そのメソッドを呼び出すメソッドのオーバー ロードします。  
  
 例では、定義、`MarshallableExample`クラスは、アプリケーション ドメイン境界を越えてマーシャ リングすることができます。 例は、現在実行中のアセンブリのパスを作成、対象のアプリケーション ドメインを作成しを使用して、<xref:System.AppDomain.CreateInstanceFrom%28System.String%2CSystem.String%29>対象のアプリケーション ドメインにアセンブリを読み込むしのインスタンスを作成するメソッドのオーバー ロード`MarshallableExample`します。  
  
> [!NOTE]
>  パスが、この例では絶対値であってため、相対パスも機能、<xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType>メソッドを使用して、アセンブリを読み込みます。  
  
 オブジェクト ハンドルをラップ解除した後は、例は、対象のアプリケーション ドメインでオブジェクトを使用する 3 つの方法を示します。  
  
-   リフレクションを使用して、遅延バインディングのメソッドを呼び出します。 これには、これにより、呼び出し元のアプリケーション ドメインに読み込まれるアセンブリ、型情報が必要です。 (この例では、既に読み込まれます。)  
  
-   オブジェクトを呼び出し元と呼び出し先の両方に既知のインターフェイスにキャストします。 インターフェイスは、呼び出し元のアセンブリまたは呼び出し元と呼び出し先の両方によって参照される 3 つ目のアセンブリに定義されているが場合、に、呼び出されるアセンブリは、呼び出し元のアプリケーション ドメインにアンロードされます。  
  
-   呼び出し元にその型がわかっているときに直接オブジェクトを使用します。 アセンブリは、呼び出し元のアプリケーション ドメインに読み込む必要があります。  
  
 呼び出し元のアプリケーション ドメインに呼び出されるアセンブリの読み込みを回避することもできますが、呼び出し元から派生するは、<xref:System.MarshalByRefObject>クラスと対象のアプリケーション ドメインで実行できるメソッドを定義します。 ターゲット アセンブリが既に対象のアプリケーション ドメインに読み込まれるために、そのメソッドは、ターゲット アセンブリを調べるにリフレクションを使用できます。 例をご覧ください、<xref:System.AppDomain.DynamicDirectory%2A>プロパティ。  
  
 [!code-cpp[System.AppDomain.CreateInstanceFrom_StringString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.appdomain.createinstancefrom_stringstring/cpp/example.cpp#1)]
 [!code-csharp[System.AppDomain.CreateInstanceFrom_StringString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.createinstancefrom_stringstring/cs/example.cs#1)]
 [!code-vb[System.AppDomain.CreateInstanceFrom_StringString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.createinstancefrom_stringstring/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> は <see langword="null" />です。  
  
- または - 
 <paramref name="typeName" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> は見つかりませんでした。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> で、<paramref name="assemblyFile" /> が見つかりませんでした。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作が試行されています。</exception>
        <exception cref="T:System.MissingMethodException">パラメーターなしのパブリック コンストラクターが見つかりませんでした。</exception>
        <exception cref="T:System.MethodAccessException">呼び出し元に、このコンストラクターを呼び出すための十分なアクセス許可がありません。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> は正しいアセンブリではありません。  
  
または 
共通言語ランタイムのバージョン 2.0 以降が現在読み込まれていますが、<paramref name="assemblyFile" /> はさらに新しいバージョンでコンパイルされています。</exception>
        <exception cref="T:System.IO.FileLoadException">1 つのアセンブリまたはモジュールが 2 つの異なる証拠を使用して 2 回読み込まれました。</exception>
        <exception cref="T:System.NullReferenceException">このインスタンスが <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">アセンブリ マニフェストを含むファイルの読み取りに必要なアクセス許可。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">アセンブリがローカルでない場合、アセンブリの場所にアクセスする機能。</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFrom (assemblyFile As String, typeName As String, activationAttributes As Object()) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceFrom : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstanceFrom : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">要求する型を定義しているアセンブリが格納されているファイルの名前 (パスを含む)。 アセンブリは <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> メソッドを使用して読み込まれます。</param>
        <param name="typeName">要求する型の完全修飾名。アセンブリは指定せずに、名前空間だけを指定します。この名前は、<see cref="P:System.Type.FullName" /> プロパティによって返されます。</param>
        <param name="activationAttributes">アクティべーションに参加できる 1 つ以上の属性の配列。 通常、リモート オブジェクトをアクティブ化するために必要な URL を指定する 1 つの <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> オブジェクトを含む配列。  
  
このパラメーターは、クライアント側でアクティブ化されるオブジェクトに関連しています。クライアント アクティベーションは、下位互換性のために残されているレガシ テクノロジです。新規の開発には使用しないでください。 分散アプリケーションは、代わりに Windows Communication Foundation (WCF) を使用する必要があります。</param>
        <summary>指定したアセンブリ ファイルで定義されている、指定した型の新しいインスタンスを作成します。</summary>
        <returns>新しいインスタンスのラッパーであるオブジェクト。<paramref name="typeName" /> が見つからない場合は <see langword="null" />。 実際のオブジェクトにアクセスするには、戻り値のラップを解除する必要があります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既定のコンス トラクター`typeName`が呼び出されます。  
  
 この方法の詳細については、次を参照してください。、<xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>メソッド。  
  
 ときに、<xref:System.AppDomain.CreateInstanceFrom%2A>メソッドは、呼び出しが行われる元のアプリケーション ドメイン以外、対象のアプリケーション ドメインでインスタンスを作成するために使用、アセンブリが対象のアプリケーション ドメインに読み込まれます。 ただし、呼び出し元のアプリケーション ドメインにインスタンスをラップされたない場合は、特定の方法でラップされていないインスタンスを使用して可能性があります、呼び出し元のアプリケーション ドメインに読み込まれるアセンブリ。 たとえば、インスタンスは、ラップされたが、その型の情報を要求する可能性があります、そのメソッドを呼び出すために遅延バインディング。 アセンブリが呼び出し元のアプリケーション ドメインに読み込まれると、例外が発生することができます。  
  
-   呼び出し元のアプリケーション ドメインに同じアセンブリの別のバージョンが以前に読み込まれた場合、または呼び出し元のアプリケーション ドメインの読み込みパスがなど、対象のアプリケーション ドメインを例外と異なる場合<xref:System.MissingMethodException>発生することができます。  
  
-   呼び出し元のアプリケーション ドメインが、インスタンスの型の事前バインディングされた呼び出しを行った場合<xref:System.InvalidCastException>インスタンスのキャストを試行したときにスローされることができます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> は見つかりませんでした。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> で、<paramref name="assemblyFile" /> が見つかりませんでした。</exception>
        <exception cref="T:System.MethodAccessException">呼び出し元に、このコンストラクターを呼び出すための十分なアクセス許可がありません。</exception>
        <exception cref="T:System.MissingMethodException">一致するパブリック コンストラクターが見つかりませんでした。</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.MarshalByRefObject" /> から継承されていないオブジェクトに対して、呼び出し元がアクティベーション属性を与えることはできません。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作が試行されています。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> が有効なアセンブリではありません。  
  
または 
共通言語ランタイムのバージョン 2.0 以降が現在読み込まれていますが、<paramref name="assemblyFile" /> はさらに新しいバージョンでコンパイルされています。</exception>
        <exception cref="T:System.IO.FileLoadException">1 つのアセンブリまたはモジュールが 2 つの異なる証拠を使用して 2 回読み込まれました。</exception>
        <exception cref="T:System.NullReferenceException">このインスタンスが <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">アセンブリ マニフェストを含むファイルの読み取りに必要なアクセス許可。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">アセンブリがローカルでない場合、アセンブリの場所にアクセスする機能。</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFrom : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">要求する型を定義しているアセンブリが格納されているファイルの名前 (パスを含む)。 アセンブリは <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> メソッドを使用して読み込まれます。</param>
        <param name="typeName">要求する型の完全修飾名。アセンブリは指定せずに、名前空間だけを指定します。この名前は、<see cref="P:System.Type.FullName" /> プロパティによって返されます。</param>
        <param name="ignoreCase">検索で大文字と小文字を区別するかどうかを指定する Boolean 値。</param>
        <param name="bindingAttr">
          <paramref name="typeName" /> コンストラクターの検索に影響を与える 0 個以上のビット フラグの組み合わせ。 <paramref name="bindingAttr" /> が 0 の場合は、大文字と小文字を区別してパブリック コンストラクターを検索します。</param>
        <param name="binder">バインディング、引数型の強制変換、メンバーの呼び出し、およびリフレクションを使用した <see cref="T:System.Reflection.MemberInfo" /> オブジェクトの取得を有効にするオブジェクト。 <paramref name="binder" /> が null の場合は、既定のバインダーが使用されます。</param>
        <param name="args">コンストラクターに渡される引数。 この引数の配列は、呼び出すコンストラクターのパラメーターに対して、数、順序、および型を一致させる必要があります。 既定のコンストラクターを優先する場合は、<paramref name="args" /> を空の配列または null にする必要があります。</param>
        <param name="culture">
          <paramref name="args" /> から <paramref name="typeName" /> コンストラクターに対して宣言された仮引数型への強制変換を制御するカルチャ固有の情報。 <paramref name="culture" /> が <see langword="null" /> の場合は、現在のスレッドの <see cref="T:System.Globalization.CultureInfo" /> が使用されます。</param>
        <param name="activationAttributes">アクティべーションに参加できる 1 つ以上の属性の配列。 通常、リモート オブジェクトをアクティブ化するために必要な URL を指定する 1 つの <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> オブジェクトを含む配列。  
  
このパラメーターは、クライアント側でアクティブ化されるオブジェクトに関連しています。 クライアント アクティベーションは、下位互換性のために残されているレガシ テクノロジです。新規の開発には使用しないでください。 分散アプリケーションは、代わりに Windows Communication Foundation (WCF) を使用する必要があります。</param>
        <summary>指定したアセンブリ ファイルで定義されている、指定した型の新しいインスタンスを作成します。</summary>
        <returns>新しいインスタンスのラッパーであるオブジェクト。<paramref name="typeName" /> が見つからない場合は <see langword="null" />。 実際のオブジェクトにアクセスするには、戻り値のラップを解除する必要があります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 詳細については、<xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> メソッドのトピックを参照してください。  
  
 ときに、<xref:System.AppDomain.CreateInstanceFrom%2A>メソッドは、呼び出しが行われる元のアプリケーション ドメイン以外、対象のアプリケーション ドメインでインスタンスを作成するために使用、アセンブリが対象のアプリケーション ドメインに読み込まれます。 ただし、呼び出し元のアプリケーション ドメインにインスタンスをラップされたない場合は、特定の方法でラップされていないインスタンスを使用して可能性があります、呼び出し元のアプリケーション ドメインに読み込まれるアセンブリ。 たとえば、インスタンスは、ラップされたが、その型の情報を要求する可能性があります、そのメソッドを呼び出すために遅延バインディング。 アセンブリが呼び出し元のアプリケーション ドメインに読み込まれると、例外が発生することができます。  
  
-   呼び出し元のアプリケーション ドメインに同じアセンブリの別のバージョンが以前に読み込まれた場合、または呼び出し元のアプリケーション ドメインの読み込みパスがなど、対象のアプリケーション ドメインを例外と異なる場合<xref:System.MissingMethodException>発生することができます。  
  
-   呼び出し元のアプリケーション ドメインが、インスタンスの型の事前バインディングされた呼び出しを行った場合<xref:System.InvalidCastException>インスタンスのキャストを試行したときにスローされることができます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> は <see langword="null" />です。  
  
- または - 
 <paramref name="typeName" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.MarshalByRefObject" /> から継承されていないオブジェクトに対して、呼び出し元がアクティベーション属性を与えることはできません。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作しようとします。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> は見つかりませんでした。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> が <paramref name="assemblyFile" /> に見つかりませんでした。</exception>
        <exception cref="T:System.MissingMethodException">一致するパブリック コンストラクターが見つかりませんでした。</exception>
        <exception cref="T:System.MethodAccessException">呼び出し元には、このコンストラクターを呼び出すために必要なアクセス許可がありません。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> は正しいアセンブリではありません。  
  
または 
 現在読み込まれているバージョンよりも新しいバージョンの共通言語ランタイムで、<paramref name="assemblyFile" /> がコンパイルされました。</exception>
        <exception cref="T:System.IO.FileLoadException">1 つのアセンブリまたはモジュールが 2 つの異なる証拠を使用して 2 回読み込まれました。</exception>
        <exception cref="T:System.NullReferenceException">このインスタンスが <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">アセンブリ マニフェストを含むファイルの読み取りに必要なアクセス許可。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">アセンブリがローカルでない場合、アセンブリの場所にアクセスする機能。</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceFrom : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstanceFrom : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">要求する型を定義しているアセンブリが格納されているファイルの名前 (パスを含む)。 アセンブリは <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> メソッドを使用して読み込まれます。</param>
        <param name="typeName">要求する型の完全修飾名。アセンブリは指定せずに、名前空間だけを指定します。この名前は、<see cref="P:System.Type.FullName" /> プロパティによって返されます。</param>
        <param name="ignoreCase">検索で大文字と小文字を区別するかどうかを指定する Boolean 値。</param>
        <param name="bindingAttr">
          <paramref name="typeName" /> コンストラクターの検索に影響を与える 0 個以上のビット フラグの組み合わせ。 <paramref name="bindingAttr" /> が 0 の場合は、大文字と小文字を区別してパブリック コンストラクターを検索します。</param>
        <param name="binder">バインディング、引数型の強制変換、メンバーの呼び出し、およびリフレクションを使用した <see cref="T:System.Reflection.MemberInfo" /> オブジェクトの取得を有効にするオブジェクト。 <paramref name="binder" /> が null の場合は、既定のバインダーが使用されます。</param>
        <param name="args">コンストラクターに渡される引数。 この引数の配列は、呼び出すコンストラクターのパラメーターに対して、数、順序、および型を一致させる必要があります。 既定のコンストラクターを優先する場合は、<paramref name="args" /> を空の配列または null にする必要があります。</param>
        <param name="culture">
          <paramref name="args" /> から <paramref name="typeName" /> コンストラクターに対して宣言された仮引数型への強制変換を制御するカルチャ固有の情報。 <paramref name="culture" /> が <see langword="null" /> の場合は、現在のスレッドの <see cref="T:System.Globalization.CultureInfo" /> が使用されます。</param>
        <param name="activationAttributes">アクティべーションに参加できる 1 つ以上の属性の配列。 通常、リモート オブジェクトをアクティブ化するために必要な URL を指定する 1 つの <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> オブジェクトを含む配列。  
  
このパラメーターは、クライアント側でアクティブ化されるオブジェクトに関連しています。 クライアント アクティベーションは、下位互換性のために残されているレガシ テクノロジです。新規の開発には使用しないでください。 分散アプリケーションは、代わりに Windows Communication Foundation (WCF) を使用する必要があります。</param>
        <param name="securityAttributes">
          <paramref name="typeName" /> の作成を承認するために使用される情報。</param>
        <summary>指定したアセンブリ ファイルで定義されている、指定した型の新しいインスタンスを作成します。</summary>
        <returns>新しいインスタンスのラッパーであるオブジェクト。<paramref name="typeName" /> が見つからない場合は <see langword="null" />。 実際のオブジェクトにアクセスするには、戻り値のラップを解除する必要があります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この方法の詳細については、次を参照してください。、<xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>メソッド。  
  
 ときに、<xref:System.AppDomain.CreateInstanceFrom%2A>メソッドは、呼び出しが行われる元のアプリケーション ドメイン以外、対象のアプリケーション ドメインでインスタンスを作成するために使用、アセンブリが対象のアプリケーション ドメインに読み込まれます。 ただし、呼び出し元のアプリケーション ドメインにインスタンスをラップされたない場合は、特定の方法でラップされていないインスタンスを使用して可能性があります、呼び出し元のアプリケーション ドメインに読み込まれるアセンブリ。 たとえば、インスタンスは、ラップされたが、その型の情報を要求する可能性があります、そのメソッドを呼び出すために遅延バインディング。 アセンブリが呼び出し元のアプリケーション ドメインに読み込まれると、例外が発生することができます。  
  
-   呼び出し元のアプリケーション ドメインに同じアセンブリの別のバージョンが以前に読み込まれた場合、または呼び出し元のアプリケーション ドメインの読み込みパスがなど、対象のアプリケーション ドメインを例外と異なる場合<xref:System.MissingMethodException>発生することができます。  
  
-   呼び出し元のアプリケーション ドメインが、インスタンスの型の事前バインディングされた呼び出しを行った場合<xref:System.InvalidCastException>インスタンスのキャストを試行したときにスローされることができます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> は <see langword="null" />です。  
  
- または - 
 <paramref name="typeName" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.MarshalByRefObject" /> から継承されていないオブジェクトに対して、呼び出し元がアクティベーション属性を与えることはできません。  
  
または 
 <paramref name="securityAttributes" /> が <see langword="null" /> ではありません。 レガシ CAS ポリシーが有効でない場合は、<paramref name="securityAttributes" /> を <see langword="null" /> にする必要があります。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作が試行されています。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> は見つかりませんでした。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> が <paramref name="assemblyFile" /> に見つかりませんでした。</exception>
        <exception cref="T:System.MissingMethodException">一致するパブリック コンストラクターが見つかりませんでした。</exception>
        <exception cref="T:System.MethodAccessException">呼び出し元には、このコンストラクターを呼び出すために必要なアクセス許可がありません。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> は正しいアセンブリではありません。  
  
または 
共通言語ランタイムのバージョン 2.0 以降が現在読み込まれていますが、<paramref name="assemblyFile" /> はさらに新しいバージョンでコンパイルされています。</exception>
        <exception cref="T:System.IO.FileLoadException">1 つのアセンブリまたはモジュールが 2 つの異なる証拠を使用して 2 回読み込まれました。</exception>
        <exception cref="T:System.NullReferenceException">このインスタンスが <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">アセンブリ マニフェストを含むファイルの読み取りに必要なアクセス許可。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">アセンブリがローカルでない場合、アセンブリの場所にアクセスする機能。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">証拠を提供します。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /> (関連する列挙体)</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceFromAndUnwrap">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定したアセンブリ ファイルで定義されている、指定した型の新しいインスタンスを作成します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFromAndUnwrap (assemblyName As String, typeName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">要求された型を定義するアセンブリのファイル名とパス。</param>
        <param name="typeName">要求する型の完全修飾名。アセンブリは指定せずに、名前空間だけを指定します。この名前は、<see cref="P:System.Type.FullName" /> プロパティによって返されます。</param>
        <summary>指定したアセンブリ ファイルで定義されている、指定した型の新しいインスタンスを作成します。</summary>
        <returns>要求されたオブジェクト。<paramref name="typeName" /> が見つからなかった場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 これは、結合メソッドは<xref:System.AppDomain.CreateInstanceFrom%2A>と<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>します。 このメソッドの既定のコンス トラクターを呼び出す`typeName`します。  
  
 詳細については、<xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> メソッドのトピックを参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> は <see langword="null" />です。  
  
- または - 
 <paramref name="typeName" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作が試行されています。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> は見つかりませんでした。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> で、<paramref name="assemblyName" /> が見つかりませんでした。</exception>
        <exception cref="T:System.MissingMethodException">パラメーターなしのパブリック コンストラクターが見つかりませんでした。</exception>
        <exception cref="T:System.MethodAccessException">呼び出し元に、このコンストラクターを呼び出すための十分なアクセス許可がありません。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> は正しいアセンブリではありません。  
  
または 
共通言語ランタイムのバージョン 2.0 以降が現在読み込まれていますが、<paramref name="assemblyName" /> はさらに新しいバージョンでコンパイルされています。</exception>
        <exception cref="T:System.IO.FileLoadException">1 つのアセンブリまたはモジュールが 2 つの異なる証拠を使用して 2 回読み込まれました。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">アセンブリ マニフェストを含むファイルの読み取りに必要なアクセス許可。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">アセンブリがローカルでない場合、アセンブリの場所にアクセスする機能。</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFromAndUnwrap (assemblyName As String, typeName As String, activationAttributes As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string * obj[] -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyName, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">要求された型を定義するアセンブリのファイル名とパス。</param>
        <param name="typeName">要求する型の完全修飾名。アセンブリは指定せずに、名前空間だけを指定します (<see cref="P:System.Type.FullName" /> プロパティを参照)。</param>
        <param name="activationAttributes">アクティべーションに参加できる 1 つ以上の属性の配列。 通常、リモート オブジェクトをアクティブ化するために必要な URL を指定する 1 つの <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> オブジェクトを含む配列。  
  
このパラメーターは、クライアント側でアクティブ化されるオブジェクトに関連しています。クライアント アクティベーションは、下位互換性のために残されているレガシ テクノロジです。新規の開発には使用しないでください。 分散アプリケーションは、代わりに Windows Communication Foundation (WCF) を使用する必要があります。</param>
        <summary>指定したアセンブリ ファイルで定義されている、指定した型の新しいインスタンスを作成します。</summary>
        <returns>要求されたオブジェクト。<paramref name="typeName" /> が見つからなかった場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 これは、結合メソッドは<xref:System.AppDomain.CreateInstanceFrom%2A>と<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>します。 このメソッドの既定のコンス トラクターを呼び出す`typeName`します。  
  
 この方法の詳細については、次を参照してください。、<xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>メソッド。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> は <see langword="null" />です。  
  
- または - 
 <paramref name="typeName" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.MarshalByRefObject" /> から継承されていないオブジェクトに対して、呼び出し元がアクティベーション属性を与えることはできません。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作しようとします。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> は見つかりませんでした。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> で、<paramref name="assemblyName" /> が見つかりませんでした。</exception>
        <exception cref="T:System.MissingMethodException">パラメーターなしのパブリック コンストラクターが見つかりませんでした。</exception>
        <exception cref="T:System.MethodAccessException">呼び出し元に、このコンストラクターを呼び出すための十分なアクセス許可がありません。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> は正しいアセンブリではありません。  
  
または 
共通言語ランタイムのバージョン 2.0 以降が現在読み込まれていますが、<paramref name="assemblyName" /> はさらに新しいバージョンでコンパイルされています。</exception>
        <exception cref="T:System.IO.FileLoadException">1 つのアセンブリまたはモジュールが 2 つの異なる証拠を使用して 2 回読み込まれました。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">アセンブリ マニフェストを含むファイルの読み取りに必要なアクセス許可。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">アセンブリがローカルでない場合、アセンブリの場所にアクセスする機能。</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">要求された型を定義するアセンブリのファイル名とパス。</param>
        <param name="typeName">要求する型の完全修飾名。アセンブリは指定せずに、名前空間だけを指定します。この名前は、<see cref="P:System.Type.FullName" /> プロパティによって返されます。</param>
        <param name="ignoreCase">検索で大文字と小文字を区別するかどうかを指定する Boolean 値。</param>
        <param name="bindingAttr">
          <paramref name="typeName" /> コンストラクターの検索に影響を与える 0 個以上のビット フラグの組み合わせ。 <paramref name="bindingAttr" /> が 0 の場合は、大文字と小文字を区別してパブリック コンストラクターを検索します。</param>
        <param name="binder">バインディング、引数型の強制変換、メンバーの呼び出し、およびリフレクションを使用した <see cref="T:System.Reflection.MemberInfo" /> オブジェクトの取得を有効にするオブジェクト。 <paramref name="binder" /> が null の場合は、既定のバインダーが使用されます。</param>
        <param name="args">コンストラクターに渡される引数。 この引数の配列は、呼び出すコンストラクターのパラメーターに対して、数、順序、および型を一致させる必要があります。 既定のコンストラクターを優先する場合は、<paramref name="args" /> を空の配列または null にする必要があります。</param>
        <param name="culture">
          <paramref name="args" /> から <paramref name="typeName" /> コンストラクターに対して宣言された仮引数型への強制変換を制御するカルチャ固有の情報。 <paramref name="culture" /> が <see langword="null" /> の場合は、現在のスレッドの <see cref="T:System.Globalization.CultureInfo" /> が使用されます。</param>
        <param name="activationAttributes">アクティべーションに参加できる 1 つ以上の属性の配列。 通常、リモート オブジェクトをアクティブ化するために必要な URL を指定する 1 つの <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> オブジェクトを含む配列。  
  
このパラメーターは、クライアント側でアクティブ化されるオブジェクトに関連しています。 クライアント アクティベーションは、下位互換性のために残されているレガシ テクノロジです。新規の開発には使用しないでください。 分散アプリケーションは、代わりに Windows Communication Foundation (WCF) を使用する必要があります。</param>
        <summary>指定したアセンブリ ファイルで定義されている、指定した型の新しいインスタンスを作成します。型名の大文字と小文字の区別を無視するかどうか、作成する型を選択するために使用されるバインディング属性とバインダー、コンストラクターの引数、カルチャ、およびアクティベーション属性を指定します。</summary>
        <returns>要求されたオブジェクト。<paramref name="typeName" /> が見つからなかった場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 これは、結合メソッドは<xref:System.AppDomain.CreateInstanceFrom%2A>と<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>します。  
  
 この方法の詳細については、次を参照してください。、<xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>メソッド。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> は <see langword="null" />です。  
  
- または - 
 <paramref name="typeName" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.MarshalByRefObject" /> から継承されていないオブジェクトに対して、呼び出し元がアクティベーション属性を与えることはできません。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作しようとします。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> は見つかりませんでした。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> が <paramref name="assemblyName" /> に見つかりませんでした。</exception>
        <exception cref="T:System.MissingMethodException">一致するパブリック コンストラクターが見つかりませんでした。</exception>
        <exception cref="T:System.MethodAccessException">呼び出し元には、このコンストラクターを呼び出すために必要なアクセス許可がありません。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> は正しいアセンブリではありません。  
  
または 
 現在読み込まれているバージョンよりも新しいバージョンの共通言語ランタイムで、<paramref name="assemblyName" /> がコンパイルされました。</exception>
        <exception cref="T:System.IO.FileLoadException">1 つのアセンブリまたはモジュールが 2 つの異なる証拠を使用して 2 回読み込まれました。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">アセンブリ マニフェストを含むファイルの読み取りに必要なアクセス許可。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">アセンブリがローカルでない場合、アセンブリの場所にアクセスする機能。</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceFromAndUnwrap which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName">要求された型を定義するアセンブリのファイル名とパス。</param>
        <param name="typeName">要求する型の完全修飾名。アセンブリは指定せずに、名前空間だけを指定します。この名前は、<see cref="P:System.Type.FullName" /> プロパティによって返されます。</param>
        <param name="ignoreCase">検索で大文字と小文字を区別するかどうかを指定する Boolean 値。</param>
        <param name="bindingAttr">
          <paramref name="typeName" /> コンストラクターの検索に影響を与える 0 個以上のビット フラグの組み合わせ。 <paramref name="bindingAttr" /> が 0 の場合は、大文字と小文字を区別してパブリック コンストラクターを検索します。</param>
        <param name="binder">バインディング、引数型の強制変換、メンバーの呼び出し、およびリフレクションを使用した <see cref="T:System.Reflection.MemberInfo" /> オブジェクトの取得を有効にするオブジェクト。 <paramref name="binder" /> が null の場合は、既定のバインダーが使用されます。</param>
        <param name="args">コンストラクターに渡される引数。 この引数の配列は、呼び出すコンストラクターのパラメーターに対して、数、順序、および型を一致させる必要があります。 既定のコンストラクターを優先する場合は、<paramref name="args" /> を空の配列または null にする必要があります。</param>
        <param name="culture">
          <paramref name="args" /> から <paramref name="typeName" /> コンストラクターに対して宣言された仮引数型への強制変換を制御するカルチャ固有の情報。 <paramref name="culture" /> が <see langword="null" /> の場合は、現在のスレッドの <see cref="T:System.Globalization.CultureInfo" /> が使用されます。</param>
        <param name="activationAttributes">アクティべーションに参加できる 1 つ以上の属性の配列。 通常、リモート オブジェクトをアクティブ化するために必要な URL を指定する 1 つの <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> オブジェクトを含む配列。  
  
このパラメーターは、クライアント側でアクティブ化されるオブジェクトに関連しています。 クライアント アクティベーションは、下位互換性のために残されているレガシ テクノロジです。新規の開発には使用しないでください。 分散アプリケーションは、代わりに Windows Communication Foundation (WCF) を使用する必要があります。</param>
        <param name="securityAttributes">
          <paramref name="typeName" /> の作成を承認するために使用される情報。</param>
        <summary>指定したアセンブリ ファイルで定義されている、指定した型の新しいインスタンスを作成します。</summary>
        <returns>要求されたオブジェクト。<paramref name="typeName" /> が見つからなかった場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 これは、結合メソッドは<xref:System.AppDomain.CreateInstanceFrom%2A>と<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>します。  
  
 この方法の詳細については、次を参照してください。、<xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>メソッド。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> は <see langword="null" />です。  
  
- または - 
 <paramref name="typeName" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.MarshalByRefObject" /> から継承されていないオブジェクトに対して、呼び出し元がアクティベーション属性を与えることはできません。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作しようとします。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> は見つかりませんでした。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> が <paramref name="assemblyName" /> に見つかりませんでした。</exception>
        <exception cref="T:System.MissingMethodException">一致するパブリック コンストラクターが見つかりませんでした。</exception>
        <exception cref="T:System.MethodAccessException">呼び出し元には、このコンストラクターを呼び出すために必要なアクセス許可がありません。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> は正しいアセンブリではありません。  
  
または 
共通言語ランタイムのバージョン 2.0 以降が現在読み込まれていますが、<paramref name="assemblyName" /> はさらに新しいバージョンでコンパイルされています。</exception>
        <exception cref="T:System.IO.FileLoadException">1 つのアセンブリまたはモジュールが 2 つの異なる証拠を使用して 2 回読み込まれました。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">アセンブリ マニフェストを含むファイルの読み取りに必要なアクセス許可。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">アセンブリがローカルでない場合、アセンブリの場所にアクセスする機能。</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CurrentDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CurrentDomain { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.AppDomain CurrentDomain" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.CurrentDomain" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentDomain As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property AppDomain ^ CurrentDomain { AppDomain ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentDomain : AppDomain" Usage="System.AppDomain.CurrentDomain" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.Threading.Thread" /> に対する現在のアプリケーション ドメインを取得します。</summary>
        <value>現在のアプリケーション ドメイン。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例では、新しいアプリケーション ドメインを作成します。 <xref:System.AppDomain.CurrentDomain%2A>プロパティを使用して、取得、<xref:System.AppDomain>現在のアプリケーション ドメインを表すオブジェクト。 <xref:System.AppDomain.FriendlyName%2A>プロパティは、コマンドラインで表示される現在のアプリケーション ドメインの名前を提供します。  
  
 [!code-cpp[ADApplicationBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADApplicationBase/CPP/adapplicationbase.cpp#1)]
 [!code-csharp[ADApplicationBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADApplicationBase/CS/adapplicationbase.cs#1)]
 [!code-vb[ADApplicationBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADApplicationBase/VB/adapplicationbase.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineDynamicAssembly">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在のアプリケーション ドメインで動的アセンブリを定義します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
      </Parameters>
      <Docs>
        <param name="name">動的アセンブリの一意の ID。</param>
        <param name="access">動的アセンブリのアクセス モード。</param>
        <summary>名前とアクセス モードを指定して、動的アセンブリを定義します。</summary>
        <returns>名前とアクセス モードが指定された動的アセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、現在のアプリケーション ドメインで、動的アセンブリを定義するのみ使用する必要があります。 詳細については、次を参照してください。、<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>メソッドのオーバー ロードします。  
  
> [!NOTE]
>  動的アセンブリを生成するコードの開発中はお勧めのオーバー ロードを使用すること、<xref:System.AppDomain.DefineDynamicAssembly%2A>証拠、アクセス許可を指定するメソッドを含む動的アセンブリを作成証拠を指定する<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType>で`refusedPermissions`. 含む<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification>で、`refusedPermissions`パラメーターは、MSIL が検証されていることを保証します。 この技法の制限はまた、ある<xref:System.Security.SecurityException>完全な信頼を要求するコードで使用する場合にスローされます。  
  
   
  
## Examples  
 次のサンプルでは、<xref:System.AppDomain.DefineDynamicAssembly%2A>メソッドと<xref:System.AppDomain.AssemblyResolve>イベント。  
  
 このコード例を実行するには、完全修飾アセンブリ名を指定する必要があります。 完全修飾アセンブリ名を取得する方法については、次を参照してください。[アセンブリ名](~/docs/framework/app-domains/assembly-names.md)します。  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> の <see langword="Name" /> プロパティが <see langword="null" /> です。  
  
または 
<paramref name="name" /> の <see langword="Name" /> プロパティが空白文字で始まるか、スラッシュまたはバック スラッシュを含んでいます。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作が試行されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, assemblyAttributes As IEnumerable(Of CustomAttributeBuilder)) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes);" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * seq&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, assemblyAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
      </Parameters>
      <Docs>
        <param name="name">動的アセンブリの一意の ID。</param>
        <param name="access">動的アセンブリのアクセス モード。</param>
        <param name="assemblyAttributes">アセンブリに適用される属性を列挙した一覧。属性がない場合は <see langword="null" />。</param>
        <summary>名前、アクセス モード、およびカスタム属性を指定して、動的アセンブリを定義します。</summary>
        <returns>名前と機能が指定された動的アセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドのオーバー ロードを使用すると、動的アセンブリの作成時に適用しない限り、正しく動作していない属性を指定できます。 たとえば、セキュリティなどの属性<xref:System.Security.SecurityTransparentAttribute>と<xref:System.Security.SecurityCriticalAttribute>動的アセンブリが作成された後に追加されている場合に正常に機能しません。  
  
 このメソッドは、現在のアプリケーション ドメインで、動的アセンブリを定義するときだけ使用する必要があります。 この制限の詳細については、次を参照してください。、<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>メソッドのオーバー ロードします。  
  
 このメソッドのオーバー ロードがで導入された、[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]します。  
  
   
  
## Examples  
 次のコード サンプルを含む動的アセンブリを作成する方法を示しています、<xref:System.Security.SecurityTransparentAttribute>します。 属性の配列の要素として指定する必要があります<xref:System.Reflection.Emit.CustomAttributeBuilder>オブジェクト。  
  
 最初の手順で作成、<xref:System.Reflection.Emit.CustomAttributeBuilder>では、属性のコンス トラクターを取得します。 コンス トラクターは、パラメーターを持たないため、<xref:System.Type.GetConstructor%2A>の空の配列メソッドが呼び出された<xref:System.Type>パラメーターの型を表すオブジェクト。 2 番目の手順では、その結果を渡す<xref:System.Reflection.ConstructorInfo>オブジェクトのコンス トラクターを<xref:System.Reflection.Emit.CustomAttributeBuilder>クラス、型の空の配列と共に<xref:System.Object>に引数を表します。  
  
 結果の<xref:System.Reflection.Emit.CustomAttributeBuilder>に渡されますが、<xref:System.AppDomain.DefineDynamicAssembly%2A>メソッドとして、配列の唯一の要素。  
  
 コード例では、新しい動的アセンブリにモジュールと型を定義し、アセンブリの属性を表示します。  
  
 [!code-cpp[DefineDynamicAssemblyWithAttributes#1](~/samples/snippets/cpp/VS_Snippets_CLR/DefineDynamicAssemblyWithAttributes/cpp/source.cpp#1)]
 [!code-csharp[DefineDynamicAssemblyWithAttributes#1](~/samples/snippets/csharp/VS_Snippets_CLR/DefineDynamicAssemblyWithAttributes/cs/source.cs#1)]
 [!code-vb[DefineDynamicAssemblyWithAttributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DefineDynamicAssemblyWithAttributes/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> の <see langword="Name" /> プロパティが <see langword="null" /> です。  
  
または 
<paramref name="name" /> の <see langword="Name" /> プロパティが空白で始まっているか、スラッシュまたは円記号が含まれています。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作が試行されています。</exception>
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Security::Policy::Evidence ^ evidence);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, evidence)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default.  See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="name">動的アセンブリの一意の ID。</param>
        <param name="access">動的アセンブリにアクセスするときのモード。</param>
        <param name="evidence">動的アセンブリに指定する証拠。 証拠は、ポリシーの解決に使用する証拠の最終セットを変更されないために使用されます。</param>
        <summary>名前、アクセス モード、および証拠を指定して、動的アセンブリを定義します。</summary>
        <returns>名前と機能が指定された動的アセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 のみ完全に信頼された呼び出し元を指定できます、`evidence`動的を定義するときに<xref:System.Reflection.Assembly>します。 マップは、ランタイム、<xref:System.Security.Policy.Evidence>付与されたアクセス許可を決定するセキュリティ ポリシーを使用します。 呼び出し元は、null を指定する必要がありますを部分的に信頼された`evidence`します。 場合`evidence`は`null`、ランタイムによってアクセス許可セットがコピー、現在の付与とから呼び出し元のセットを拒否<xref:System.Reflection.Assembly>を動的<xref:System.Reflection.Assembly>定義されていると、ポリシーを解決済みとしてマークします。  
  
 場合、動的<xref:System.Reflection.Assembly>がディスクに保存すると、その後の読み込みは、場所に関連付けられたポリシーに基づいて付与を取得は場所、<xref:System.Reflection.Assembly>が保存されました。  
  
 このメソッドは、現在のアプリケーション ドメインで、動的アセンブリを定義するのみ使用する必要があります。 詳細については、次を参照してください。、<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>メソッドのオーバー ロードします。  
  
> [!NOTE]
>  動的アセンブリを生成するコードの開発中はお勧めのオーバー ロードを使用すること、<xref:System.AppDomain.DefineDynamicAssembly%2A>証拠、アクセス許可を指定するメソッドを含む動的アセンブリを作成証拠を指定する<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType>で`refusedPermissions`. 含む<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification>で、`refusedPermissions`パラメーターは、MSIL が検証されていることを保証します。 この技法の制限はまた、ある<xref:System.Security.SecurityException>完全な信頼を要求するコードで使用する場合にスローされます。  
  
   
  
## Examples  
 次のサンプルでは、<xref:System.AppDomain.DefineDynamicAssembly%2A>メソッドと<xref:System.AppDomain.AssemblyResolve>イベント。  
  
 最初に、コード例がのインスタンスを作成しよう`MyDynamicType`呼び出すことによって、<xref:System.AppDomain.CreateInstance%2A>メソッドは無効なアセンブリ名、および結果の例外をキャッチします。  
  
 コード例のイベント ハンドラーを追加し、<xref:System.AppDomain.AssemblyResolve>イベント、もう一度のインスタンスを作成しようと`MyDynamicType`します。 呼び出し中に<xref:System.AppDomain.CreateInstance%2A>、<xref:System.AppDomain.AssemblyResolve>無効なアセンブリのイベントが発生します。 イベント ハンドラーは、という名前の型を含む動的アセンブリを作成します。 `MyDynamicType`、型、パラメーターなしのコンス トラクターを提供し、新しい動的アセンブリを返します。 呼び出し<xref:System.AppDomain.CreateInstance%2A>、正常に終了した後のコンス トラクターと`MyDynamicType`コンソールにメッセージが表示されます。  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> の <see langword="Name" /> プロパティが <see langword="null" /> です。  
  
または 
<paramref name="name" /> の <see langword="Name" /> プロパティが空白文字で始まるか、スラッシュまたはバック スラッシュを含んでいます。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作が試行されています。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">証拠とアセンブリの読み込み。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /> (関連する列挙体)</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, dir As String) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">動的アセンブリの一意の ID。</param>
        <param name="access">動的アセンブリにアクセスするときのモード。</param>
        <param name="dir">アセンブリを保存するディレクトリの名前。 <paramref name="dir" /> が <see langword="null" /> の場合は、現在のディレクトリが既定で使用されます。</param>
        <summary>名前、アクセス モード、およびストレージ ディレクトリを指定して、動的アセンブリを定義します。</summary>
        <returns>名前と機能が指定された動的アセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、現在のアプリケーション ドメインで、動的アセンブリを定義するのみ使用する必要があります。 詳細については、次を参照してください。、<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>メソッドのオーバー ロードします。  
  
> [!NOTE]
>  動的アセンブリを生成するコードの開発中はお勧めのオーバー ロードを使用すること、<xref:System.AppDomain.DefineDynamicAssembly%2A>証拠、アクセス許可を指定するメソッドを含む動的アセンブリを作成証拠を指定する<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType>で`refusedPermissions`. 含む<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification>で、`refusedPermissions`パラメーターは、MSIL が検証されていることを保証します。 この技法の制限はまた、ある<xref:System.Security.SecurityException>完全な信頼を要求するコードで使用する場合にスローされます。  
  
   
  
## Examples  
 次のサンプルでは、<xref:System.AppDomain.DefineDynamicAssembly%2A>メソッドと<xref:System.AppDomain.AssemblyResolve>イベント。  
  
 このコード例を実行するには、完全修飾アセンブリ名を指定する必要があります。 完全修飾アセンブリ名を取得する方法については、次を参照してください。[アセンブリ名](~/docs/framework/app-domains/assembly-names.md)します。  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> の <see langword="Name" /> プロパティが <see langword="null" /> です。  
  
または 
<paramref name="name" /> の <see langword="Name" /> プロパティが空白文字で始まるか、スラッシュまたはバック スラッシュを含んでいます。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作が試行されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes, System.Security.SecurityContextSource securityContextSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes, valuetype System.Security.SecurityContextSource securityContextSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes, System::Security::SecurityContextSource securityContextSource);" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * seq&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; * System.Security.SecurityContextSource -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, assemblyAttributes, securityContextSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
        <Parameter Name="securityContextSource" Type="System.Security.SecurityContextSource" />
      </Parameters>
      <Docs>
        <param name="name">動的アセンブリの一意の ID。</param>
        <param name="access">動的アセンブリのアクセス モード。</param>
        <param name="assemblyAttributes">アセンブリに適用される属性を列挙した一覧。属性がない場合は <see langword="null" />。</param>
        <param name="securityContextSource">セキュリティ コンテキストのソース。</param>
        <summary>名前、アクセス モード、カスタム属性、およびセキュリティ コンテキストのソースを指定して、動的アセンブリを定義します。</summary>
        <returns>名前と機能が指定された動的アセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドのオーバー ロードを使用すると、動的アセンブリの作成時に適用しない限り、正しく動作していない属性を指定できます。 たとえば、セキュリティなどの属性<xref:System.Security.SecurityTransparentAttribute>と<xref:System.Security.SecurityCriticalAttribute>動的アセンブリが作成された後に追加されている場合に正常に機能しません。  
  
 このメソッドは、現在のアプリケーション ドメインで、動的アセンブリを定義するときだけ使用する必要があります。 この制限の詳細については、次を参照してください。、<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>メソッドのオーバー ロードします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> の <see langword="Name" /> プロパティが <see langword="null" /> です。  
  
または 
<paramref name="name" /> の <see langword="Name" /> プロパティが空白で始まっているか、スラッシュまたは円記号が含まれています。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作が試行されています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="securityContextSource" /> の値が列挙値ではありませんでした。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of DefineDynamicAssembly which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkId=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="name">動的アセンブリの一意の ID。</param>
        <param name="access">動的アセンブリにアクセスするときのモード。</param>
        <param name="dir">アセンブリを保存するディレクトリの名前。 <paramref name="dir" /> が <see langword="null" /> の場合は、現在のディレクトリが既定で使用されます。</param>
        <param name="evidence">動的アセンブリに指定する証拠。 証拠は、ポリシーの解決に使用する証拠の最終セットを変更されないために使用されます。</param>
        <summary>名前、アクセス モード、ストレージ ディレクトリ、および証拠を指定して、動的アセンブリを定義します。</summary>
        <returns>名前と機能が指定された動的アセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 のみ完全に信頼された呼び出し元を指定できます、`evidence`動的を定義するときに<xref:System.Reflection.Assembly>します。 マップは、ランタイム、<xref:System.Security.Policy.Evidence>付与されたアクセス許可を決定するセキュリティ ポリシーを使用します。 呼び出し元は、null を指定する必要がありますを部分的に信頼された`evidence`します。 場合`evidence`は`null`、ランタイムによってアクセス許可セットがコピー、現在の付与とから呼び出し元のセットを拒否<xref:System.Reflection.Assembly>を動的<xref:System.Reflection.Assembly>定義されていると、ポリシーを解決済みとしてマークします。  
  
 場合、動的<xref:System.Reflection.Assembly>がディスクに保存すると、その後の読み込みは、場所に関連付けられたポリシーに基づいて付与を取得は場所、<xref:System.Reflection.Assembly>が保存されました。  
  
 このメソッドは、現在のアプリケーション ドメインで、動的アセンブリを定義するのみ使用する必要があります。 詳細については、次を参照してください。、<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>メソッドのオーバー ロードします。  
  
> [!NOTE]
>  動的アセンブリを生成するコードの開発中はお勧めのオーバー ロードを使用すること、<xref:System.AppDomain.DefineDynamicAssembly%2A>証拠、アクセス許可を指定するメソッドを含む動的アセンブリを作成証拠を指定する<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType>で`refusedPermissions`. 含む<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification>で、`refusedPermissions`パラメーターは、MSIL が検証されていることを保証します。 この技法の制限はまた、ある<xref:System.Security.SecurityException>完全な信頼を要求するコードで使用する場合にスローされます。  
  
   
  
## Examples  
 次のサンプルでは、<xref:System.AppDomain.DefineDynamicAssembly%2A>メソッドと<xref:System.AppDomain.AssemblyResolve>イベント。  
  
 このコード例を実行するには、完全修飾アセンブリ名を指定する必要があります。 完全修飾アセンブリ名を取得する方法については、次を参照してください。[アセンブリ名](~/docs/framework/app-domains/assembly-names.md)します。  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> の <see langword="Name" /> プロパティが <see langword="null" /> です。  
  
または 
<paramref name="name" /> の <see langword="Name" /> プロパティが空白文字で始まるか、スラッシュまたはバック スラッシュを含んでいます。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作が試行されています。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">証拠とアセンブリの読み込み。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /> (関連する列挙体)</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, requiredPermissions As PermissionSet, optionalPermissions As PermissionSet, refusedPermissions As PermissionSet) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, requiredPermissions, optionalPermissions, refusedPermissions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default.  See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name">動的アセンブリの一意の ID。</param>
        <param name="access">動的アセンブリにアクセスするときのモード。</param>
        <param name="requiredPermissions">必須のアクセス許可要求。</param>
        <param name="optionalPermissions">オプションのアクセス許可要求。</param>
        <param name="refusedPermissions">拒否されたアクセス許可要求。</param>
        <summary>名前、アクセス モード、およびアクセス許可要求を指定して、動的アセンブリを定義します。</summary>
        <returns>名前と機能が指定された動的アセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定されたアクセス許可要求`requiredPermissions`、 `optionalPermissions`、および`refusedPermissions`動的アセンブリに保存され、メモリに再読み込みしない限りは使用されません。 ディスクのオーバー ロードを使用することはありません保存されている一時アセンブリのアクセス許可要求を指定する、<xref:System.AppDomain.DefineDynamicAssembly%2A>メソッドも、要求されたアクセス許可、および供給としての証拠を示す、<xref:System.Security.Policy.Evidence>オブジェクト。  
  
> [!NOTE]
>  動的アセンブリを生成するコードの開発中はお勧めのオーバー ロードを使用すること、<xref:System.AppDomain.DefineDynamicAssembly%2A>証拠、アクセス許可を指定するメソッドを含む動的アセンブリを作成証拠を指定する<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType>で`refusedPermissions`. 含む<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification>で、`refusedPermissions`パラメーターは、MSIL が検証されていることを保証します。 この技法の制限はまた、ある<xref:System.Security.SecurityException>完全な信頼を要求するコードで使用する場合にスローされます。  
  
 このメソッドは、現在のアプリケーション ドメインで、動的アセンブリを定義するのみ使用する必要があります。 詳細については、次を参照してください。、<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>メソッドのオーバー ロードします。  
  
   
  
## Examples  
 次のサンプルでは、<xref:System.AppDomain.DefineDynamicAssembly%2A>メソッドと<xref:System.AppDomain.AssemblyResolve>イベント。  
  
 このコード例を実行するには、完全修飾アセンブリ名を指定する必要があります。 完全修飾アセンブリ名を取得する方法については、次を参照してください。[アセンブリ名](~/docs/framework/app-domains/assembly-names.md)します。  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> の <see langword="Name" /> プロパティが <see langword="null" /> です。  
  
または 
<paramref name="name" /> の <see langword="Name" /> プロパティが空白文字で始まるか、スラッシュまたはバック スラッシュを含んでいます。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作が試行されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, bool isSynchronized, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, bool isSynchronized, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, dir As String, isSynchronized As Boolean, assemblyAttributes As IEnumerable(Of CustomAttributeBuilder)) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, bool isSynchronized, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes);" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * bool * seq&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, isSynchronized, assemblyAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="isSynchronized" Type="System.Boolean" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
      </Parameters>
      <Docs>
        <param name="name">動的アセンブリの一意の ID。</param>
        <param name="access">動的アセンブリにアクセスするときのモード。</param>
        <param name="dir">動的アセンブリを保存するディレクトリの名前。 <paramref name="dir" /> が <see langword="null" /> の場合、現在のディレクトリが使用されます。</param>
        <param name="isSynchronized">動的アセンブリ内のモジュール、型、およびメンバーの作成を同期する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <param name="assemblyAttributes">アセンブリに適用される属性を列挙した一覧。属性がない場合は <see langword="null" />。</param>
        <summary>名前、アクセス モード、ストレージ ディレクトリ、および同期オプションを指定して、動的アセンブリを定義します。</summary>
        <returns>名前と機能が指定された動的アセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドのオーバー ロードを使用すると、動的アセンブリの作成時に適用しない限り、正しく動作していない属性を指定できます。 たとえば、セキュリティなどの属性<xref:System.Security.SecurityTransparentAttribute>と<xref:System.Security.SecurityCriticalAttribute>動的アセンブリが作成された後に追加されている場合に正常に機能しません。  
  
 場合`isSynchronized`は`true`、結果の次のメソッド<xref:System.Reflection.Emit.AssemblyBuilder>を同期する: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>、 <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>、 <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>、 <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>、 <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>、および<xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>します。 これらのメソッドの 2 つは、異なるスレッドで呼び出されると、もう一方が完了するまで 1 つブロックされます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> の <see langword="Name" /> プロパティが <see langword="null" /> です。  
  
または 
<paramref name="name" /> の <see langword="Name" /> プロパティが空白で始まっているか、スラッシュまたは円記号が含まれています。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作が試行されています。</exception>
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, evidence, requiredPermissions, optionalPermissions, refusedPermissions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name">動的アセンブリの一意の ID。</param>
        <param name="access">動的アセンブリにアクセスするときのモード。</param>
        <param name="evidence">動的アセンブリに指定する証拠。 証拠は、ポリシーの解決に使用する証拠の最終セットを変更されないために使用されます。</param>
        <param name="requiredPermissions">必須のアクセス許可要求。</param>
        <param name="optionalPermissions">オプションのアクセス許可要求。</param>
        <param name="refusedPermissions">拒否されたアクセス許可要求。</param>
        <summary>名前、アクセス モード、証拠、およびアクセス許可要求を指定して、動的アセンブリを定義します。</summary>
        <returns>名前と機能が指定された動的アセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定されたアクセス許可要求`requiredPermissions`、`optionalPermissions`と`refusedPermissions`場合にだけ使用`evidence`が指定されても、または動的アセンブリが保存され、メモリに再度読み込まれる場合。  
  
> [!NOTE]
>  動的アセンブリを生成するコードの開発中をお勧めを含めるように<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType>で`refusedPermissions`します。 含む<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification>で、`refusedPermissions`パラメーターは、MSIL が検証されていることを保証します。 この技法の制限はまた、ある<xref:System.Security.SecurityException>完全な信頼を要求するコードで使用する場合にスローされます。  
  
 のみ完全に信頼された呼び出し元を指定できます、`evidence`動的を定義するときに<xref:System.Reflection.Assembly>します。 マップは、ランタイム、<xref:System.Security.Policy.Evidence>付与されたアクセス許可を決定するセキュリティ ポリシーを使用します。 呼び出し元は、null を指定する必要がありますを部分的に信頼された`evidence`します。 場合`evidence`は`null`、ランタイムによってアクセス許可セットがコピー、現在の付与とから呼び出し元のセットを拒否<xref:System.Reflection.Assembly>を動的<xref:System.Reflection.Assembly>定義されていると、ポリシーを解決済みとしてマークします。  
  
 場合、動的<xref:System.Reflection.Assembly>がディスクに保存すると、その後の読み込みは、場所に関連付けられたポリシーに基づいて付与を取得は場所、<xref:System.Reflection.Assembly>が保存されました。  
  
 このメソッドは、現在のアプリケーション ドメインで、動的アセンブリを定義するのみ使用する必要があります。 詳細については、次を参照してください。、<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>メソッドのオーバー ロードします。  
  
   
  
## Examples  
 次のサンプルでは、<xref:System.AppDomain.DefineDynamicAssembly%2A>メソッドと<xref:System.AppDomain.AssemblyResolve>イベント。  
  
 このコード例を実行するには、完全修飾アセンブリ名を指定する必要があります。 完全修飾アセンブリ名を取得する方法については、次を参照してください。[アセンブリ名](~/docs/framework/app-domains/assembly-names.md)します。  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> の <see langword="Name" /> プロパティが <see langword="null" /> です。  
  
または 
<paramref name="name" /> の <see langword="Name" /> プロパティが空白文字で始まるか、スラッシュまたはバック スラッシュを含んでいます。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作が試行されています。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">証拠とアセンブリの読み込み。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /> (関連する列挙体)</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, dir As String, requiredPermissions As PermissionSet, optionalPermissions As PermissionSet, refusedPermissions As PermissionSet) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, requiredPermissions, optionalPermissions, refusedPermissions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name">動的アセンブリの一意の ID。</param>
        <param name="access">動的アセンブリにアクセスするときのモード。</param>
        <param name="dir">アセンブリを保存するディレクトリの名前。 <paramref name="dir" /> が <see langword="null" /> の場合は、現在のディレクトリが既定で使用されます。</param>
        <param name="requiredPermissions">必須のアクセス許可要求。</param>
        <param name="optionalPermissions">オプションのアクセス許可要求。</param>
        <param name="refusedPermissions">拒否されたアクセス許可要求。</param>
        <summary>名前、アクセス モード、ストレージ ディレクトリ、およびアクセス許可要求を指定して、動的アセンブリを定義します。</summary>
        <returns>名前と機能が指定された動的アセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定されたアクセス許可要求`requiredPermissions`、 `optionalPermissions`、および`refusedPermissions`動的アセンブリに保存され、メモリに再読み込みしない限りは使用されません。 ディスクのオーバー ロードを使用することはありません保存されている一時アセンブリのアクセス許可要求を指定する、<xref:System.AppDomain.DefineDynamicAssembly%2A>メソッドも、要求されたアクセス許可、および供給としての証拠を示す、<xref:System.Security.Policy.Evidence>オブジェクト。  
  
> [!NOTE]
>  動的アセンブリを生成するコードの開発中はお勧めのオーバー ロードを使用すること、<xref:System.AppDomain.DefineDynamicAssembly%2A>証拠、アクセス許可を指定するメソッドを含む動的アセンブリを作成証拠を指定する<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType>で`refusedPermissions`. 含む<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification>で、`refusedPermissions`パラメーターは、MSIL が検証されていることを保証します。 この技法の制限はまた、ある<xref:System.Security.SecurityException>完全な信頼を要求するコードで使用する場合にスローされます。  
  
 このメソッドは、現在のアプリケーション ドメインで、動的アセンブリを定義するのみ使用する必要があります。 詳細については、次を参照してください。、<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>メソッドのオーバー ロードします。  
  
   
  
## Examples  
 次のサンプルでは、<xref:System.AppDomain.DefineDynamicAssembly%2A>メソッドと<xref:System.AppDomain.AssemblyResolve>イベント。  
  
 このコード例を実行するには、完全修飾アセンブリ名を指定する必要があります。 完全修飾アセンブリ名を取得する方法については、次を参照してください。[アセンブリ名](~/docs/framework/app-domains/assembly-names.md)します。  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> の <see langword="Name" /> プロパティが <see langword="null" /> です。  
  
または 
<paramref name="name" /> の <see langword="Name" /> プロパティが空白文字で始まるか、スラッシュまたはバック スラッシュを含んでいます。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作が試行されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence, requiredPermissions, optionalPermissions, refusedPermissions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default.  Please see http://go.microsoft.com/fwlink/?LinkId=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name">動的アセンブリの一意の ID。</param>
        <param name="access">動的アセンブリにアクセスするときのモード。</param>
        <param name="dir">アセンブリを保存するディレクトリの名前。 <paramref name="dir" /> が <see langword="null" /> の場合は、現在のディレクトリが既定で使用されます。</param>
        <param name="evidence">動的アセンブリに指定する証拠。 証拠は、ポリシーの解決に使用する証拠の最終セットを変更されないために使用されます。</param>
        <param name="requiredPermissions">必須のアクセス許可要求。</param>
        <param name="optionalPermissions">オプションのアクセス許可要求。</param>
        <param name="refusedPermissions">拒否されたアクセス許可要求。</param>
        <summary>名前、アクセス モード、ストレージ ディレクトリ、証拠、およびアクセス許可要求を指定して、動的アセンブリを定義します。</summary>
        <returns>名前と機能が指定された動的アセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定されたアクセス許可要求`requiredPermissions`、`optionalPermissions`と`refusedPermissions`場合にだけ使用`evidence`が指定されても、または動的アセンブリが保存され、メモリに再度読み込まれる場合。  
  
> [!NOTE]
>  動的アセンブリを生成するコードの開発中をお勧めを含めるように<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType>で`refusedPermissions`します。 含む<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification>で、`refusedPermissions`パラメーターは、MSIL が検証されていることを保証します。 この技法の制限はまた、ある<xref:System.Security.SecurityException>完全な信頼を要求するコードで使用する場合にスローされます。  
  
 のみ完全に信頼された呼び出し元を指定できます、`evidence`動的を定義するときに<xref:System.Reflection.Assembly>します。 マップは、ランタイム、<xref:System.Security.Policy.Evidence>付与されたアクセス許可を決定するセキュリティ ポリシーを使用します。 呼び出し元は、null を指定する必要がありますを部分的に信頼された`evidence`します。 場合`evidence`は`null`、ランタイムによってアクセス許可セットがコピー、現在の付与とから呼び出し元のセットを拒否<xref:System.Reflection.Assembly>を動的<xref:System.Reflection.Assembly>定義されていると、ポリシーを解決済みとしてマークします。  
  
 場合、動的<xref:System.Reflection.Assembly>がディスクに保存すると、その後の読み込みは、場所に関連付けられたポリシーに基づいて付与を取得は場所、<xref:System.Reflection.Assembly>が保存されました。  
  
 このメソッドは、現在のアプリケーション ドメインで、動的アセンブリを定義するのみ使用する必要があります。 詳細については、次を参照してください。、<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>メソッドのオーバー ロードします。  
  
   
  
## Examples  
 次のサンプルでは、<xref:System.AppDomain.DefineDynamicAssembly%2A>メソッドと<xref:System.AppDomain.AssemblyResolve>イベント。  
  
 このコード例を実行するには、完全修飾アセンブリ名を指定する必要があります。 完全修飾アセンブリ名を取得する方法については、次を参照してください。[アセンブリ名](~/docs/framework/app-domains/assembly-names.md)します。  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> の <see langword="Name" /> プロパティが <see langword="null" /> です。  
  
または 
<paramref name="name" /> の <see langword="Name" /> プロパティが空白文字で始まるか、スラッシュまたはバック スラッシュを含んでいます。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作が試行されています。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">証拠とアセンブリの読み込み。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /> (関連する列挙体)</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions, bool isSynchronized);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions, bool isSynchronized) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions, bool isSynchronized);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet * bool -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet * bool -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence, requiredPermissions, optionalPermissions, refusedPermissions, isSynchronized)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="isSynchronized" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">動的アセンブリの一意の ID。</param>
        <param name="access">動的アセンブリにアクセスするときのモード。</param>
        <param name="dir">動的アセンブリを保存するディレクトリの名前。 <paramref name="dir" /> が <see langword="null" /> の場合は、現在のディレクトリが既定で使用されます。</param>
        <param name="evidence">動的アセンブリに指定する証拠。 証拠は、ポリシーの解決に使用する証拠の最終セットを変更されないために使用されます。</param>
        <param name="requiredPermissions">必須のアクセス許可要求。</param>
        <param name="optionalPermissions">オプションのアクセス許可要求。</param>
        <param name="refusedPermissions">拒否されたアクセス許可要求。</param>
        <param name="isSynchronized">動的アセンブリ内のモジュール、型、およびメンバーの作成を同期する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>名前、アクセス モード、ストレージ ディレクトリ、証拠、アクセス許可要求、および同期オプションを指定して、動的アセンブリを定義します。</summary>
        <returns>名前と機能が指定された動的アセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定されたアクセス許可要求`requiredPermissions`、`optionalPermissions`と`refusedPermissions`場合にだけ使用`evidence`が指定されても、または動的アセンブリが保存され、メモリに再度読み込まれる場合。  
  
> [!NOTE]
>  動的アセンブリを生成するコードの開発中をお勧めを含めるように<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType>で`refusedPermissions`します。 含む<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification>で、`refusedPermissions`パラメーターは、MSIL が検証されていることを保証します。 この技法の制限はまた、ある<xref:System.Security.SecurityException>完全な信頼を要求するコードで使用する場合にスローされます。  
  
 動的な定義するときに、完全に信頼された呼び出し元は、証拠を提供できますのみ<xref:System.Reflection.Assembly>します。 マップは、ランタイム、<xref:System.Security.Policy.Evidence>付与されたアクセス許可を決定するセキュリティ ポリシーを使用します。 呼び出し元を指定する必要がありますを部分的に信頼された`null`の`evidence`パラメーター。 場合`evidence`は`null`、ランタイムによってアクセス許可セットがコピー、現在の付与とから呼び出し元のセットを拒否<xref:System.Reflection.Assembly>を動的<xref:System.Reflection.Assembly>定義されていると、ポリシーを解決済みとしてマークします。  
  
 場合、動的<xref:System.Reflection.Assembly>がディスクに保存すると、その後の読み込みは、場所に関連付けられたポリシーに基づいて付与を取得は場所、<xref:System.Reflection.Assembly>が保存されました。  
  
 場合`isSynchronized`は`true`、結果の次のメソッド<xref:System.Reflection.Emit.AssemblyBuilder>を同期する: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>、 <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>、 <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>、 <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>、 <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>、および<xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>します。 これらのメソッドの 2 つは、異なるスレッドで呼び出されると、もう一方が完了するまで 1 つブロックされます。  
  
   
  
## Examples  
 次のサンプルでは、<xref:System.AppDomain.DefineDynamicAssembly%2A>メソッドと<xref:System.AppDomain.AssemblyResolve>イベント。  
  
 このコード例を実行するには、完全修飾アセンブリ名を指定する必要があります。 完全修飾アセンブリ名を取得する方法については、次を参照してください。[アセンブリ名](~/docs/framework/app-domains/assembly-names.md)します。  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> の <see langword="Name" /> プロパティが <see langword="null" /> です。  
  
または 
<paramref name="name" /> の <see langword="Name" /> プロパティが空白文字で始まるか、スラッシュまたはバック スラッシュを含んでいます。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作が試行されています。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">証拠とアセンブリの読み込み。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /> (関連する列挙体)</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions, bool isSynchronized, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions, bool isSynchronized, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions, bool isSynchronized, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes);" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet * bool * seq&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence, requiredPermissions, optionalPermissions, refusedPermissions, isSynchronized, assemblyAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="isSynchronized" Type="System.Boolean" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
      </Parameters>
      <Docs>
        <param name="name">動的アセンブリの一意の ID。</param>
        <param name="access">動的アセンブリにアクセスするときのモード。</param>
        <param name="dir">動的アセンブリを保存するディレクトリの名前。 <paramref name="dir" /> が <see langword="null" /> の場合、現在のディレクトリが使用されます。</param>
        <param name="evidence">動的アセンブリに指定する証拠。 証拠は、ポリシーの解決に使用する証拠の最終セットを変更されないために使用されます。</param>
        <param name="requiredPermissions">必須のアクセス許可要求。</param>
        <param name="optionalPermissions">オプションのアクセス許可要求。</param>
        <param name="refusedPermissions">拒否されたアクセス許可要求。</param>
        <param name="isSynchronized">動的アセンブリ内のモジュール、型、およびメンバーの作成を同期する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <param name="assemblyAttributes">アセンブリに適用される属性を列挙した一覧。属性がない場合は <see langword="null" />。</param>
        <summary>名前、アクセス モード、ストレージ ディレクトリ、証拠、アクセス許可要求、同期オプション、およびカスタム属性を指定して、動的アセンブリを定義します。</summary>
        <returns>名前と機能が指定された動的アセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドのオーバー ロードを使用すると、動的アセンブリの作成時に適用しない限り、正しく動作していない属性を指定できます。 たとえば、セキュリティなどの属性<xref:System.Security.SecurityTransparentAttribute>と<xref:System.Security.SecurityCriticalAttribute>動的アセンブリが作成された後に追加されている場合に正常に機能しません。  
  
 指定されたアクセス許可要求、 `requiredPermissions`、 `optionalPermissions`、および`refusedPermissions`場合にのみ、パラメーターが使用される、`evidence`パラメーターが指定されても、または動的アセンブリが保存され、メモリに再度読み込まれる場合。  
  
> [!NOTE]
>  含めることをお勧め動的アセンブリを生成するコードを開発する際に、<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType>フラグ、`refusedPermissions`パラメーター。 このフラグを含めることにより、Microsoft intermediate language (MSIL) が検証されます。 この手法では、意図せずに検出するために非常に困難ですが、検証できないコードの生成を検出します。 この技法の制限はまた、ある<xref:System.Security.SecurityException>完全な信頼を要求するコードで使用した場合にスローされます。  
  
 動的な定義するときに、完全に信頼された呼び出し元は証拠を提供できますのみ<xref:System.Reflection.Assembly>します。 ランタイムのマップ、<xref:System.Security.Policy.Evidence>付与されたアクセス許可を決定するセキュリティ ポリシーを使用します。 呼び出し元を指定する必要がありますを部分的に信頼された`null`の`evidence`パラメーター。 場合`evidence`は`null`、ランタイムは、定義されていると、ポリシーを解決済みとしてマークされる動的アセンブリを呼び出し元のアセンブリから (つまりは、現在の許可、セットを拒否) アクセス許可セットをコピーします。  
  
 動的アセンブリがディスク、その後に保存されているかどうかの負荷が動的アセンブリが保存された場所に関連付けられているポリシーに基づいて付与を取得します。  
  
 場合`isSynchronized`は`true`、結果の次のメソッド<xref:System.Reflection.Emit.AssemblyBuilder>を同期する: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>、 <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>、 <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>、 <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>、 <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>、および<xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>します。 これらのメソッドの 2 つは、異なるスレッドで呼び出されると、もう一方が完了するまで 1 つブロックされます。  
  
 このメソッドのオーバー ロードがで導入された、[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> の <see langword="Name" /> プロパティが <see langword="null" /> です。  
  
または 
<paramref name="name" /> の <see langword="Name" /> プロパティが空白で始まっているか、スラッシュまたは円記号が含まれています。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作が試行されています。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">証拠とアセンブリの読み込み。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /> (関連する列挙体)</permission>
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="DoCallBack">
      <MemberSignature Language="C#" Value="public void DoCallBack (CrossAppDomainDelegate callBackDelegate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DoCallBack(class System.CrossAppDomainDelegate callBackDelegate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DoCallBack (callBackDelegate As CrossAppDomainDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DoCallBack(CrossAppDomainDelegate ^ callBackDelegate);" />
      <MemberSignature Language="F#" Value="abstract member DoCallBack : CrossAppDomainDelegate -&gt; unit&#xA;override this.DoCallBack : CrossAppDomainDelegate -&gt; unit" Usage="appDomain.DoCallBack callBackDelegate" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DoCallBack(System.CrossAppDomainDelegate)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBackDelegate" Type="System.CrossAppDomainDelegate" />
      </Parameters>
      <Docs>
        <param name="callBackDelegate">呼び出すメソッドを指定するデリゲート。</param>
        <summary>指定したデリゲートで識別される、別のアプリケーション ドメイン内のコードを実行します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `callBackDelegate` 値を指定できますマーシャ リングする-、-、 <xref:System.MarshalByRefObject>、または<xref:System.ContextBoundObject>します。  
  
   
  
## Examples  
 次の例は、静的 using<xref:System.AppDomain.DoCallBack%2A>メソッド。  
  
 [!code-cpp[AppDomain_DoCallBack#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DoCallBack/CPP/docallback_static.cpp#1)]
 [!code-csharp[AppDomain_DoCallBack#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DoCallBack/CS/docallback_static.cs#1)]
 [!code-vb[AppDomain_DoCallBack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DoCallBack/VB/docallback_static.vb#1)]  
  
 次の例を使用して、<xref:System.AppDomain.DoCallBack%2A>値によってメソッド。  
  
 [!code-cpp[AppDomain_DoCallBack#2](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DoCallBack/CPP/docallback_byval.cpp#2)]
 [!code-csharp[AppDomain_DoCallBack#2](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DoCallBack/CS/docallback_byval.cs#2)]
 [!code-vb[AppDomain_DoCallBack#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DoCallBack/VB/docallback_byval.vb#2)]  
  
 次の例を使用して、<xref:System.AppDomain.DoCallBack%2A>参照によってメソッド。  
  
 [!code-cpp[AppDomain_DoCallBack#3](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DoCallBack/CPP/docallback_byref.cpp#3)]
 [!code-csharp[AppDomain_DoCallBack#3](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DoCallBack/CS/docallback_byref.cs#3)]
 [!code-vb[AppDomain_DoCallBack#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DoCallBack/VB/docallback_byref.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="callBackDelegate" /> は <see langword="null" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="DomainManager">
      <MemberSignature Language="C#" Value="public AppDomainManager DomainManager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AppDomainManager DomainManager" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.DomainManager" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DomainManager As AppDomainManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AppDomainManager ^ DomainManager { AppDomainManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DomainManager : AppDomainManager" Usage="System.AppDomain.DomainManager" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomainManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーション ドメインの初期化時にホストから提供されたドメイン マネージャーを取得します。</summary>
        <value>アプリケーション ドメインの初期化時にホストから提供されたドメイン マネージャーを表すオブジェクト。ドメイン マネージャーが提供されなかった場合は <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 共通言語ランタイム (CLR) のアンマネージ ホストは、ドメイン マネージャーを提供できます。 ドメイン マネージャーが、新しいアプリケーション ドメインの初期化中に参加してなど、他の管理者の指定、 <xref:System.Security.HostSecurityManager>、アプリケーション ドメインの操作に参加します。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="DomainUnload">
      <MemberSignature Language="C#" Value="public event EventHandler DomainUnload;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DomainUnload" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.DomainUnload" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DomainUnload As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ DomainUnload;" />
      <MemberSignature Language="F#" Value="member this.DomainUnload : EventHandler " Usage="member this.DomainUnload : System.EventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.DomainUnload</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>remove: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.AppDomain" /> をアンロードしようとすると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.EventHandler>デリゲートのアプリケーション ドメインが読み込まれる前に、このイベントは終了のすべてのアクティビティを実行できます。  
  
 各アプリケーション ドメインがアンロードされるときに処理を実行する必要がありますには、このイベントのイベント ハンドラーを登録する必要があります。 共有イベント ハンドラーがないため、使用、<xref:System.EventHandler>デリゲートがアンロードされているドメインを識別できません。  
  
> [!NOTE]
>  既定のアプリケーション ドメインでは、このイベントが発生することはありません。  
  
 イベントが発生したスレッドについて前提を使用しないでください。 呼ばれるものとは別のスレッドでイベントを発生させることができます、<xref:System.AppDomain.Unload%2A>メソッド。  
  
 イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DynamicDirectory">
      <MemberSignature Language="C#" Value="public string DynamicDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DynamicDirectory" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.DynamicDirectory" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DynamicDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DynamicDirectory { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DynamicDirectory : string" Usage="System.AppDomain.DynamicDirectory" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.DynamicDirectory</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>動的に作成されたアセンブリを探すためにアセンブリ リゾルバーが使用するディレクトリを取得します。</summary>
        <value>動的に作成されたアセンブリを探すためにアセンブリ リゾルバーが使用するディレクトリ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 動的なディレクトリを設定するには、ベース ディレクトリ パスを割り当てる、<xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType>のプロパティ、<xref:System.AppDomainSetup>新しいアプリケーション ドメインを作成するために使用するオブジェクト。 割り当てる文字列のハッシュ コードを単純な名前を持つサブディレクトリの追加により、プロパティに割り当てるベース ディレクトリ パスが変更された、<xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType>プロパティ、ベース ディレクトリの形式が*元パス* \\*ハッシュ コード*します。 動的ディレクトリは、このベース ディレクトリのサブディレクトリです。 単純な名前の値である、<xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType>プロパティ、その形式が*元のパス*\\*ハッシュ コード*\\*アプリケーション名*します。  
  
   
  
## Examples  
 次の例では、動的アセンブリのディレクトリとアプリケーション ドメインを作成、動的アセンブリを生成および動的のディレクトリに格納新しいアプリケーション ドメインにアセンブリを読み込み、それを使用します。  
  
 例は、作成、<xref:System.AppDomainSetup>オブジェクトとセットの<xref:System.AppDomainSetup.ApplicationName%2A>を"Example"プロパティとその<xref:System.AppDomainSetup.DynamicBase%2A>プロパティを"C:\DynamicAssemblyDir"。 例を表示し、<xref:System.AppDomainSetup.DynamicBase%2A>プロパティ、アプリケーション名のハッシュ コードが最初に割り当てられたパスのサブディレクトリとして追加されていないことを表示します。  
  
> [!NOTE]
>  この例では、ベース ディレクトリの目的は、アプリケーションの例のプローブ パスの外部にします。 別の場所の例をコンパイルしてください。 例を実行するたびに、ベース ディレクトリとすべてのサブディレクトリを削除します。  
  
 例では、作成、新しいアプリケーション ドメインを使用して、<xref:System.AppDomainSetup>オブジェクト。 この例では、<xref:System.AppDomain.DynamicDirectory%2A>ディレクトリを作成するために、ディレクトリの名前を取得するプロパティ。 (例では、でした同じくらい簡単に事前に作成、ディレクトリ、元のパス、アプリケーション名、およびアプリケーション名のハッシュ コードを連結することにより。)  
  
 この例を`GenerateDynamicAssembly`という名前のアセンブリを出力するメソッド`DynamicHelloWorld.dll`し、新しいアプリケーション ドメインの動的なディレクトリに格納します。 動的アセンブリには、1 つの型が含まれています。 `HelloWorld`、静的メソッドを持つ (`Shared` Visual Basic でのメソッド) という名前の`HelloFromAD`します。 このメソッドを呼び出すには、アプリケーション ドメインの名前が表示されます。  
  
 `Example`クラスから派生<xref:System.MarshalByRefObject>例では、新しいアプリケーション ドメインと呼び出しで、クラスのインスタンスを作成できるように、その`Test`メソッド。 `Test`メソッドその表示名で動的アセンブリをロードして、静的な`HelloFromAD`メソッド。  
  
 という名前のアセンブリのコードを記述することで、動的なディレクトリが通常のプローブ パスの後に検索を表示する`DynamicHelloWorld.dll`し、この例と同じディレクトリにコンパイルしています。 という名前のクラスがアセンブリにあります`HelloWorld`という名前の静的メソッドで`HelloFromAD`します。 このメソッドはの例で 1 つとして同じ機能を使用する必要はありません。単にコンソールに文字列を表示できます。 アセンブリがあります、<xref:System.Reflection.AssemblyVersionAttribute>属性をそのバージョンを 1.0.0.0 に設定します。 例を実行するときに、動的なディレクトリを検索する前に、現在のディレクトリでコンパイルしたアセンブリが見つかりました。  
  
 [!code-cpp[ADDynamicBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDynamicBase/CPP/addynamicbase.cpp#1)]
 [!code-csharp[ADDynamicBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDynamicBase/CS/addynamicbase.cs#1)]
 [!code-vb[ADDynamicBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDynamicBase/VB/addynamicbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作が試行されています。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">パス情報にアクセスします。 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> (関連する列挙体)</permission>
      </Docs>
    </Member>
    <Member MemberName="Evidence">
      <MemberSignature Language="C#" Value="public System.Security.Policy.Evidence Evidence { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.Evidence Evidence" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.Evidence" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Evidence As Evidence" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Policy::Evidence ^ Evidence { System::Security::Policy::Evidence ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Evidence : System.Security.Policy.Evidence" Usage="System.AppDomain.Evidence" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Security.IEvidenceFactory.Evidence</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Policy.Evidence</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このアプリケーション ドメインに関連付けられている <see cref="T:System.Security.Policy.Evidence" /> を取得します。</summary>
        <value>このアプリケーション ドメインに関連付けられた証拠。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作が試行されています。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">証拠とアセンブリの読み込み。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /> (関連する列挙体) セキュリティ アクション:<see cref="F:System.Security.Permissions.SecurityAction.Demand" />します。</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExecuteAssembly">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定したファイルに格納されているアセンブリを実行します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ExecuteAssembly(System::String ^ assemblyFile);" />
      <MemberSignature Language="F#" Value="abstract member ExecuteAssembly : string -&gt; int&#xA;override this.ExecuteAssembly : string -&gt; int" Usage="appDomain.ExecuteAssembly assemblyFile" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ExecuteAssembly(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">実行するアセンブリが格納されているファイルの名前。</param>
        <summary>指定したファイルに格納されているアセンブリを実行します。</summary>
        <returns>アセンブリのエントリ ポイントが返す値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 アセンブリが .NET Framework のヘッダーで指定されたエントリ ポイントで実行を開始します。  
  
 このメソッドでは、新しいプロセスまたはアプリケーション ドメインは作成されませんし、新しいスレッド上で、エントリ ポイント メソッドは実行されません。  
  
 このメソッドを使用してアセンブリを読み込み、<xref:System.Reflection.Assembly.LoadFile%2A>メソッド。 使用してアセンブリを実行することも、<xref:System.AppDomain.ExecuteAssemblyByName%2A>メソッドを使用してアセンブリを読み込む、<xref:System.Reflection.Assembly.Load%2A>メソッド。  
  
 作成する、<xref:System.AppDomain>読み込みと実行を使用して、<xref:System.AppDomain.CreateDomain%2A>メソッド。  
  
   
  
## Examples  
 次の例のオーバー ロードのいずれかを使用して<xref:System.AppDomain.ExecuteAssembly%2A>で 2 つのドメイン。  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> が見つかりません。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> は有効なアセンブリではありません。  
  
または 
現在、Version 2.0 以降の共通言語ランタイムが読み込まれていますが、それよりも新しいバージョンを使用して <paramref name="assemblyFile" /> がコンパイルされています。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作しようとします。</exception>
        <exception cref="T:System.IO.FileLoadException">1 つのアセンブリまたはモジュールが 2 つの異なる証拠を使用して 2 回読み込まれました。</exception>
        <exception cref="T:System.MissingMethodException">指定されたアセンブリにエントリ ポイントがありません。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">ファイルまたはディレクトリからと、パス自体の情報にアクセスするための読み取りにアクセスします。 列挙体に関連付けられている: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />、<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />します。</permission>
        <permission cref="T:System.Net.WebPermission">file:// で始まらないする URI を読み取る。</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">コンソール アプリケーションを実行します。 <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /> (関連する列挙体)</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, assemblySecurity As Evidence) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ExecuteAssembly(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="abstract member ExecuteAssembly : string * System.Security.Policy.Evidence -&gt; int&#xA;override this.ExecuteAssembly : string * System.Security.Policy.Evidence -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssembly which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">実行するアセンブリが格納されているファイルの名前。</param>
        <param name="assemblySecurity">アセンブリを読み込むために必要な証拠。</param>
        <summary>指定したファイルに格納されているアセンブリを、指定した証拠を使用して実行します。</summary>
        <returns>アセンブリのエントリ ポイントが返す値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 アセンブリが .NET Framework のヘッダーで指定されたエントリ ポイントで実行を開始します。  
  
 <xref:System.AppDomain.ExecuteAssembly%2A>メソッドでは、新しいプロセスまたはアプリケーション ドメインは作成されませんし、新しいスレッド上で、エントリ ポイント メソッドは実行されません。  
  
 このメソッドを使用してアセンブリを読み込み、<xref:System.Reflection.Assembly.LoadFile%2A>メソッド。 使用してアセンブリを実行することも、<xref:System.AppDomain.ExecuteAssemblyByName%2A>メソッドを使用してアセンブリを読み込む、<xref:System.Reflection.Assembly.Load%2A>メソッド。  
  
   
  
## Examples  
 次の例のオーバー ロードのいずれかを使用して<xref:System.AppDomain.ExecuteAssembly%2A>で 2 つのドメイン。  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> が見つかりません。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> は有効なアセンブリではありません。  
  
または 
現在、Version 2.0 以降の共通言語ランタイムが読み込まれていますが、それよりも新しいバージョンを使用して <paramref name="assemblyFile" /> がコンパイルされています。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作しようとします。</exception>
        <exception cref="T:System.IO.FileLoadException">1 つのアセンブリまたはモジュールが 2 つの異なる証拠を使用して 2 回読み込まれました。</exception>
        <exception cref="T:System.MissingMethodException">指定されたアセンブリにエントリ ポイントがありません。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">証拠とアセンブリの読み込み。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /> (関連する列挙体)</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">ファイルまたはディレクトリからと、パス自体の情報にアクセスするための読み取りにアクセスします。 列挙体に関連付けられている: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />、<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />します。</permission>
        <permission cref="T:System.Net.WebPermission">file:// で始まらないする URI を読み取る。</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">コンソール アプリケーションを実行します。 <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /> (関連する列挙体)</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssembly(System::String ^ assemblyFile, cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssembly : string * string[] -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="args" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">実行するアセンブリが格納されているファイルの名前。</param>
        <param name="args">アセンブリのエントリ ポイントに渡す引数。</param>
        <summary>指定したファイルに格納されているアセンブリを、指定した引数を使用して実行します。</summary>
        <returns>アセンブリのエントリ ポイントから返された値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 アセンブリが .NET Framework のヘッダーで指定されたエントリ ポイントで実行を開始します。  
  
 このメソッドでは、新しいプロセスまたはアプリケーション ドメインは作成されませんし、新しいスレッド上で、エントリ ポイント メソッドは実行されません。  
  
 このメソッドを使用してアセンブリを読み込み、<xref:System.Reflection.Assembly.LoadFile%2A>メソッド。 使用してアセンブリを実行することも、<xref:System.AppDomain.ExecuteAssemblyByName%2A>メソッドを使用してアセンブリを読み込む、<xref:System.Reflection.Assembly.Load%2A>メソッド。  
  
   
  
## Examples  
 次の例のオーバー ロードのいずれかを使用して<xref:System.AppDomain.ExecuteAssembly%2A>で 2 つのドメイン。  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> が見つかりません。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> は有効なアセンブリではありません。  
  
または 
 <paramref name="assemblyFile" /> が、現在読み込まれているバージョンよりも新しいバージョンの共通言語ランタイムでコンパイルされました。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作が試行されています。</exception>
        <exception cref="T:System.IO.FileLoadException">1 つのアセンブリまたはモジュールが 2 つの異なる証拠を使用して 2 回読み込まれました。</exception>
        <exception cref="T:System.MissingMethodException">指定されたアセンブリにエントリ ポイントがありません。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">ファイルまたはディレクトリからと、パス自体の情報にアクセスするための読み取りにアクセスします。 列挙体に関連付けられている: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />、<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />します。</permission>
        <permission cref="T:System.Net.WebPermission">file:// で始まらないする URI を読み取る。</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">コンソール アプリケーションを実行します。 <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /> (関連する列挙体)</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, assemblySecurity As Evidence, args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ExecuteAssembly(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ assemblySecurity, cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member ExecuteAssembly : string * System.Security.Policy.Evidence * string[] -&gt; int&#xA;override this.ExecuteAssembly : string * System.Security.Policy.Evidence * string[] -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, assemblySecurity, args)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssembly which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">実行するアセンブリが格納されているファイルの名前。</param>
        <param name="assemblySecurity">アセンブリに指定する証拠。</param>
        <param name="args">アセンブリのエントリ ポイントに渡す引数。</param>
        <summary>指定したファイルに格納されているアセンブリを、指定した証拠と引数を使用して実行します。</summary>
        <returns>アセンブリのエントリ ポイントが返す値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 アセンブリが .NET Framework のヘッダーで指定されたエントリ ポイントで実行を開始します。  
  
 このメソッドでは、新しいプロセスまたはアプリケーション ドメインは作成されませんし、新しいスレッド上で、エントリ ポイント メソッドは実行されません。  
  
 このメソッドを使用してアセンブリを読み込み、<xref:System.Reflection.Assembly.LoadFile%2A>メソッド。 使用してアセンブリを実行することも、<xref:System.AppDomain.ExecuteAssemblyByName%2A>メソッドを使用してアセンブリを読み込む、<xref:System.Reflection.Assembly.Load%2A>メソッド。  
  
   
  
## Examples  
 次の例のオーバー ロードのいずれかを使用して<xref:System.AppDomain.ExecuteAssembly%2A>で 2 つのドメイン。  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> が見つかりません。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> は有効なアセンブリではありません。  
  
または 
現在、Version 2.0 以降の共通言語ランタイムが読み込まれていますが、それよりも新しいバージョンを使用して <paramref name="assemblyFile" /> がコンパイルされています。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作しようとします。</exception>
        <exception cref="T:System.IO.FileLoadException">1 つのアセンブリまたはモジュールが 2 つの異なる証拠を使用して 2 回読み込まれました。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="assemblySecurity" /> が <see langword="null" /> ではありません。 レガシ CAS ポリシーが有効になっていない場合は、<paramref name="assemblySecurity" /> を <see langword="null" /> にする必要があります。</exception>
        <exception cref="T:System.MissingMethodException">指定されたアセンブリにエントリ ポイントがありません。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">証拠とアセンブリの読み込み。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /> (関連する列挙体)</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">ファイルまたはディレクトリからと、パス自体の情報にアクセスするための読み取りにアクセスします。 列挙体に関連付けられている: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />、<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />します。</permission>
        <permission cref="T:System.Net.WebPermission">file:// で始まらないする URI を読み取る。</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">コンソール アプリケーションを実行します。 <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /> (関連する列挙体)</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, string[] args, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, string[] args, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, args As String(), hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssembly(System::String ^ assemblyFile, cli::array &lt;System::String ^&gt; ^ args, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssembly : string * string[] * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, args, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="args" Type="System.String[]" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">実行するアセンブリが格納されているファイルの名前。</param>
        <param name="args">アセンブリのエントリ ポイントに渡す引数。</param>
        <param name="hashValue">計算されたハッシュ コードの値を表します。</param>
        <param name="hashAlgorithm">アセンブリ マニフェストが使用するハッシュ アルゴリズムを表します。</param>
        <summary>指定したファイルに格納されているアセンブリを、指定した引数、ハッシュ値、およびハッシュ アルゴリズムを使用して実行します。</summary>
        <returns>アセンブリのエントリ ポイントから返された値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 アセンブリが .NET Framework のヘッダーで指定されたエントリ ポイントで実行を開始します。  
  
 このメソッドでは、新しいプロセスまたはアプリケーション ドメインは作成されませんし、新しいスレッド上で、エントリ ポイント メソッドは実行されません。  
  
 このメソッドを使用してアセンブリを読み込み、<xref:System.Reflection.Assembly.LoadFile%2A>メソッド。 使用してアセンブリを実行することも、<xref:System.AppDomain.ExecuteAssemblyByName%2A>メソッドを使用してアセンブリを読み込む、<xref:System.Reflection.Assembly.Load%2A>メソッド。  
  
   
  
## Examples  
 次の例のオーバー ロードのいずれかを使用して<xref:System.AppDomain.ExecuteAssembly%2A>で 2 つのドメイン。  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> が見つかりません。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> は有効なアセンブリではありません。  
  
または 
 <paramref name="assemblyFile" /> が、現在読み込まれているバージョンよりも新しいバージョンの共通言語ランタイムでコンパイルされました。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作が試行されています。</exception>
        <exception cref="T:System.IO.FileLoadException">1 つのアセンブリまたはモジュールが 2 つの異なる証拠を使用して 2 回読み込まれました。</exception>
        <exception cref="T:System.MissingMethodException">指定されたアセンブリにエントリ ポイントがありません。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">ファイルまたはディレクトリからと、パス自体の情報にアクセスするための読み取りにアクセスします。 列挙体に関連付けられている: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />、<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />します。</permission>
        <permission cref="T:System.Net.WebPermission">file:// で始まらないする URI を読み取る。</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">コンソール アプリケーションを実行します。 <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /> (関連する列挙体)</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity, string[] args, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, assemblySecurity As Evidence, args As String(), hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssembly(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ assemblySecurity, cli::array &lt;System::String ^&gt; ^ args, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssembly : string * System.Security.Policy.Evidence * string[] * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, assemblySecurity, args, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssembly which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">実行するアセンブリが格納されているファイルの名前。</param>
        <param name="assemblySecurity">アセンブリに指定する証拠。</param>
        <param name="args">アセンブリのエントリ ポイントに渡す引数。</param>
        <param name="hashValue">計算されたハッシュ コードの値を表します。</param>
        <param name="hashAlgorithm">アセンブリ マニフェストが使用するハッシュ アルゴリズムを表します。</param>
        <summary>指定したファイルに格納されているアセンブリを、指定した証拠、引数、ハッシュ値、およびハッシュ アルゴリズムを使用して実行します。</summary>
        <returns>アセンブリのエントリ ポイントが返す値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 アセンブリが .NET Framework のヘッダーで指定されたエントリ ポイントで実行を開始します。  
  
 このメソッドでは、新しいプロセスまたはアプリケーション ドメインは作成されませんし、新しいスレッド上で、エントリ ポイント メソッドは実行されません。  
  
 このメソッドを使用してアセンブリを読み込み、<xref:System.Reflection.Assembly.LoadFile%2A>メソッド。 使用してアセンブリを実行することも、<xref:System.AppDomain.ExecuteAssemblyByName%2A>メソッドを使用してアセンブリを読み込む、<xref:System.Reflection.Assembly.Load%2A>メソッド。  
  
   
  
## Examples  
 次のサンプルのオーバー ロードのいずれかの使用例<xref:System.AppDomain.ExecuteAssembly%2A>で 2 つのドメイン。  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> が見つかりません。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> は有効なアセンブリではありません。  
  
または 
現在、Version 2.0 以降の共通言語ランタイムが読み込まれていますが、それよりも新しいバージョンを使用して <paramref name="assemblyFile" /> がコンパイルされています。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作しようとします。</exception>
        <exception cref="T:System.IO.FileLoadException">1 つのアセンブリまたはモジュールが 2 つの異なる証拠を使用して 2 回読み込まれました。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="assemblySecurity" /> が <see langword="null" /> ではありません。 レガシ CAS ポリシーが有効になっていない場合は、<paramref name="assemblySecurity" /> を <see langword="null" /> にする必要があります。</exception>
        <exception cref="T:System.MissingMethodException">指定されたアセンブリにエントリ ポイントがありません。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">証拠とアセンブリの読み込み。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /> (関連する列挙体)</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">ファイルまたはディレクトリからと、パス自体の情報にアクセスするための読み取りにアクセスします。 列挙体に関連付けられている: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />、<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />します。</permission>
        <permission cref="T:System.Net.WebPermission">file:// で始まらないする URI を読み取る。</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">コンソール アプリケーションを実行します。 <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /> (関連する列挙体)</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExecuteAssemblyByName">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>アセンブリを実行します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : string -&gt; int" Usage="appDomain.ExecuteAssemblyByName assemblyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">アセンブリの表示名。 「<see cref="P:System.Reflection.Assembly.FullName" />」を参照してください。</param>
        <summary>表示名を指定してアセンブリを実行します。</summary>
        <returns>アセンブリのエントリ ポイントが返す値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomain.ExecuteAssemblyByName%2A>メソッドと同様の機能を提供する、<xref:System.AppDomain.ExecuteAssembly%2A>メソッドは、表示名でアセンブリを指定する、または<xref:System.Reflection.AssemblyName>ファイルの場所ではなく、します。 そのため、<xref:System.AppDomain.ExecuteAssemblyByName%2A>を持つアセンブリを読み込み、<xref:System.Reflection.Assembly.Load%2A>メソッドではなく、<xref:System.Reflection.Assembly.LoadFile%2A>メソッド。  
  
 アセンブリが .NET Framework のヘッダーで指定されたエントリ ポイントで実行を開始します。  
  
 このメソッドでは、新しいプロセスまたはアプリケーション ドメインは作成されませんし、新しいスレッド上で、エントリ ポイント メソッドは実行されません。  
  
 作成する、<xref:System.AppDomain>読み込みと実行を使用して、<xref:System.AppDomain.CreateDomain%2A>メソッド。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> で指定されたアセンブリが見つかりません。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> で指定されたアセンブリが有効なアセンブリではありません。  
  
または 
現在、Version 2.0 以降の共通言語ランタイムが読み込まれていますが、それよりも新しいバージョンを使用して <paramref name="assemblyName" /> がコンパイルされています。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作が試行されています。</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="assemblyName" /> で指定されたアセンブリは見つかりましたが、読み込むことができませんでした。</exception>
        <exception cref="T:System.MissingMethodException">指定されたアセンブリにエントリ ポイントがありません。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">ファイルまたはパス、自体の情報へのアクセスと表示名をパスにリダイレクトするためのディレクトリからの読み取りアクセス。 列挙体に関連付けられている: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />、<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />します。</permission>
        <permission cref="T:System.Net.WebPermission">表示名が URL にリダイレクトされたときに、Web サイトにアクセスします。</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">コンソール アプリケーションを実行します。 <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /> (関連する列挙体)</permission>
        <altmember cref="T:System.Reflection.AssemblyName" />
        <altmember cref="M:System.Reflection.Assembly.Load(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (System.Reflection.AssemblyName assemblyName, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(class System.Reflection.AssemblyName assemblyName, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::Reflection::AssemblyName ^ assemblyName, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : System.Reflection.AssemblyName * string[] -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.Reflection.AssemblyName" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName">アセンブリの名前を表す <see cref="T:System.Reflection.AssemblyName" /> オブジェクト。</param>
        <param name="args">プロセスを起動するときに渡すコマンド ライン引数。</param>
        <summary>
          <see cref="T:System.Reflection.AssemblyName" /> を指定し、指定された引数を使用してアセンブリを実行します。</summary>
        <returns>アセンブリのエントリ ポイントから返された値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomain.ExecuteAssemblyByName%2A>メソッドと同様の機能を提供する、<xref:System.AppDomain.ExecuteAssembly%2A>メソッドは、表示名でアセンブリを指定する、または<xref:System.Reflection.AssemblyName>ファイルの場所ではなく、します。 そのため、<xref:System.AppDomain.ExecuteAssemblyByName%2A>を持つアセンブリを読み込み、<xref:System.Reflection.Assembly.Load%2A>メソッドではなく、<xref:System.Reflection.Assembly.LoadFile%2A>メソッド。  
  
 アセンブリが .NET Framework のヘッダーで指定されたエントリ ポイントで実行を開始します。  
  
 このメソッドでは、新しいプロセスまたはアプリケーション ドメインは作成されませんし、新しいスレッド上で、エントリ ポイント メソッドは実行されません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> で指定されたアセンブリが見つかりません。</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="assemblyName" /> によって指定したアセンブリが検出されましたが、読み込むことができません。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> によって指定したアセンブリは、有効なアセンブリではありません。  
  
または 
 <paramref name="assemblyName" /> が、現在読み込まれているバージョンよりも新しいバージョンの共通言語ランタイムでコンパイルされました。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作が試行されています。</exception>
        <exception cref="T:System.MissingMethodException">指定されたアセンブリにエントリ ポイントがありません。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">ファイルまたはパス、自体の情報へのアクセスと表示名をパスにリダイレクトするためのディレクトリからの読み取りアクセス。 列挙体に関連付けられている: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />、<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />します。</permission>
        <permission cref="T:System.Net.WebPermission">表示名が URL にリダイレクトされたときに、Web サイトにアクセスします。</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">コンソール アプリケーションを実行します。 <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /> (関連する列挙体)</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String, assemblySecurity As Evidence) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : string * System.Security.Policy.Evidence -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssemblyByName which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName">アセンブリの表示名。 「<see cref="P:System.Reflection.Assembly.FullName" />」を参照してください。</param>
        <param name="assemblySecurity">アセンブリを読み込むために必要な証拠。</param>
        <summary>表示名を指定し、指定された証拠を使用してアセンブリを実行します。</summary>
        <returns>アセンブリのエントリ ポイントが返す値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomain.ExecuteAssemblyByName%2A>メソッドと同様の機能を提供する、<xref:System.AppDomain.ExecuteAssembly%2A>メソッドは、表示名でアセンブリを指定する、または<xref:System.Reflection.AssemblyName>ファイルの場所ではなく、します。 そのため、<xref:System.AppDomain.ExecuteAssemblyByName%2A>を持つアセンブリを読み込み、<xref:System.Reflection.Assembly.Load%2A>メソッドではなく、<xref:System.Reflection.Assembly.LoadFile%2A>メソッド。  
  
 アセンブリが .NET Framework のヘッダーで指定されたエントリ ポイントで実行を開始します。  
  
 <xref:System.AppDomain.ExecuteAssemblyByName%2A>メソッドでは、新しいプロセスまたはアプリケーション ドメインは作成されませんし、新しいスレッド上で、エントリ ポイント メソッドは実行されません。  
  
> [!NOTE]
>  使用すると、<xref:System.AppDomain.ExecuteAssemblyByName%2A>メソッドを<xref:System.Security.Policy.Evidence>パラメーターの証拠がマージされます。 引数として指定された証拠、<xref:System.AppDomain.ExecuteAssemblyByName%2A>メソッドは、ローダーによって提供される証拠の部分を置き換えます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> で指定されたアセンブリが見つかりません。</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="assemblyName" /> によって指定したアセンブリが検出されましたが、読み込むことができません。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> によって指定したアセンブリは、有効なアセンブリではありません。  
  
または 
現在、Version 2.0 以降の共通言語ランタイムが読み込まれていますが、それよりも新しいバージョンを使用して <paramref name="assemblyName" /> がコンパイルされています。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作が試行されています。</exception>
        <exception cref="T:System.MissingMethodException">指定されたアセンブリにエントリ ポイントがありません。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">ファイルまたはパス、自体の情報へのアクセスと表示名をパスにリダイレクトするためのディレクトリからの読み取りアクセス。 列挙体に関連付けられている: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />、<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />します。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">証拠とアセンブリの読み込み。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /> (関連する列挙体)</permission>
        <permission cref="T:System.Net.WebPermission">表示名が URL にリダイレクトされたときに、Web サイトにアクセスします。</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">コンソール アプリケーションを実行します。 <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /> (関連する列挙体)</permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String, ParamArray args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : string * string[] -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName">アセンブリの表示名。 「<see cref="P:System.Reflection.Assembly.FullName" />」を参照してください。</param>
        <param name="args">プロセスを起動するときに渡すコマンド ライン引数。</param>
        <summary>表示名を指定し、指定された引数を使用してアセンブリを実行します。</summary>
        <returns>アセンブリのエントリ ポイントから返された値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomain.ExecuteAssemblyByName%2A>メソッドと同様の機能を提供する、<xref:System.AppDomain.ExecuteAssembly%2A>メソッドは、表示名でアセンブリを指定する、または<xref:System.Reflection.AssemblyName>ファイルの場所ではなく、します。 そのため、<xref:System.AppDomain.ExecuteAssemblyByName%2A>を持つアセンブリを読み込み、<xref:System.Reflection.Assembly.Load%2A>メソッドではなく、<xref:System.Reflection.Assembly.LoadFile%2A>メソッド。  
  
 アセンブリが .NET Framework のヘッダーで指定されたエントリ ポイントで実行を開始します。  
  
 このメソッドでは、新しいプロセスまたはアプリケーション ドメインは作成されませんし、新しいスレッド上で、エントリ ポイント メソッドは実行されません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> で指定されたアセンブリが見つかりません。</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="assemblyName" /> によって指定したアセンブリが検出されましたが、読み込むことができません。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> によって指定したアセンブリは、有効なアセンブリではありません。  
  
または 
 <paramref name="assemblyName" /> が、現在読み込まれているバージョンよりも新しいバージョンの共通言語ランタイムでコンパイルされました。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作が試行されています。</exception>
        <exception cref="T:System.MissingMethodException">指定されたアセンブリにエントリ ポイントがありません。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">ファイルまたはパス、自体の情報へのアクセスと表示名をパスにリダイレクトするためのディレクトリからの読み取りアクセス。 列挙体に関連付けられている: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />、<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />します。</permission>
        <permission cref="T:System.Net.WebPermission">表示名が URL にリダイレクトされたときに、Web サイトにアクセスします。</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">コンソール アプリケーションを実行します。 <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /> (関連する列挙体)</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (System.Reflection.AssemblyName assemblyName, System.Security.Policy.Evidence assemblySecurity, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(class System.Reflection.AssemblyName assemblyName, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::Reflection::AssemblyName ^ assemblyName, System::Security::Policy::Evidence ^ assemblySecurity, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : System.Reflection.AssemblyName * System.Security.Policy.Evidence * string[] -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, assemblySecurity, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssemblyByName which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.Reflection.AssemblyName" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName">アセンブリの名前を表す <see cref="T:System.Reflection.AssemblyName" /> オブジェクト。</param>
        <param name="assemblySecurity">アセンブリを読み込むために必要な証拠。</param>
        <param name="args">プロセスを起動するときに渡すコマンド ライン引数。</param>
        <summary>指定された証拠および引数で、<see cref="T:System.Reflection.AssemblyName" /> に指定されたアセンブリを実行します。</summary>
        <returns>アセンブリのエントリ ポイントが返す値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomain.ExecuteAssemblyByName%2A>メソッドと同様の機能を提供する、<xref:System.AppDomain.ExecuteAssembly%2A>メソッドは、表示名でアセンブリを指定する、または<xref:System.Reflection.AssemblyName>ファイルの場所ではなく、します。 そのため、<xref:System.AppDomain.ExecuteAssemblyByName%2A>を持つアセンブリを読み込み、<xref:System.Reflection.Assembly.Load%2A>メソッドではなく、<xref:System.Reflection.Assembly.LoadFile%2A>メソッド。  
  
 アセンブリが .NET Framework のヘッダーで指定されたエントリ ポイントで実行を開始します。  
  
 このメソッドでは、新しいプロセスまたはアプリケーション ドメインは作成されませんし、新しいスレッド上で、エントリ ポイント メソッドは実行されません。  
  
> [!NOTE]
>  使用すると、<xref:System.AppDomain.ExecuteAssemblyByName%2A>メソッドを<xref:System.Security.Policy.Evidence>パラメーターの証拠がマージされます。 引数として指定された証拠、<xref:System.AppDomain.ExecuteAssemblyByName%2A>メソッドは、ローダーによって提供される証拠の部分を置き換えます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> で指定されたアセンブリが見つかりません。</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="assemblyName" /> によって指定したアセンブリが検出されましたが、読み込むことができません。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> によって指定したアセンブリは、有効なアセンブリではありません。  
  
または 
現在、Version 2.0 以降の共通言語ランタイムが読み込まれていますが、それよりも新しいバージョンを使用して <paramref name="assemblyName" /> がコンパイルされています。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作が試行されています。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="assemblySecurity" /> が <see langword="null" /> ではありません。 レガシ CAS ポリシーが有効になっていない場合は、<paramref name="assemblySecurity" /> を <see langword="null" /> にする必要があります。</exception>
        <exception cref="T:System.MissingMethodException">指定されたアセンブリにエントリ ポイントがありません。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">ファイルまたはパス、自体の情報へのアクセスと表示名をパスにリダイレクトするためのディレクトリからの読み取りアクセス。 列挙体に関連付けられている: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />、<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />します。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">証拠とアセンブリの読み込み。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /> (関連する列挙体)</permission>
        <permission cref="T:System.Net.WebPermission">表示名が URL にリダイレクトされたときに、Web サイトにアクセスします。</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">コンソール アプリケーションを実行します。 <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /> (関連する列挙体)</permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, System.Security.Policy.Evidence assemblySecurity, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String, assemblySecurity As Evidence, ParamArray args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName, System::Security::Policy::Evidence ^ assemblySecurity, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : string * System.Security.Policy.Evidence * string[] -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, assemblySecurity, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssemblyByName which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName">アセンブリの表示名。 「<see cref="P:System.Reflection.Assembly.FullName" />」を参照してください。</param>
        <param name="assemblySecurity">アセンブリを読み込むために必要な証拠。</param>
        <param name="args">プロセスを起動するときに渡すコマンド ライン引数。</param>
        <summary>表示名を指定し、指定された証拠および引数を使用してアセンブリを実行します。</summary>
        <returns>アセンブリのエントリ ポイントが返す値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomain.ExecuteAssemblyByName%2A>メソッドと同様の機能を提供する、<xref:System.AppDomain.ExecuteAssembly%2A>メソッドは、表示名でアセンブリを指定する、または<xref:System.Reflection.AssemblyName>ファイルの場所ではなく、します。 そのため、<xref:System.AppDomain.ExecuteAssemblyByName%2A>を持つアセンブリを読み込み、<xref:System.Reflection.Assembly.Load%2A>メソッドではなく、<xref:System.Reflection.Assembly.LoadFile%2A>メソッド。  
  
 アセンブリが .NET Framework のヘッダーで指定されたエントリ ポイントで実行を開始します。  
  
 このメソッドでは、新しいプロセスまたはアプリケーション ドメインは作成されませんし、新しいスレッド上で、エントリ ポイント メソッドは実行されません。  
  
> [!NOTE]
>  使用すると、<xref:System.AppDomain.ExecuteAssemblyByName%2A>メソッドを<xref:System.Security.Policy.Evidence>パラメーターの証拠がマージされます。 引数として指定された証拠、<xref:System.AppDomain.ExecuteAssemblyByName%2A>メソッドは、ローダーによって提供される証拠の部分を置き換えます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> で指定されたアセンブリが見つかりません。</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="assemblyName" /> によって指定したアセンブリが検出されましたが、読み込むことができません。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> によって指定したアセンブリは、有効なアセンブリではありません。  
  
または 
現在、Version 2.0 以降の共通言語ランタイムが読み込まれていますが、それよりも新しいバージョンを使用して <paramref name="assemblyName" /> がコンパイルされています。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作が試行されています。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="assemblySecurity" /> が <see langword="null" /> ではありません。 レガシ CAS ポリシーが有効になっていない場合は、<paramref name="assemblySecurity" /> を <see langword="null" /> にする必要があります。</exception>
        <exception cref="T:System.MissingMethodException">指定されたアセンブリにエントリ ポイントがありません。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">ファイルまたはパス、自体の情報へのアクセスと表示名をパスにリダイレクトするためのディレクトリからの読み取りアクセス。 列挙体に関連付けられている: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />、<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />します。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">証拠とアセンブリの読み込み。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /> (関連する列挙体)</permission>
        <permission cref="T:System.Net.WebPermission">表示名が URL にリダイレクトされたときに、Web サイトにアクセスします。</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">コンソール アプリケーションを実行します。 <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /> (関連する列挙体)</permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="FirstChanceException">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; FirstChanceException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; FirstChanceException" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.FirstChanceException" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FirstChanceException As EventHandler(Of FirstChanceExceptionEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Runtime::ExceptionServices::FirstChanceExceptionEventArgs ^&gt; ^ FirstChanceException;" />
      <MemberSignature Language="F#" Value="member this.FirstChanceException : EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; " Usage="member this.FirstChanceException : System.EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーション ドメイン内の例外ハンドラーに対する呼び出し履歴をランタイムが検索する前に、マネージド コード内で例外がスローされた場合に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、通知だけです。 このイベントを処理する例外を処理したりしない後続の例外が何らかの方法で処理に影響を与えます。 イベントが発生したイベント ハンドラーが呼び出された後は、共通言語ランタイム (CLR) は、例外のハンドラーの検索を開始します。 <xref:System.AppDomain.FirstChanceException> アプリケーション ドメインを任意のマネージ例外を確認する最初の機会を提供します。  
  
 イベントは、アプリケーション ドメインごとに処理できます。 スレッドが呼び出しの実行中の複数のアプリケーション ドメインを通過、CLR は、そのアプリケーション ドメインに一致する例外ハンドラーの検索を開始する前に、イベント ハンドラーが登録したアプリケーション ドメインごとに、イベントが発生します。 イベントが処理された後、そのアプリケーション ドメインに一致する例外ハンドラーの検索が行われます。 [なし] が見つかった場合は、次のアプリケーション ドメインで、イベントが発生します。  
  
 イベントのハンドラーで発生するすべての例外を処理する必要があります、<xref:System.AppDomain.FirstChanceException>イベント。 それ以外の場合、<xref:System.AppDomain.FirstChanceException>発生を再帰的には、します。 これは、結果、スタック オーバーフローが発生し、アプリケーションが終了します。 例外の通知は、仮想マシンに影響を与えるからメモリ不足やスタック オーバーフローなどのインフラストラクチャに関連する例外を保持する、制約された実行領域 (Cer) として、このイベントのイベント ハンドラーを実装することをお勧めします。処理中です。  
  
 このイベントがない限り、イベント ハンドラーがセキュリティ クリティカルであり、アクセス違反など、プロセスの状態の破損を示す例外の発生しません、<xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute>属性。  
  
 この通知イベントが処理されるときに、共通言語ランタイムはスレッドの中止を中断します。  
  
   
  
## Examples  
 次の例は、一連のという名前のアプリケーション ドメインを作成`AD0`を通じて`AD3`で、`Worker`各アプリケーション ドメイン内のオブジェクト。 各`Worker`オブジェクトへの参照には、`Worker`以外の次のアプリケーション ドメイン内のオブジェクト、`Worker`最後のアプリケーション ドメインでします。 <xref:System.AppDomain.FirstChanceException>を除くすべてのアプリケーション ドメインでイベントを処理`AD1`します。  
  
> [!NOTE]
>  だけでなく、複数のアプリケーション ドメインで初回例外通知については、この例で単純なユース ケースが見つかります[方法: 初回例外通知の受信](~/docs/framework/app-domains/how-to-receive-first-chance-exception-notifications.md)します。  
  
 アプリケーション ドメインが作成されると、既定のアプリケーション ドメインが呼び出し、`TestException`メソッドの最初のアプリケーション ドメイン。 各`Worker`オブジェクトの呼び出し、`TestException`メソッドの最後まで、[次へ] のアプリケーション ドメイン`Worker`が処理または未処理の例外をスローします。 現在のスレッドがすべてのアプリケーション ドメインを通過するため、および`TestException`アプリケーション ドメインごとにスタックに追加されます。  
  
 ときに、最終`Worker`オブジェクト、例外を処理する、<xref:System.AppDomain.FirstChanceException>最後のアプリケーション ドメインでのみイベントが発生します。 他のアプリケーション ドメインでは、イベントは発生しませんので、例外を処理するためにされなくなります。  
  
 ときに、最後`Worker`オブジェクトが例外を処理していない、<xref:System.AppDomain.FirstChanceException>イベント ハンドラーを持っている各アプリケーション ドメインでイベントが発生します。 各イベント ハンドラーが完了すると、スタックがアンワインドの既定のアプリケーション ドメインで例外がキャッチされるまで続行されます。  
  
> [!NOTE]
>  イベントは近くの履歴の表示の拡大と既定のアプリケーション ドメインに近づけるためのを表示する変更`e.Exception.Message`に`e.Exception`で、`FirstChanceHandler`イベント ハンドラー。 そのときに注意してください`TestException`2 回表示されるアプリケーション ドメインの境界を越えて呼び出される: プロキシでスタブに 1 回です。  
  
 [!code-csharp[System.AppDomain.FirstChanceException#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.firstchanceexception/cs/example.cs#1)]
 [!code-vb[System.AppDomain.FirstChanceException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.firstchanceexception/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</permission>
        <altmember cref="T:System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs" />
        <altmember cref="E:System.AppDomain.UnhandledException" />
        <related type="Article" href="https://msdn.microsoft.com/library/66f002b8-a97d-4a6e-a503-2cec01689113">方法: 初回例外通知を受け取る</related>
      </Docs>
    </Member>
    <Member MemberName="FriendlyName">
      <MemberSignature Language="C#" Value="public string FriendlyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FriendlyName" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.FriendlyName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FriendlyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FriendlyName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FriendlyName : string" Usage="System.AppDomain.FriendlyName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.FriendlyName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーション ドメインの表示名を取得します。</summary>
        <value>アプリケーション ドメインの表示名。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既定のアプリケーション ドメインのフレンドリ名は、プロセス実行可能ファイルのファイル名です。 たとえば、プロセスを開始する実行可能ファイルが使用されている場合は`"c:\MyAppDirectory\MyAssembly.exe"`、既定のアプリケーション ドメインのフレンドリ名は`"MyAssembly.exe"`します。  
  
   
  
## Examples  
 次のコード例では、<xref:System.AppDomain.FriendlyName%2A>プロパティを現在のアプリケーション ドメインのわかりやすい名前を取得します。 既定のアプリケーション ドメインのフレンドリ名は、アプリケーションの実行可能ファイルの名前です。 コード例では、アプリケーション ドメインに関する追加情報も表示されます。  
  
 [!code-cpp[ADApplicationBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADApplicationBase/CPP/adapplicationbase.cpp#1)]
 [!code-csharp[ADApplicationBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADApplicationBase/CS/adapplicationbase.cs#1)]
 [!code-vb[ADApplicationBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADApplicationBase/VB/adapplicationbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作が試行されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAssemblies">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly[] GetAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly[] GetAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAssemblies () As Assembly()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Assembly ^&gt; ^ GetAssemblies();" />
      <MemberSignature Language="F#" Value="abstract member GetAssemblies : unit -&gt; System.Reflection.Assembly[]&#xA;override this.GetAssemblies : unit -&gt; System.Reflection.Assembly[]" Usage="appDomain.GetAssemblies " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetAssemblies</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>アプリケーション ドメインの実行コンテキストに読み込まれているアセンブリを取得します。</summary>
        <returns>アプリケーション ドメイン内のアセンブリの配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例では、<xref:System.AppDomain.GetAssemblies%2A>アプリケーション ドメインに読み込まれているすべてのアセンブリの一覧を取得します。 アセンブリは、コンソールに表示されます。  
  
 このコード例を実行するという名前のアセンブリを作成する必要があります。 `CustomLibrary.dll`、に渡されるアセンブリ名を変更したり、<xref:System.AppDomain.GetAssemblies%2A>メソッド。  
  
 [!code-cpp[ADGetAssemblies#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADGetAssemblies/CPP/adgetassemblies.cpp#1)]
 [!code-csharp[ADGetAssemblies#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADGetAssemblies/CS/adgetassemblies.cs#1)]
 [!code-vb[ADGetAssemblies#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADGetAssemblies/VB/adgetassemblies.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作が試行されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentThreadId">
      <MemberSignature Language="C#" Value="public static int GetCurrentThreadId ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetCurrentThreadId() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetCurrentThreadId" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentThreadId () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetCurrentThreadId();" />
      <MemberSignature Language="F#" Value="static member GetCurrentThreadId : unit -&gt; int" Usage="System.AppDomain.GetCurrentThreadId " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("AppDomain.GetCurrentThreadId has been deprecated because it does not provide a stable Id when managed threads are running on fibers (aka lightweight threads). To get a stable identifier for a managed thread, use the ManagedThreadId property on Thread.'")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Obsolete("AppDomain.GetCurrentThreadId has been deprecated because it does not provide a stable Id when managed threads are running on fibers (aka lightweight threads). To get a stable identifier for a managed thread, use the ManagedThreadId property on Thread.  http://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のスレッドの識別子を取得します。</summary>
        <returns>現在のスレッドの識別子を表す 32 ビット符号付き整数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType>プロパティは、.NET Framework がファイバー (つまり、簡易スレッド) をサポートする環境でホストされている場合にも安定しています。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">このメソッドを呼び出す。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> (関連する列挙体) セキュリティ アクション:<see cref="F:System.Security.Permissions.SecurityAction.Demand" />します。</permission>
        <altmember cref="T:System.Int32" />
        <altmember cref="P:System.Threading.Thread.ManagedThreadId" />
      </Docs>
    </Member>
    <Member MemberName="GetData">
      <MemberSignature Language="C#" Value="public object GetData (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetData(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetData(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetData (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetData(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetData : string -&gt; obj&#xA;override this.GetData : string -&gt; obj" Usage="appDomain.GetData name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetData(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">あらかじめ定義されたアプリケーション ドメイン プロパティの名前、または独自に定義したアプリケーション ドメイン プロパティの名前。</param>
        <summary>現在のアプリケーション ドメイン内に格納されている、指定した名前の値を取得します。</summary>
        <returns>
          <paramref name="name" /> プロパティの値。プロパティが存在しない場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このインスタンスのプロパティを説明する名前とデータのペアの内部キャッシュ内のエントリの値を取得するには、このメソッドを使用して<xref:System.AppDomain>します。 なお、比較の`name`をキーと値のペアの名前は大文字小文字を区別します。  
  
 キャッシュには、アプリケーション ドメインの作成時に挿入される定義済みのシステム エントリに自動的に含まれています。 その値を検査することができます、<xref:System.AppDomain.GetData%2A>メソッド、または同等<xref:System.AppDomainSetup>プロパティ。  
  
 挿入すると、独自のユーザー定義名前とデータ ペアの変更、<xref:System.AppDomain.SetData%2A>メソッドでは、その値を検査し、<xref:System.AppDomain.GetData%2A>メソッド。  
  
 次の表、`name`の各システム エントリとそれに対応する定義済みの<xref:System.AppDomainSetup>プロパティ。  
  
|'Name' の値|プロパティ|  
|---------------------|--------------|  
|"APPBASE"|<xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>|  
|"APP_CONFIG_FILE"|<xref:System.AppDomainSetup.ConfigurationFile%2A?displayProperty=nameWithType>|  
|"APP_LAUNCH_URL"|(プロパティなし)<br /><br /> "APP_LAUNCH_URL"は、リダイレクトする前に、ユーザーによって要求された URL を表します。 アプリケーションが Internet Explorer などのブラウザーで起動された場合にのみ使用可能なは。 すべてのブラウザーでは、この値を指定します。|  
|"APP_NAME"|<xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType>|  
|"BINPATH_PROBE_ONLY"|<xref:System.AppDomainSetup.PrivateBinPathProbe%2A?displayProperty=nameWithType>|  
|"CACHE_BASE"|<xref:System.AppDomainSetup.CachePath%2A?displayProperty=nameWithType>|  
|"CODE_DOWNLOAD_DISABLED"|<xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=nameWithType>|  
|"DEV_PATH"|(プロパティなし)|  
|"DISALLOW_APP"|<xref:System.AppDomainSetup.DisallowPublisherPolicy%2A?displayProperty=nameWithType>|  
|"DISALLOW_APP_BASE_PROBING"|<xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A?displayProperty=nameWithType>|  
|"DISALLOW_APP_REDIRECTS"|<xref:System.AppDomainSetup.DisallowBindingRedirects%2A?displayProperty=nameWithType>|  
|"DYNAMIC_BASE"|<xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType>|  
|"FORCE_CACHE_INSTALL"|<xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=nameWithType>|  
|"LICENSE_FILE"、またはアプリケーション固有の文字列|<xref:System.AppDomainSetup.LicenseFile%2A?displayProperty=nameWithType>|  
|"LOADER_OPTIMIZATION"|<xref:System.AppDomainSetup.LoaderOptimization%2A?displayProperty=nameWithType>|  
|"LOCATION_URI"|(プロパティなし)|  
|「場合」|<xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>|  
|"REGEX_DEFAULT_MATCH_TIMEOUT"|<xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A?displayProperty=nameWithType><br /><br /> "REGEX_DEFAULT_MATCH_TIMEOUT"はシステムのエントリではありませんし、呼び出すことによってその値を設定することができます、<xref:System.AppDomain.SetData%2A>メソッド。|  
|"SHADOW_COPY_DIRS"|<xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=nameWithType>|  
  
   
  
## Examples  
 次の例では、新しいアプリケーション ドメインを作成するには、ドメインのシステム指定の値を設定およびドメインの新しい値のペアを追加します。 例では、しを使用する方法を示します、<xref:System.AppDomain.GetData%2A>これらの値のペアからデータを取得し、それらをコンソールに表示します。  
  
 [!code-cpp[ADGetData#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADGetData/CPP/adgetdata.cpp#1)]
 [!code-csharp[ADGetData#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADGetData/CS/adgetdata.cs#1)]
 [!code-vb[ADGetData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADGetData/VB/adgetdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作が試行されています。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">パス自体であるため、パスにプロパティが適用される場合の情報にアクセスします。 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> (関連する列挙体)</permission>
        <altmember cref="M:System.AppDomain.SetData(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="appDomain.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のインスタンスの型を取得します。</summary>
        <returns>現在のインスタンスの型。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.AppDomain.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>プロセス内のアプリケーション ドメインを一意に識別する整数を取得します。</summary>
        <value>アプリケーション ドメインを識別する整数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例では、2 つ目のアプリケーション ドメインを作成し、既定のドメインと、新しいドメインに関する情報を表示します。  
  
 [!code-cpp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CPP/System.AppDomain.IsDefaultAppDomain.cpp#1)]
 [!code-csharp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CS/source.cs#1)]
 [!code-vb[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InitializeLifetimeService">
      <MemberSignature Language="C#" Value="public override object InitializeLifetimeService ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object InitializeLifetimeService() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.InitializeLifetimeService" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function InitializeLifetimeService () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ InitializeLifetimeService();" />
      <MemberSignature Language="F#" Value="override this.InitializeLifetimeService : unit -&gt; obj" Usage="appDomain.InitializeLifetimeService " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.InitializeLifetimeService</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>リースが作成されないようにすることで、<see cref="T:System.AppDomain" /> に無期限の有効期間を指定します。</summary>
        <returns>常に <see langword="null" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作が試行されています。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="IsCompatibilitySwitchSet">
      <MemberSignature Language="C#" Value="public Nullable&lt;bool&gt; IsCompatibilitySwitchSet (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;bool&gt; IsCompatibilitySwitchSet(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsCompatibilitySwitchSet (value As String) As Nullable(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;bool&gt; IsCompatibilitySwitchSet(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.IsCompatibilitySwitchSet : string -&gt; Nullable&lt;bool&gt;" Usage="appDomain.IsCompatibilitySwitchSet value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">テストする互換性スイッチ。</param>
        <summary>いずれかの互換性スイッチが設定されているかどうか、設定されている場合は指定の互換性スイッチが設定されているかどうかを示す、null 許容のブール値を取得します。</summary>
        <returns>互換性スイッチが設定されていない場合は null 参照 (Visual Basic では <see langword="Nothing" />)。それ以外の場合は、<paramref name="value" /> で指定された互換性スイッチが設定されているかどうかを示すブール値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、現在のアプリケーション ドメインの指定された互換性スイッチが設定されているかどうかをテストします。 互換性スイッチは、(方法文字列が並べ替えられます)、通常、動作を復元するが、.NET Framework のバージョン間で変更されました。  呼び出すことによって設定されている、<xref:System.AppDomainSetup.SetCompatibilitySwitches%2A?displayProperty=nameWithType>メソッドは、アプリケーション ドメインを作成する前にします。  
  
 次の表では、.NET Framework の以前のバージョンの動作を復元する設定できる互換性スイッチの例を示します。  
  
|切り替え|説明|  
|------------|-------------|  
|"NetFx40_LegacySecurityPolicy"|コード アクセス セキュリティ (CAS)、[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]でこのアプリケーション ドメインを有効にします。 参照してください[ &lt;NetFx40_LegacySecurityPolicy&gt;要素](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md)します。|  
|"NetFx40_Legacy20SortingBehavior"|文字列の既定値を並べ替え、[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]はこのアプリケーション ドメインで有効にします。 その成功には、インストールされるように sort00001000.dll が必要です。 参照してください[ &lt;CompatSortNLSVersion&gt;要素](~/docs/framework/configure-apps/file-schema/runtime/compatsortnlsversion-element.md)します。|  
|"NetFx40_Legacy40SortingBehavior"|文字列の既定値を並べ替え、 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]Unicode 5.0 は、このアプリケーション ドメインで有効になっているとします。 その成功には、インストールする sort00060101.dll が必要です。|  
|"NetFx40_TimeSpanLegacyFormatMode"|<xref:System.TimeSpan> 書式設定の動作、[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]でこのアプリケーション ドメインを有効にします。  参照してください[ &lt;TimeSpan_LegacyFormatMode&gt;要素](~/docs/framework/configure-apps/file-schema/runtime/timespan-legacyformatmode-element.md)の"復元レガシ TimeSpan"の書式設定」、および、<xref:System.TimeSpan>トピック。|  
|"UseRandomizedStringHashAlgorithm"|ランタイムに文字列のハッシュ コードを計算する、アプリケーション ドメイン間で一貫したハッシュ コードを生成する 1 つのハッシュ アルゴリズムを使用する代わりのアプリケーション ドメインごと。 参照してください[ &lt;UseRandomizedStringHashAlgorithm&gt;要素](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md)します。|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.AppDomainSetup.SetCompatibilitySwitches(System.Collections.Generic.IEnumerable{System.String})" />
      </Docs>
    </Member>
    <Member MemberName="IsDefaultAppDomain">
      <MemberSignature Language="C#" Value="public bool IsDefaultAppDomain ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsDefaultAppDomain() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.IsDefaultAppDomain" />
      <MemberSignature Language="VB.NET" Value="Public Function IsDefaultAppDomain () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsDefaultAppDomain();" />
      <MemberSignature Language="F#" Value="member this.IsDefaultAppDomain : unit -&gt; bool" Usage="appDomain.IsDefaultAppDomain " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>アプリケーション ドメインが、プロセスの既定のアプリケーション ドメインであるかどうかを示す値を返します。</summary>
        <returns>現在の <see cref="T:System.AppDomain" /> オブジェクトがプロセスの既定のアプリケーション ドメインを表す場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 すべてのマネージ プロセスでは、既定のアプリケーション ドメインがあります。 既定のドメインで実行が開始されます。  
  
   
  
## Examples  
 次のコード例では、2 つ目のアプリケーション ドメインを作成し、既定のドメインと、新しいドメインに関する情報を表示します。  
  
 [!code-cpp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CPP/System.AppDomain.IsDefaultAppDomain.cpp#1)]
 [!code-csharp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CS/source.cs#1)]
 [!code-vb[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFinalizingForUnload">
      <MemberSignature Language="C#" Value="public bool IsFinalizingForUnload ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsFinalizingForUnload() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.IsFinalizingForUnload" />
      <MemberSignature Language="VB.NET" Value="Public Function IsFinalizingForUnload () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsFinalizingForUnload();" />
      <MemberSignature Language="F#" Value="member this.IsFinalizingForUnload : unit -&gt; bool" Usage="appDomain.IsFinalizingForUnload " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このアプリケーション ドメインがアンロード中で、これに含まれるオブジェクトが共通言語ランタイムによって終了処理されているかどうかを示します。</summary>
        <returns>アプリケーション ドメインがアンロード中で、共通言語ランタイムがファイナライザーの呼び出しを既に開始している場合は <see langword="true" />。これ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 オブジェクトのファイナライズ メソッドは、オブジェクトがガベージ コレクトされる前に必要なクリーンアップ操作を実行する機会を提供します。 終了後、オブジェクトがアクセスできるが無効な状態で、そのために使用できなくなります。 最終的には、ガベージ コレクションが完了し、オブジェクトを解放します。  
  
 オブジェクトのファイナライズ メソッドは、次の状況のいずれかで: ガベージ コレクション中に、共通言語ランタイムがシャット ダウンするとき、またはオブジェクトを含むアプリケーション ドメインがアンロードされます。 <xref:System.AppDomain.IsFinalizingForUnload%2A>メソッドを返します。`true`のみで最後のケースでは、これは返されません`true`ファイナライズ定期的なガベージ コレクションから、または CLR シャット ダウンからの結果の場合。  
  
> [!NOTE]
>  CLR シャット ダウンにより終了処理は、かどうかを調べるには、<xref:System.Environment.HasShutdownStarted%2A?displayProperty=nameWithType>プロパティ。 返します`true`終了処理は、アプリケーション ドメインがアンロードされるため、または、CLR がシャット ダウンする場合。  
  
 ドメインのアンロード中、終了メソッドで実行中に、静的フィールドによって参照され、終了メソッドを持つ別のオブジェクトにアクセスする可能性があります。 ただし、この操作を行いますアクセスされるオブジェクトが既にファイナライズされているため、確実にことはできません。  
  
> [!NOTE]
>  このルールの例外は、<xref:System.Console>クラスは、ストリーム オブジェクトを参照する静的フィールドが含まれていますが、常に、ドメインのアンロード、またはシステムのシャット ダウン中も、システム コンソールに記述できますように特別に実装されます。  
  
 オブジェクトのファイナライズ メソッドでこのメソッドを使用すると、オブジェクトを含むアプリケーション ドメインがアンロード中かどうかを判断します。 場合は、終了メソッドを持つ静的フィールドによって参照されるオブジェクトを確実にアクセスできません。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Environment.HasShutdownStarted" />
      </Docs>
    </Member>
    <Member MemberName="IsFullyTrusted">
      <MemberSignature Language="C#" Value="public bool IsFullyTrusted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFullyTrusted" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.IsFullyTrusted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFullyTrusted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFullyTrusted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFullyTrusted : bool" Usage="System.AppDomain.IsFullyTrusted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のアプリケーション ドメインに読み込まれたアセンブリが、完全に信頼された状態で実行されるかどうかを示す値を取得します。</summary>
        <value>現在のアプリケーション ドメインに読み込まれたアセンブリが、完全に信頼された状態で実行される場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは常に返します`true`デスクトップ上で実行されるアプリケーションの既定のアプリケーション ドメイン。 返します`false`サンド ボックス アプリケーション ドメインを使用して作成された、<xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType>アプリケーション ドメインに与えられるアクセス許可が完全な信頼と等価でない場合、メソッドのオーバー ロードします。  
  
   
  
## Examples  
 次の例で、<xref:System.AppDomain.IsFullyTrusted%2A>プロパティおよび<xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType>完全信頼と部分的に信頼されたアプリケーション ドメインのプロパティ。 完全に信頼されたアプリケーション ドメインでは、アプリケーションの既定のアプリケーション ドメインです。 使用して、部分的に信頼されたアプリケーション ドメインが作成された、<xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType>メソッドのオーバー ロードします。  
  
 この例では、`Worker`から派生したクラス<xref:System.MarshalByRefObject>ので、アプリケーション ドメイン境界を越えてマーシャ リングすることができます。 例は、作成、`Worker`既定のアプリケーション ドメイン内のオブジェクト。 呼び出して、`TestIsFullyTrusted`アプリケーション ドメインとアプリケーション ドメインに読み込まれている 2 つのアセンブリのプロパティ値を表示する方法: mscorlib は、.NET Framework とアセンブリの一部です。 両方のアセンブリが完全に信頼されたために、アプリケーション ドメインが完全に信頼されました。  
  
 例では、作成別`Worker`サンド ボックス アプリケーション ドメインと、もう一度呼び出し内のオブジェクト、`TestIsFullyTrusted`メソッド。 Mscorlib は、部分的に信頼されたアプリケーション ドメインであっても常に、信頼できるが、アセンブリが部分的に信頼されました。  
  
 [!code-csharp[System.AppDomain.IsFullyTrusted#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.isfullytrusted/cs/example.cs#1)]
 [!code-vb[System.AppDomain.IsFullyTrusted#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.isfullytrusted/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHomogenous">
      <MemberSignature Language="C#" Value="public bool IsHomogenous { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHomogenous" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.IsHomogenous" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsHomogenous As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsHomogenous { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsHomogenous : bool" Usage="System.AppDomain.IsHomogenous" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーション ドメインに読み込まれたすべてのアセンブリに付与されるアクセス許可セットが、現在のアプリケーション ドメインに存在するかどうかを示す値を取得します。</summary>
        <value>一貫して付与されるアクセス許可セットが現在のアプリケーション ドメインに存在する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティを返します`true`サンド ボックス アプリケーション ドメインを使用して作成された、<xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType>メソッドのオーバー ロードします。 サンド ボックス アプリケーション ドメインがある同種一連のアクセス許可。つまり、同じ一連の権限は、アプリケーション ドメインに読み込まれるすべての部分的に信頼されたアセンブリに与えられます。 必要に応じて、サンド ボックス アプリケーション ドメインには、この権限を設定して、代わりに完全な信頼で実行から除外される厳密な名前のアセンブリの一覧があります。  
  
 完全信頼コードで使用できる、<xref:System.AppDomain.PermissionSet%2A>サンド ボックス アプリケーション ドメインの同種の許可セットを決定するプロパティ。  
  
 このプロパティも返します`true`デスクトップ アプリケーションでの既定のアプリケーション ドメインのため、そのアプリケーション ドメインは、すべてのアセンブリに完全な信頼を付与します。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.AppDomain.PermissionSet" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在のアプリケーション ドメインに <see cref="T:System.Reflection.Assembly" /> を読み込みます。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (rawAssembly As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly);" />
      <MemberSignature Language="F#" Value="abstract member Load : byte[] -&gt; System.Reflection.Assembly&#xA;override this.Load : byte[] -&gt; System.Reflection.Assembly" Usage="appDomain.Load rawAssembly" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">生成されたアセンブリを含む COFF ベースのイメージである <see langword="byte" /> 型配列。</param>
        <summary>生成された <see cref="T:System.Reflection.Assembly" /> を含む COFF (Common Object File Format) ベースのイメージを使用して、<see cref="T:System.Reflection.Assembly" /> を読み込みます。</summary>
        <returns>読み込み済みのアセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 以降では、 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]、このメソッドを使用して読み込まれるアセンブリの信頼レベルは、アプリケーション ドメインの信頼レベルと同じです。  
  
 このメソッドは、現在のアプリケーション ドメインにアセンブリを読み込む場合にのみ使用する必要があります。 このメソッドが静的なを呼び出すことができない相互運用性の呼び出し元に、便宜上指定<xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>メソッド。 他のアプリケーション ドメインにアセンブリを読み込む場合などメソッドを使用して<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>します。  
  
 このメソッドのすべてのオーバー ロードする一般的な情報については、次を参照してください。、<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>メソッドのオーバー ロードします。  
  
   
  
## Examples  
 次の例では、生のアセンブリの読み込みの使用を示します。  
  
 このコード例を実行するには、完全修飾アセンブリ名を指定する必要があります。 完全修飾アセンブリ名を取得する方法については、次を参照してください。[アセンブリ名](~/docs/framework/app-domains/assembly-names.md)します。  
  
 [!code-cpp[AppDomain_LoadRaw#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_LoadRaw/CPP/loadraw.cpp#1)]
 [!code-csharp[AppDomain_LoadRaw#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_LoadRaw/CS/loadraw.cs#1)]
 [!code-vb[AppDomain_LoadRaw#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_LoadRaw/VB/loadraw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> は有効なアセンブリ名ではありません。  
  
または 
現在、Version 2.0 以降の共通言語ランタイムが読み込まれていますが、それよりも新しいバージョンを使用して <paramref name="rawAssembly" /> がコンパイルされています。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作しようとします。</exception>
        <exception cref="T:System.IO.FileLoadException">1 つのアセンブリまたはモジュールが 2 つの異なる証拠を使用して 2 回読み込まれました。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">ファイルまたはディレクトリからと、パス自体の情報にアクセスするための読み取りにアクセスします。 列挙体に関連付けられている: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />、<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />します。</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Reflection.AssemblyName)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyRef As AssemblyName) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly&#xA;override this.Load : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly" Usage="appDomain.Load assemblyRef" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Reflection.AssemblyName)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="assemblyRef">読み込むアセンブリについて記述しているオブジェクト。</param>
        <summary>
          <see cref="T:System.Reflection.Assembly" /> を指定して、<see cref="T:System.Reflection.AssemblyName" /> を読み込みます。</summary>
        <returns>読み込み済みのアセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、現在のアプリケーション ドメインにアセンブリを読み込む場合にのみ使用する必要があります。 このメソッドが静的なを呼び出すことができない相互運用性の呼び出し元に、便宜上指定<xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>メソッド。 他のアプリケーション ドメインにアセンブリを読み込む場合などメソッドを使用して<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>します。  
  
 要求されたアセンブリのバージョンが既に読み込まれている場合、このメソッドは、別のバージョンが要求された場合でも、読み込まれたアセンブリを返します。  
  
 部分的なアセンブリ名を指定して`assemblyRef`はお勧めしません。 (部分的な名前は、1 つまたは複数のカルチャ、バージョン、または公開キー トークンを省略します。 代わりに文字列を受け取るオーバー ロードの場合、<xref:System.Reflection.AssemblyName>オブジェクト、"MyAssembly, バージョン 1.0.0.0 を ="部分的な名前の例を示しますと"MyAssembly, バージョン 1.0.0.0、カルチャを = = neutral, PublicKeyToken = 18ab3442da84b47"完全な名前の例を示します)。パフォーマンスに悪影響を及ぼすが部分的な名前を使用します。 さらに、部分的なアセンブリ名はアセンブリを読み込むグローバル アセンブリ キャッシュからアプリケーション ベース ディレクトリ内のアセンブリの正確なコピーがある場合にのみ (<xref:System.AppDomain.BaseDirectory%2A>または<xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>)。  
  
 場合、現在<xref:System.AppDomain>オブジェクトは、アプリケーション ドメインを表す`A`、および<xref:System.AppDomain.Load%2A>メソッドの呼び出し元のアプリケーション ドメイン`B`アセンブリは両方のアプリケーション ドメインに読み込まれます。 たとえば、次のコードの読み込み`MyAssembly`新しいアプリケーション ドメインに`ChildDomain`とコードが実行されるアプリケーション ドメインにもします。  
  
 [!code-cpp[System.AppDomain.Load#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.appdomain.load/cpp/source.cpp#1)]
 [!code-csharp[System.AppDomain.Load#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.load/cs/source.cs#1)]
 [!code-vb[System.AppDomain.Load#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.load/vb/source.vb#1)]  
  
 両方のドメインにアセンブリが読み込まれる<xref:System.Reflection.Assembly>から派生していない<xref:System.MarshalByRefObject>、および戻り値のため、<xref:System.AppDomain.Load%2A>メソッドをマーシャ リングすることはできません。 代わりに、共通言語ランタイムは、呼び出し元のアプリケーション ドメインにアセンブリの読み込みを試みます。 2 つのアプリケーション ドメインに読み込まれるアセンブリは、2 つのアプリケーション ドメインのパスの設定が異なる場合は異なる可能性があります。  
  
> [!NOTE]
>  両方の場合、<xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType>プロパティと<xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType>プロパティが設定されて、アセンブリを読み込むには、最初の試行は、表示名を使用 (によって返されるバージョン、カルチャ、およびなどを含む、<xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType>プロパティ)。 ファイルが見つからない場合、<xref:System.Reflection.AssemblyName.CodeBase%2A>プロパティを使用して、アセンブリを検索します。 使用して、アセンブリが見つかった場合<xref:System.Reflection.AssemblyName.CodeBase%2A>表示名のアセンブリが照合されます。 一致が見つからない場合、<xref:System.IO.FileLoadException>がスローされます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyRef" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyRef" /> が見つかりません。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyRef" /> は有効なアセンブリではありません。  
  
または 
現在、Version 2.0 以降の共通言語ランタイムが読み込まれていますが、それよりも新しいバージョンを使用して <paramref name="assemblyRef" /> がコンパイルされています。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作しようとします。</exception>
        <exception cref="T:System.IO.FileLoadException">1 つのアセンブリまたはモジュールが 2 つの異なる証拠を使用して 2 回読み込まれました。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">ファイルまたはディレクトリからと、パス自体の情報にアクセスするための読み取りにアクセスします。 列挙体に関連付けられている: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />、<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />します。</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (string assemblyString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(string assemblyString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyString As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::String ^ assemblyString);" />
      <MemberSignature Language="F#" Value="abstract member Load : string -&gt; System.Reflection.Assembly&#xA;override this.Load : string -&gt; System.Reflection.Assembly" Usage="appDomain.Load assemblyString" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyString">アセンブリの表示名。 「<see cref="P:System.Reflection.Assembly.FullName" />」を参照してください。</param>
        <summary>表示名を指定して <see cref="T:System.Reflection.Assembly" /> を読み込みます。</summary>
        <returns>読み込み済みのアセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、現在のアプリケーション ドメインにアセンブリを読み込む場合にのみ使用する必要があります。 このメソッドが静的なを呼び出すことができない相互運用性の呼び出し元に、便宜上指定<xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>メソッド。 他のアプリケーション ドメインにアセンブリを読み込む場合などメソッドを使用して<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>します。  
  
 このメソッドのすべてのオーバー ロードする一般的な情報については、次を参照してください。、<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>メソッドのオーバー ロードします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyString" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyString" /> が見つかりません。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyString" /> は有効なアセンブリではありません。  
  
または 
現在、Version 2.0 以降の共通言語ランタイムが読み込まれていますが、それよりも新しいバージョンを使用して <paramref name="assemblyString" /> がコンパイルされています。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作しようとします。</exception>
        <exception cref="T:System.IO.FileLoadException">1 つのアセンブリまたはモジュールが 2 つの異なる証拠を使用して 2 回読み込まれました。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">ファイルまたはディレクトリからと、パス自体の情報にアクセスするための読み取りにアクセスします。 列挙体に関連付けられている: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />、<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />します。</permission>
        <permission cref="T:System.Net.WebPermission">アセンブリがローカルでない場合、アセンブリの場所にアクセスする機能。</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (rawAssembly As Byte(), rawSymbolStore As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore);" />
      <MemberSignature Language="F#" Value="abstract member Load : byte[] * byte[] -&gt; System.Reflection.Assembly&#xA;override this.Load : byte[] * byte[] -&gt; System.Reflection.Assembly" Usage="appDomain.Load (rawAssembly, rawSymbolStore)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Byte[],System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">生成されたアセンブリを含む COFF ベースのイメージである <see langword="byte" /> 型配列。</param>
        <param name="rawSymbolStore">アセンブリのシンボルを表す生バイトを格納している <see langword="byte" /> 型の配列。</param>
        <summary>生成された <see cref="T:System.Reflection.Assembly" /> を含む COFF (Common Object File Format) ベースのイメージを使用して、<see cref="T:System.Reflection.Assembly" /> を読み込みます。 <see cref="T:System.Reflection.Assembly" /> のシンボルを表す生バイトも読み込まれます。</summary>
        <returns>読み込み済みのアセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 以降では、 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]、このメソッドを使用して読み込まれるアセンブリの信頼レベルは、アプリケーション ドメインの信頼レベルと同じです。  
  
 このメソッドは、現在のアプリケーション ドメインにアセンブリを読み込む場合にのみ使用する必要があります。 このメソッドが静的なを呼び出すことができない相互運用性の呼び出し元に、便宜上指定<xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>メソッド。 他のアプリケーション ドメインにアセンブリを読み込む場合などメソッドを使用して<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>します。  
  
 このメソッドのすべてのオーバー ロードする一般的な情報については、次を参照してください。、<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>メソッドのオーバー ロードします。  
  
   
  
## Examples  
 次の例では、生のアセンブリの読み込みの使用を示します。  
  
 このコード例を実行するには、完全修飾アセンブリ名を指定する必要があります。 完全修飾アセンブリ名を取得する方法については、次を参照してください。[アセンブリ名](~/docs/framework/app-domains/assembly-names.md)します。  
  
 [!code-cpp[AppDomain_LoadRaw#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_LoadRaw/CPP/loadraw.cpp#1)]
 [!code-csharp[AppDomain_LoadRaw#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_LoadRaw/CS/loadraw.cs#1)]
 [!code-vb[AppDomain_LoadRaw#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_LoadRaw/VB/loadraw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> は有効なアセンブリ名ではありません。  
  
または 
現在、Version 2.0 以降の共通言語ランタイムが読み込まれていますが、それよりも新しいバージョンを使用して <paramref name="rawAssembly" /> がコンパイルされています。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作しようとします。</exception>
        <exception cref="T:System.IO.FileLoadException">1 つのアセンブリまたはモジュールが 2 つの異なる証拠を使用して 2 回読み込まれました。</exception>
        <permission cref="T:System.Net.WebPermission">file:// で始まらないする URI を読み取る。</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">ファイルまたはディレクトリからと、パス自体の情報にアクセスするための読み取りにアクセスします。 列挙体に関連付けられている: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />、<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />します。</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyRef As AssemblyName, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.Reflection.AssemblyName * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly&#xA;override this.Load : System.Reflection.AssemblyName * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="appDomain.Load (assemblyRef, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyRef">読み込むアセンブリについて記述しているオブジェクト。</param>
        <param name="assemblySecurity">アセンブリを読み込むために必要な証拠。</param>
        <summary>
          <see cref="T:System.Reflection.Assembly" /> を指定して、<see cref="T:System.Reflection.AssemblyName" /> を読み込みます。</summary>
        <returns>読み込み済みのアセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、現在のアプリケーション ドメインにアセンブリを読み込む場合にのみ使用する必要があります。 このメソッドが静的なを呼び出すことができない相互運用性の呼び出し元に、便宜上指定<xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>メソッド。 他のアプリケーション ドメインにアセンブリを読み込む場合などメソッドを使用して<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>します。  
  
 このメソッドのすべてのオーバー ロードする一般的な情報については、次を参照してください。、<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>メソッドのオーバー ロードします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyRef" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyRef" /> が見つかりません。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyRef" /> は有効なアセンブリではありません。  
  
または 
現在、Version 2.0 以降の共通言語ランタイムが読み込まれていますが、それよりも新しいバージョンを使用して <paramref name="assemblyRef" /> がコンパイルされています。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作しようとします。</exception>
        <exception cref="T:System.IO.FileLoadException">1 つのアセンブリまたはモジュールが 2 つの異なる証拠を使用して 2 回読み込まれました。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">ファイルまたはディレクトリからと、パス自体の情報にアクセスするための読み取りにアクセスします。 列挙体に関連付けられている: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />、<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />します。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">証拠とアセンブリの読み込み。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /> (関連する列挙体)</permission>
        <permission cref="T:System.Net.WebPermission">file:// フォームではないパスを読み取るため、または"\\\UNC\dir\\"または"c:\\"。</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (string assemblyString, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(string assemblyString, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyString As String, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::String ^ assemblyString, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="abstract member Load : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly&#xA;override this.Load : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="appDomain.Load (assemblyString, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.String,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyString">アセンブリの表示名。 「<see cref="P:System.Reflection.Assembly.FullName" />」を参照してください。</param>
        <param name="assemblySecurity">アセンブリを読み込むために必要な証拠。</param>
        <summary>表示名を指定して <see cref="T:System.Reflection.Assembly" /> を読み込みます。</summary>
        <returns>読み込み済みのアセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、現在のアプリケーション ドメインにアセンブリを読み込む場合にのみ使用する必要があります。 このメソッドが静的なを呼び出すことができない相互運用性の呼び出し元に、便宜上指定<xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>メソッド。 他のアプリケーション ドメインにアセンブリを読み込む場合などメソッドを使用して<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>します。  
  
 このメソッドのすべてのオーバー ロードする一般的な情報については、次を参照してください。、<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>メソッドのオーバー ロードします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyString" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyString" /> が見つかりません。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyString" /> は有効なアセンブリではありません。  
  
または 
現在、Version 2.0 以降の共通言語ランタイムが読み込まれていますが、それよりも新しいバージョンを使用して <paramref name="assemblyString" /> がコンパイルされています。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作しようとします。</exception>
        <exception cref="T:System.IO.FileLoadException">1 つのアセンブリまたはモジュールが 2 つの異なる証拠を使用して 2 回読み込まれました。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">証拠とアセンブリの読み込み。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /> (関連する列挙体)</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">ファイルまたはディレクトリからと、パス自体の情報にアクセスするための読み取りにアクセスします。 列挙体に関連付けられている: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />、<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />します。</permission>
        <permission cref="T:System.Net.WebPermission">file:// フォームではないパスを読み取るため、または"\\\UNC\dir\\"または"c:\\"。</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (rawAssembly As Byte(), rawSymbolStore As Byte(), securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="abstract member Load : byte[] * byte[] * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly&#xA;override this.Load : byte[] * byte[] * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="appDomain.Load (rawAssembly, rawSymbolStore, securityEvidence)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkId=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">生成されたアセンブリを含む COFF ベースのイメージである <see langword="byte" /> 型配列。</param>
        <param name="rawSymbolStore">アセンブリのシンボルを表す生バイトを格納している <see langword="byte" /> 型の配列。</param>
        <param name="securityEvidence">アセンブリを読み込むために必要な証拠。</param>
        <summary>生成された <see cref="T:System.Reflection.Assembly" /> を含む COFF (Common Object File Format) ベースのイメージを使用して、<see cref="T:System.Reflection.Assembly" /> を読み込みます。 <see cref="T:System.Reflection.Assembly" /> のシンボルを表す生バイトも読み込まれます。</summary>
        <returns>読み込み済みのアセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 以降では、 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]、このメソッドを使用して読み込まれるアセンブリの信頼レベルは、アプリケーション ドメインの信頼レベルと同じです。  
  
 このメソッドは、現在のアプリケーション ドメインにアセンブリを読み込む場合にのみ使用する必要があります。 このメソッドが静的なを呼び出すことができない相互運用性の呼び出し元に、便宜上指定<xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>メソッド。 他のアプリケーション ドメインにアセンブリを読み込む場合などメソッドを使用して<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>します。  
  
 このメソッドのすべてのオーバー ロードする一般的な情報については、次を参照してください。、<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>メソッドのオーバー ロードします。  
  
   
  
## Examples  
 次の例では、生のアセンブリの読み込みの使用を示します。  
  
 このコード例を実行するには、完全修飾アセンブリ名を指定する必要があります。 完全修飾アセンブリ名を取得する方法については、次を参照してください。[アセンブリ名](~/docs/framework/app-domains/assembly-names.md)します。  
  
 [!code-cpp[AppDomain_LoadRaw#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_LoadRaw/CPP/loadraw.cpp#1)]
 [!code-csharp[AppDomain_LoadRaw#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_LoadRaw/CS/loadraw.cs#1)]
 [!code-vb[AppDomain_LoadRaw#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_LoadRaw/VB/loadraw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> は有効なアセンブリ名ではありません。  
  
または 
現在、Version 2.0 以降の共通言語ランタイムが読み込まれていますが、それよりも新しいバージョンを使用して <paramref name="rawAssembly" /> がコンパイルされています。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作しようとします。</exception>
        <exception cref="T:System.IO.FileLoadException">1 つのアセンブリまたはモジュールが 2 つの異なる証拠を使用して 2 回読み込まれました。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="securityEvidence" /> が <see langword="null" /> ではありません。 レガシ CAS ポリシーが有効になっていない場合は、<paramref name="securityEvidence" /> を <see langword="null" /> にする必要があります。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">証拠を提供します。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /> (関連する列挙体) セキュリティ アクション:<see cref="F:System.Security.Permissions.SecurityAction.Demand" />します。</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">ファイルまたはディレクトリからと、パス自体の情報にアクセスするための読み取りにアクセスします。 列挙体に関連付けられている: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />、<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />します。</permission>
        <permission cref="T:System.Net.WebPermission">file:// フォームではないパスを読み取るため、または"\\\UNC\dir\\"または"c:\\"。</permission>
      </Docs>
    </Member>
    <Member MemberName="MonitoringIsEnabled">
      <MemberSignature Language="C#" Value="public static bool MonitoringIsEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool MonitoringIsEnabled" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringIsEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property MonitoringIsEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool MonitoringIsEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringIsEnabled : bool with get, set" Usage="System.AppDomain.MonitoringIsEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のプロセスに対して、アプリケーション ドメインの CPU およびメモリの監視が有効になっているかどうかを示す値を取得または設定します。 プロセスに対して一度有効にした監視を無効にすることはできません。</summary>
        <value>監視が有効になっている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 これは、`static`プロパティ (`Shared`プロパティ Visual Basic) CPU とメモリがプロセス内のすべてのアプリケーション ドメインの監視を制御します。  
  
 このプロパティを設定しようとした場合`false`、<xref:System.ArgumentException>例外がスローされた場合でも、プロパティの現在の値が`false`します。  
  
 使用することができますの監視を有効にすると、 <xref:System.AppDomain.MonitoringSurvivedMemorySize%2A>、 <xref:System.AppDomain.MonitoringSurvivedProcessMemorySize%2A>、<xref:System.AppDomain.MonitoringTotalAllocatedMemorySize%2A>と<xref:System.AppDomain.MonitoringTotalProcessorTime%2A>インスタンスのプロパティの個々 のアプリケーション ドメインの CPU とメモリの使用状況を監視します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">現在のプロセスは、このプロパティに値 <see langword="false" /> を代入しようとしました。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/318bedf8-7f35-4f00-b34a-2b7b8e3fa315">アプリケーション ドメインのリソース監視</related>
        <related type="Article" href="https://msdn.microsoft.com/library/02119ab6-1e91-448e-97ad-e7b2e5c4bbbd">&lt;appdomainResourceMonitoring&gt;要素</related>
      </Docs>
    </Member>
    <Member MemberName="MonitoringSurvivedMemorySize">
      <MemberSignature Language="C#" Value="public long MonitoringSurvivedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MonitoringSurvivedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringSurvivedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MonitoringSurvivedMemorySize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MonitoringSurvivedMemorySize { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringSurvivedMemorySize : int64" Usage="System.AppDomain.MonitoringSurvivedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>最後のコレクションの実行後に残された、現在のアプリケーション ドメインによって参照されていることが判明しているバイト数を取得します。</summary>
        <value>残っているバイト数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 統計情報は、各ガベージ コレクションが更新されます。 ただし、完全なブロッキング コレクションの後にのみ正確である保証は、つまり、コレクションの中に、アプリケーションが停止するを含むすべてのジェネレーションのコレクションが発生します。 たとえば、<xref:System.GC.Collect?displayProperty=nameWithType>メソッドのオーバー ロードは、完全なブロッキング コレクションを実行します。 (同時実行コレクションはバック グラウンドで発生して、アプリケーションはブロックされません)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see langword="static" /> (Visual Basic の場合は <see langword="Shared" />) の <see cref="P:System.AppDomain.MonitoringIsEnabled" /> プロパティは <see langword="false" /> に設定されています。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/318bedf8-7f35-4f00-b34a-2b7b8e3fa315">アプリケーション ドメインのリソース監視</related>
      </Docs>
    </Member>
    <Member MemberName="MonitoringSurvivedProcessMemorySize">
      <MemberSignature Language="C#" Value="public static long MonitoringSurvivedProcessMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 MonitoringSurvivedProcessMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringSurvivedProcessMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MonitoringSurvivedProcessMemorySize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long MonitoringSurvivedProcessMemorySize { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringSurvivedProcessMemorySize : int64" Usage="System.AppDomain.MonitoringSurvivedProcessMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>最後のコレクションの実行後に残された、プロセス内のすべてのアプリケーション ドメインにおける合計バイト数を取得します。</summary>
        <value>プロセスに残っている合計バイト数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 完全なブロッキング コレクションの後にこの番号を表すバイトの数は現在上でライブで保持マネージ ヒープを使用します。 によって報告される数に近いことが、<xref:System.GC.GetTotalMemory%2A>メソッド。 短期コレクションの後にこの番号を表すバイト数の現在保持されている短期のジェネレーションにライブします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see langword="static" /> (Visual Basic の場合は <see langword="Shared" />) の <see cref="P:System.AppDomain.MonitoringIsEnabled" /> プロパティは <see langword="false" /> に設定されています。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/318bedf8-7f35-4f00-b34a-2b7b8e3fa315">アプリケーション ドメインのリソース監視</related>
      </Docs>
    </Member>
    <Member MemberName="MonitoringTotalAllocatedMemorySize">
      <MemberSignature Language="C#" Value="public long MonitoringTotalAllocatedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MonitoringTotalAllocatedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringTotalAllocatedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MonitoringTotalAllocatedMemorySize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MonitoringTotalAllocatedMemorySize { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringTotalAllocatedMemorySize : int64" Usage="System.AppDomain.MonitoringTotalAllocatedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーション ドメインが作成されてから、そのアプリケーション ドメインで実行されたすべてのメモリ割り当ての合計サイズをバイト単位で取得します。収集されたメモリは差し引かれません。</summary>
        <value>すべてのメモリ割り当ての合計サイズ。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">
          <see langword="static" /> (Visual Basic の場合は <see langword="Shared" />) の <see cref="P:System.AppDomain.MonitoringIsEnabled" /> プロパティは <see langword="false" /> に設定されています。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/318bedf8-7f35-4f00-b34a-2b7b8e3fa315">アプリケーション ドメインのリソース監視</related>
      </Docs>
    </Member>
    <Member MemberName="MonitoringTotalProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan MonitoringTotalProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan MonitoringTotalProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringTotalProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MonitoringTotalProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan MonitoringTotalProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringTotalProcessorTime : TimeSpan" Usage="System.AppDomain.MonitoringTotalProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>プロセスが開始されてから、現在のアプリケーション ドメインでの実行中にすべてのスレッドで使用された合計プロセッサ時間を取得します。</summary>
        <value>現在のアプリケーション ドメインの合計プロセッサ時間。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 アプリケーション ドメインの報告される合計時間には、プロセス内の各スレッドは、そのアプリケーション ドメインで実行に費やされた時間が含まれます。  
  
 アンマネージ コードを呼び出すスレッドは、アプリケーション ドメインに関連付けられたままとアンマネージ コードは、呼び出しが行われたアプリケーション ドメインの報告の実行にかかったプロセッサ時間です。  
  
 ときにスレッドがブロックされているかがスリープ状態を使用せずプロセッサ時間。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see langword="static" /> (Visual Basic の場合は <see langword="Shared" />) の <see cref="P:System.AppDomain.MonitoringIsEnabled" /> プロパティは <see langword="false" /> に設定されています。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/318bedf8-7f35-4f00-b34a-2b7b8e3fa315">アプリケーション ドメインのリソース監視</related>
      </Docs>
    </Member>
    <Member MemberName="PermissionSet">
      <MemberSignature Language="C#" Value="public System.Security.PermissionSet PermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet PermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.PermissionSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PermissionSet As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::PermissionSet ^ PermissionSet { System::Security::PermissionSet ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PermissionSet : System.Security.PermissionSet" Usage="System.AppDomain.PermissionSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>サンドボックス化されたアプリケーション ドメインのアクセス許可セットを取得します。</summary>
        <value>サンドボックス化されたアプリケーション ドメインのアクセス許可セット。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 サンド ボックス アプリケーション ドメインを使用して作成された、<xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType>メソッドのオーバー ロードがある、権限のセットを同種; は、同じ一連の権限がアプリケーション ドメインに読み込まれるすべての部分的に信頼されたアセンブリに付与されます。 必要に応じて、サンド ボックス アプリケーション ドメインには、この権限を設定して、代わりに完全な信頼で実行から除外される厳密な名前のアセンブリの一覧があります。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</permission>
        <altmember cref="P:System.AppDomain.IsHomogenous" />
      </Docs>
    </Member>
    <Member MemberName="ProcessExit">
      <MemberSignature Language="C#" Value="public event EventHandler ProcessExit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ProcessExit" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.ProcessExit" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ProcessExit As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ ProcessExit;" />
      <MemberSignature Language="F#" Value="member this.ProcessExit : EventHandler " Usage="member this.ProcessExit : System.EventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.ProcessExit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>remove: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>既定のアプリケーション ドメインの親プロセスが終了した場合に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.EventHandler>このイベントは、ファイルを閉じるなどの終了活動を実行できるの解放ストレージで、プロセスが終了する前にします。  
  
 以降、.NET Framework version 2.0 では、このイベントはイベント ハンドラーを登録する各アプリケーション ドメインで発生します。  
  
> [!NOTE]
>  すべての合計実行時間<xref:System.AppDomain.ProcessExit>すべてのファイナライザーの合計実行時間がプロセスのシャット ダウンの制限と同様、イベント ハンドラーが限られています。 既定では 2 秒です。 アンマネージ ホストは呼び出すことでこの実行時間を変更することができます、 [iclrpolicymanager::settimeout](~/docs/framework/unmanaged-api/hosting/iclrpolicymanager-settimeout-method.md)メソッドを[OPR_ProcessExit](~/docs/framework/unmanaged-api/hosting/eclroperation-enumeration.md)列挙値。  
  
 .NET Framework バージョン 1.0 および 1.1 では、このイベントは、既定のアプリケーション ドメインでのみ発生し、イベント ハンドラーが既定のアプリケーション ドメインに登録されている場合にのみです。  
  
 このイベントのイベント ハンドラーを登録するには、必要なアクセス許可が必要または<xref:System.Security.SecurityException>がスローされます。  
  
 イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyAssemblyResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler ReflectionOnlyAssemblyResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler ReflectionOnlyAssemblyResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.ReflectionOnlyAssemblyResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ReflectionOnlyAssemblyResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event ResolveEventHandler ^ ReflectionOnlyAssemblyResolve;" />
      <MemberSignature Language="F#" Value="member this.ReflectionOnlyAssemblyResolve : ResolveEventHandler " Usage="member this.ReflectionOnlyAssemblyResolve : System.ResolveEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>リフレクション専用のコンテキストでアセンブリの解決に失敗した場合に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 リフレクションのみのコンテキストでの依存関係は自動的に解決されません。 これらは、プリロードする必要があります。 またはこのイベントのハンドラーによって返されます。 アセンブリがリフレクションのみのコンテキストに既に読み込まれていない依存関係を持つ場合は、このイベントが発生します。 依存関係の欠落がで指定された、<xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType>プロパティ。 <xref:System.ResolveEventHandler>のこのイベントは、依存関係を満たすアセンブリを返す必要があります。 返されるアセンブリは、リフレクション専用コンテキストに読み込まれる必要があります。  
  
> [!IMPORTANT]
>  このイベントは、リフレクション専用コンテキストに読み込むアセンブリの依存関係がないに対してのみ発生します (たとえばを使用して、<xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType>メソッド)。 読み込むアセンブリが見つからない場合は発生しません。  
  
 以降では、 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]、<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>プロパティは、解決できなかったアセンブリの読み込みを要求したアセンブリを返します。 要求元のアセンブリの id を知ることは、1 つ以上のバージョンが利用可能な場合に、依存関係の正しいバージョンを特定するのに役立ちますに可能性があります。 詳細については、「<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>」を参照してください。  
  
 このイベントで、<xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType>プロパティは、ポリシーが適用される前に、アセンブリ名を返します。  
  
 イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyGetAssemblies">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly[] ReflectionOnlyGetAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly[] ReflectionOnlyGetAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ReflectionOnlyGetAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Function ReflectionOnlyGetAssemblies () As Assembly()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::Assembly ^&gt; ^ ReflectionOnlyGetAssemblies();" />
      <MemberSignature Language="F#" Value="member this.ReflectionOnlyGetAssemblies : unit -&gt; System.Reflection.Assembly[]" Usage="appDomain.ReflectionOnlyGetAssemblies " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>アプリケーション ドメインのリフレクション専用コンテキストに読み込まれているアセンブリを返します。</summary>
        <returns>アプリケーション ドメインのリフレクション専用コンテキストに読み込まれているアセンブリを表す <see cref="T:System.Reflection.Assembly" /> オブジェクトの配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、リフレクション専用コンテキストに読み込まれているアセンブリを返します。 読み込まれたアセンブリの実行を取得するを使用して、<xref:System.AppDomain.GetAssemblies%2A>メソッド。  
  
   
  
## Examples  
 実行コンテキストにし、さらに、リフレクション専用コンテキストに、次のコード例は、System.dll アセンブリを読み込みます。 <xref:System.AppDomain.GetAssemblies%2A>と<xref:System.AppDomain.ReflectionOnlyGetAssemblies%2A>メソッドを使用して、それぞれのコンテキストに読み込まれるアセンブリを表示します。  
  
 [!code-cpp[AppDomain.ReflectionOnlyGetAssemblies#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain.ReflectionOnlyGetAssemblies/CPP/reflectiononly.cpp#1)]
 [!code-csharp[AppDomain.ReflectionOnlyGetAssemblies#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain.ReflectionOnlyGetAssemblies/CS/reflectiononly.cs#1)]
 [!code-vb[AppDomain.ReflectionOnlyGetAssemblies#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain.ReflectionOnlyGetAssemblies/VB/reflectiononly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作が試行されています。</exception>
        <altmember cref="M:System.AppDomain.GetAssemblies" />
      </Docs>
    </Member>
    <Member MemberName="RelativeSearchPath">
      <MemberSignature Language="C#" Value="public string RelativeSearchPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RelativeSearchPath" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.RelativeSearchPath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RelativeSearchPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RelativeSearchPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RelativeSearchPath : string" Usage="System.AppDomain.RelativeSearchPath" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.RelativeSearchPath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アセンブリ リゾルバーがプライベート アセンブリを探す場所を示す、ベース ディレクトリ以下のパスを取得します。</summary>
        <value>アセンブリ リゾルバーがプライベート アセンブリを探す場所を示す、ベース ディレクトリ以下のパス。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プライベート アセンブリは、アプリケーションと同じディレクトリ構造にデプロイされます。 パスが指定されている場合、<xref:System.AppDomain.RelativeSearchPath%2A>プロパティが  <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>、無視されます。  
  
 このプロパティを使用して設定値を返します<xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作が試行されています。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">パス情報にアクセスします。 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> (関連する列挙体)</permission>
        <altmember cref="P:System.AppDomainSetup.PrivateBinPath" />
      </Docs>
    </Member>
    <Member MemberName="ResourceResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler ResourceResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler ResourceResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.ResourceResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ResourceResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event ResolveEventHandler ^ ResourceResolve;" />
      <MemberSignature Language="F#" Value="member this.ResourceResolve : ResolveEventHandler " Usage="member this.ResourceResolve : System.ResolveEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.ResourceResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>リソースが正しくリンクされていなかったり、アセンブリに埋め込まれているなどの理由からリソースの解決に失敗した場合に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ResolveEventHandler>のこのイベントは、リソースを含むアセンブリを検索し、返すことを試みることができます。  
  
> [!IMPORTANT]
>  有効なリンクされたリソースのファイルが見つからなかったため、解決が失敗した場合、このイベントは発生しません。 イベントは、マニフェスト リソース ストリームが見つかりませんが、個別のリソース キーが見つからない場合は発生しません。  
  
 以降では、 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]、<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>プロパティには、リソースを要求したアセンブリが含まれています。 詳細については、「<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>」を参照してください。  
  
 このイベントのイベント ハンドラーを登録するには、必要なアクセス許可が必要または<xref:System.Security.SecurityException>がスローされます。  
  
 イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="SetAppDomainPolicy">
      <MemberSignature Language="C#" Value="public void SetAppDomainPolicy (System.Security.Policy.PolicyLevel domainPolicy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAppDomainPolicy(class System.Security.Policy.PolicyLevel domainPolicy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAppDomainPolicy (domainPolicy As PolicyLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAppDomainPolicy(System::Security::Policy::PolicyLevel ^ domainPolicy);" />
      <MemberSignature Language="F#" Value="member this.SetAppDomainPolicy : System.Security.Policy.PolicyLevel -&gt; unit" Usage="appDomain.SetAppDomainPolicy domainPolicy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("AppDomain policy levels are obsolete")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("AppDomain policy levels are obsolete and will be removed in a future release of the .NET Framework. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domainPolicy" Type="System.Security.Policy.PolicyLevel" />
      </Parameters>
      <Docs>
        <param name="domainPolicy">セキュリティ ポリシー レベル。</param>
        <summary>アプリケーション ドメインのセキュリティ ポリシー レベルを設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 アセンブリに読み込まれる前に、このメソッドを呼び出す、<xref:System.AppDomain>効果がセキュリティ ポリシーの順序で。  
  
   
  
## Examples  
 次の例では、使用する方法、<xref:System.AppDomain.SetAppDomainPolicy%2A>アプリケーション ドメインのセキュリティ ポリシー レベルを設定します。  
  
 [!code-cpp[ADSetAppDomainPolicy#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADSetAppDomainPolicy/CPP/adsetappdomainpolicy.cpp#1)]
 [!code-csharp[ADSetAppDomainPolicy#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADSetAppDomainPolicy/CS/adsetappdomainpolicy.cs#1)]
 [!code-vb[ADSetAppDomainPolicy#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADSetAppDomainPolicy/VB/adsetappdomainpolicy.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="domainPolicy" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Security.Policy.PolicyException">セキュリティ ポリシー レベルが既に設定されています。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作が試行されています。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="SetCachePath">
      <MemberSignature Language="C#" Value="public void SetCachePath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetCachePath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetCachePath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCachePath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetCachePath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="abstract member SetCachePath : string -&gt; unit&#xA;override this.SetCachePath : string -&gt; unit" Usage="appDomain.SetCachePath path" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.SetCachePath(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.SetCachePath")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Obsolete("AppDomain.SetCachePath has been deprecated. Please investigate the use of AppDomainSetup.CachePath instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">シャドウ コピー先の絶対パス。</param>
        <summary>指定したディレクトリ パスを、アセンブリのシャドウ コピー先として設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、キャッシュのパスは無視されます、<xref:System.AppDomainSetup.ApplicationName%2A>プロパティは設定されません。 <xref:System.AppDomainSetup.CachePath%2A?displayProperty=nameWithType> プロパティを参照してください。  
  
 シャドウ コピーの詳細については、次を参照してください。[アセンブリのシャドウ コピー](~/docs/framework/app-domains/shadow-copy-assemblies.md)します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作が試行されています。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</permission>
        <altmember cref="P:System.AppDomainSetup.CachePath" />
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">アセンブリのシャドウ コピー</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetData">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>アプリケーション ドメイン プロパティに値を代入します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public void SetData (string name, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetData(string name, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetData(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetData (name As String, data As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetData(System::String ^ name, System::Object ^ data);" />
      <MemberSignature Language="F#" Value="abstract member SetData : string * obj -&gt; unit&#xA;override this.SetData : string * obj -&gt; unit" Usage="appDomain.SetData (name, data)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.SetData(System.String,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">作成または変更の対象となるユーザー定義アプリケーション ドメイン プロパティの名前。</param>
        <param name="data">プロパティの値。</param>
        <summary>指定したアプリケーション ドメイン プロパティに、指定した値を割り当てます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、エントリを挿入するのこのインスタンスのプロパティを説明する名前とデータのペアの内部キャッシュ内のエントリの値を変更または<xref:System.AppDomain>します。  
  
 キャッシュには、アプリケーション ドメインの作成時に挿入される定義済みのシステム エントリに自動的に含まれています。 挿入または、このメソッドを使用してシステム エントリを変更することはできません。 システムのエントリを変更しようとするメソッドの呼び出しには効果がありません。メソッドは例外をスローしていません。 システム エントリの値を検査することができます、<xref:System.AppDomain.GetData%2A>メソッド、または同等<xref:System.AppDomainSetup>プロパティの説明<xref:System.AppDomain.GetData%2A>します。  
  
 値として"REGEX_DEFAULT_MATCH_TIMEOUT"を指定して正規表現パターンを評価するための既定のタイムアウト間隔の値を設定するには、このメソッドを呼び出すことができます、`name`引数と<xref:System.TimeSpan>タイムアウトを表す値です間隔の値として、`data`引数。 挿入またはこのメソッドを使用して、独自のユーザー定義名とデータの組み合わせを変更しでその値を検査、<xref:System.AppDomain.GetData%2A>メソッド。  
  
   
  
## Examples  
 次の例では、使用する方法、<xref:System.AppDomain.SetData%28System.String%2CSystem.Object%29>新しい値のペアを作成します。 使用して、<xref:System.AppDomain.GetData%2A>値を取得し、コンソールに表示します。  
  
 [!code-cpp[ADGetData#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADGetData/CPP/adgetdata.cpp#1)]
 [!code-csharp[ADGetData#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADGetData/CS/adgetdata.cs#1)]
 [!code-vb[ADGetData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADGetData/VB/adgetdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作が試行されています。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</permission>
        <altmember cref="M:System.AppDomain.GetData(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public void SetData (string name, object data, System.Security.IPermission permission);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetData(string name, object data, class System.Security.IPermission permission) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetData (name As String, data As Object, permission As IPermission)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetData(System::String ^ name, System::Object ^ data, System::Security::IPermission ^ permission);" />
      <MemberSignature Language="F#" Value="member this.SetData : string * obj * System.Security.IPermission -&gt; unit" Usage="appDomain.SetData (name, data, permission)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Object" />
        <Parameter Name="permission" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="name">作成または変更の対象となるユーザー定義アプリケーション ドメイン プロパティの名前。</param>
        <param name="data">プロパティの値。</param>
        <param name="permission">プロパティの取得時に呼び出し元に要求するアクセス許可。</param>
        <summary>アプリケーション ドメインの特定のプロパティに対し、指定された値を代入します。プロパティの取得時に呼び出し元に要求するアクセス許可を引数として受け取ります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 挿入または独自のアプリケーション ドメインのプロパティを説明する名前/データ ペアの内部キャッシュにユーザー定義のエントリを変更するには、このメソッドを使用します。 エントリを挿入する場合は、エントリが取得されるときに適用するアクセス許可の要求を指定できます。さらの値として"REGEX_DEFAULT_MATCH_TIMEOUT"を指定して正規表現パターンを評価するための既定のタイムアウト間隔の値を設定するには、このメソッドを呼び出すことができます、`name`引数と<xref:System.TimeSpan>を表す値、タイムアウト間隔の値として、`data`引数。  
  
 このメソッドを使用して、システム定義のプロパティ文字列をセキュリティの要求を割り当てることはできません。  
  
 キャッシュには、アプリケーション ドメインの作成時に挿入される定義済みのシステム エントリに自動的に含まれています。 挿入または、このメソッドを使用してシステム エントリを変更することはできません。 システムのエントリを変更しようとするメソッドの呼び出しには効果がありません。メソッドは例外をスローしていません。 システム エントリの値を検査することができます、<xref:System.AppDomain.GetData%2A>メソッドまたは同等<xref:System.AppDomainSetup>は「解説」で説明するプロパティ、<xref:System.AppDomain.GetData%2A>メソッド。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="name" /> にシステム定義のプロパティ文字列が指定されているにもかかわらず、<paramref name="permission" /> が <see langword="null" /> です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="SetDynamicBase">
      <MemberSignature Language="C#" Value="public void SetDynamicBase (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetDynamicBase(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetDynamicBase(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetDynamicBase (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetDynamicBase(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.SetDynamicBase : string -&gt; unit" Usage="appDomain.SetDynamicBase path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.DynamicBase")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Obsolete("AppDomain.SetDynamicBase has been deprecated. Please investigate the use of AppDomainSetup.DynamicBase instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">動的に生成されたファイルの格納先となるサブディレクトリに対するベース ディレクトリを指定する絶対パス。</param>
        <summary>動的に生成されたファイルの格納先、およびそのファイルへのアクセス先となるサブディレクトリに対するベース ディレクトリとして、ディレクトリ パスを設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、設定、<xref:System.AppDomainSetup.DynamicBase%2A>プロパティ、内部の<xref:System.AppDomainSetup>このインスタンスに関連付けられています。  
  
   
  
## Examples  
 このメソッドは、廃止されており新しい開発ないで使用する必要があります。 次の例が旧式でない別の方法を使用する方法を示します、<xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType>プロパティ。 この例の詳細については、次を参照してください。、<xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType>プロパティまたは<xref:System.AppDomain.DynamicDirectory%2A>プロパティ。  
  
 [!code-cpp[ADDynamicBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDynamicBase/CPP/addynamicbase.cpp#1)]
 [!code-csharp[ADDynamicBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDynamicBase/CS/addynamicbase.cs#1)]
 [!code-vb[ADDynamicBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDynamicBase/VB/addynamicbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作が試行されています。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</permission>
        <altmember cref="P:System.AppDomainSetup.DynamicBase" />
      </Docs>
    </Member>
    <Member MemberName="SetPrincipalPolicy">
      <MemberSignature Language="C#" Value="public void SetPrincipalPolicy (System.Security.Principal.PrincipalPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPrincipalPolicy(valuetype System.Security.Principal.PrincipalPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPrincipalPolicy (policy As PrincipalPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPrincipalPolicy(System::Security::Principal::PrincipalPolicy policy);" />
      <MemberSignature Language="F#" Value="member this.SetPrincipalPolicy : System.Security.Principal.PrincipalPolicy -&gt; unit" Usage="appDomain.SetPrincipalPolicy policy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="policy" Type="System.Security.Principal.PrincipalPolicy" />
      </Parameters>
      <Docs>
        <param name="policy">スレッドにアタッチするプリンシパル オブジェクトの型を指定する、<see cref="T:System.Security.Principal.PrincipalPolicy" /> のいずれかの値。</param>
        <summary>アプリケーション ドメインでスレッドを実行中に、スレッドがプリンシパルにバインドしようとした場合に、プリンシパル オブジェクトと ID オブジェクトをそのスレッドに関連付ける方法を指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この値を設定するが効果的なは、使用する前に設定した場合のみが、<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType>プロパティ。 例では、設定した場合の<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType>次を使用して指定されたプリンシパル (たとえば、汎用プリンシパル) を<xref:System.AppDomain.SetPrincipalPolicy%2A>を設定するメソッド、<xref:System.Security.Principal.PrincipalPolicy>に<xref:System.Security.Principal.PrincipalPolicy.WindowsPrincipal>、現在のプリンシパルは、汎用プリンシパルに残ります。  
  
   
  
## Examples  
 次の例を使用するスレッドへの影響を示しています、<xref:System.AppDomain.SetPrincipalPolicy%2A>アプリケーション ドメインのプリンシパルのポリシーを変更するメソッド。 使用する効果も示しています、<xref:System.AppDomain.SetThreadPrincipal%2A>のアプリケーション ドメインのスレッドにアタッチするために使用できるプリンシパルを変更するメソッド。  
  
 [!code-cpp[ADPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADPrincipal/CPP/adprincipal.cpp#1)]
 [!code-csharp[ADPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADPrincipal/CS/adprincipal.cs#1)]
 [!code-vb[ADPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADPrincipal/VB/adprincipal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作が試行されています。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">プリンシパル オブジェクトを操作する権限です。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /> (関連する列挙体) セキュリティ アクション:<see cref="F:System.Security.Permissions.SecurityAction.Demand" />します。</permission>
      </Docs>
    </Member>
    <Member MemberName="SetShadowCopyFiles">
      <MemberSignature Language="C#" Value="public void SetShadowCopyFiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetShadowCopyFiles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetShadowCopyFiles" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetShadowCopyFiles ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetShadowCopyFiles();" />
      <MemberSignature Language="F#" Value="member this.SetShadowCopyFiles : unit -&gt; unit" Usage="appDomain.SetShadowCopyFiles " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyFiles")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Obsolete("AppDomain.SetShadowCopyFiles has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyFiles instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>シャドウ コピーをオンにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 シャドウ コピーの詳細については、次を参照してください。[アセンブリのシャドウ コピー](~/docs/framework/app-domains/shadow-copy-assemblies.md)します。  
  
   
  
## Examples  
 このメソッドは、廃止されており新しい開発ないで使用する必要があります。  
  
 [!code-cpp[adproperties#1](~/samples/snippets/cpp/VS_Snippets_CLR/adproperties/CPP/adproperties.cpp#1)]
 [!code-csharp[adproperties#1](~/samples/snippets/csharp/VS_Snippets_CLR/adproperties/CS/adproperties.cs#1)]
 [!code-vb[adproperties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/adproperties/VB/adproperties.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作が試行されています。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</permission>
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">アセンブリのシャドウ コピー</related>
      </Docs>
    </Member>
    <Member MemberName="SetShadowCopyPath">
      <MemberSignature Language="C#" Value="public void SetShadowCopyPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetShadowCopyPath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetShadowCopyPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetShadowCopyPath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetShadowCopyPath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="abstract member SetShadowCopyPath : string -&gt; unit&#xA;override this.SetShadowCopyPath : string -&gt; unit" Usage="appDomain.SetShadowCopyPath path" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.SetShadowCopyPath(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyDirectories")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.Obsolete("AppDomain.SetShadowCopyPath has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyDirectories instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">ディレクトリ名のリスト。各ディレクトリ名はセミコロンで区切られます。</param>
        <summary>指定したディレクトリ パスを、シャドウ コピーするアセンブリがある場所として設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既定では、シャドウ コピーには、調査で見つかったすべてのアセンブリが含まれています。 <xref:System.AppDomain.SetShadowCopyPath%2A>メソッドによって指定されたディレクトリでアセンブリをシャドウ コピーを制限する`path`します。  
  
 <xref:System.AppDomain.SetShadowCopyPath%2A>メソッドでアセンブリを検索する追加のディレクトリが指定されていません。 アセンブリのシャドウ コピーする必要があります既に検索パスの例の下に<xref:System.AppDomain.BaseDirectory%2A>します。 <xref:System.AppDomain.SetShadowCopyPath%2A>メソッドでは、どの検索パスがシャドウ-コピーする対象を指定します。  
  
 このメソッドは、設定、<xref:System.AppDomainSetup.ShadowCopyDirectories%2A>プロパティ、内部の<xref:System.AppDomainSetup>このインスタンスに関連付けられています。  
  
 シャドウ コピーの詳細については、次を参照してください。[アセンブリのシャドウ コピー](~/docs/framework/app-domains/shadow-copy-assemblies.md)します。  
  
   
  
## Examples  
 このメソッドは、廃止されており新しい開発ないで使用する必要があります。  
  
 [!code-cpp[ADShadowCopy#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADShadowCopy/CPP/adshadowcopy.cpp#1)]
 [!code-csharp[ADShadowCopy#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADShadowCopy/CS/adshadowcopy.cs#1)]
 [!code-vb[ADShadowCopy#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADShadowCopy/VB/adshadowcopy.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作が試行されています。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</permission>
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">アセンブリのシャドウ コピー</related>
      </Docs>
    </Member>
    <Member MemberName="SetThreadPrincipal">
      <MemberSignature Language="C#" Value="public void SetThreadPrincipal (System.Security.Principal.IPrincipal principal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetThreadPrincipal(class System.Security.Principal.IPrincipal principal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetThreadPrincipal (principal As IPrincipal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetThreadPrincipal(System::Security::Principal::IPrincipal ^ principal);" />
      <MemberSignature Language="F#" Value="member this.SetThreadPrincipal : System.Security.Principal.IPrincipal -&gt; unit" Usage="appDomain.SetThreadPrincipal principal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Principal.IPrincipal" />
      </Parameters>
      <Docs>
        <param name="principal">スレッドに関連付けるプリンシパル オブジェクト。</param>
        <summary>アプリケーション ドメインでスレッドを実行中に、スレッドがプリンシパルにバインドしようとした場合に、そのスレッドに関連付ける既定のプリンシパル オブジェクトを設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例を使用する効果を示しています、<xref:System.AppDomain.SetThreadPrincipal%2A>アプリケーション ドメインで実行されているスレッドにアタッチするために使用できるプリンシパルを変更するメソッド。 使用するスレッドへの影響も示しています、<xref:System.AppDomain.SetPrincipalPolicy%2A>アプリケーション ドメインのプリンシパルのポリシーを変更するメソッド。  
  
 [!code-cpp[ADPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADPrincipal/CPP/adprincipal.cpp#1)]
 [!code-csharp[ADPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADPrincipal/CS/adprincipal.cs#1)]
 [!code-vb[ADPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADPrincipal/VB/adprincipal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="principal" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Security.Policy.PolicyException">スレッドのプリンシパルが既に設定されています。</exception>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作が試行されています。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">プリンシパル オブジェクトを操作する権限です。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /> (関連する列挙体) セキュリティ アクション:<see cref="F:System.Security.Permissions.SecurityAction.Demand" />します。</permission>
      </Docs>
    </Member>
    <Member MemberName="SetupInformation">
      <MemberSignature Language="C#" Value="public AppDomainSetup SetupInformation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AppDomainSetup SetupInformation" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.SetupInformation" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SetupInformation As AppDomainSetup" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AppDomainSetup ^ SetupInformation { AppDomainSetup ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SetupInformation : AppDomainSetup" Usage="System.AppDomain.SetupInformation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomainSetup</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このインスタンスのアプリケーション ドメイン構成情報を取得します。</summary>
        <value>アプリケーション ドメインの初期化情報。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作が試行されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="ShadowCopyFiles">
      <MemberSignature Language="C#" Value="public bool ShadowCopyFiles { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShadowCopyFiles" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ShadowCopyFiles" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ShadowCopyFiles As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShadowCopyFiles { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ShadowCopyFiles : bool" Usage="System.AppDomain.ShadowCopyFiles" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.ShadowCopyFiles</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーション ドメインでファイルのシャドウ コピーを実行するよう設定されているかどうかを示す値を取得します。</summary>
        <value>アプリケーション ドメインでファイルのシャドウ コピーを実行するよう設定されている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 詳細については、次を参照してください。<xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=nameWithType>と[アセンブリのシャドウ コピー](~/docs/framework/app-domains/shadow-copy-assemblies.md)します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">アンロードされたアプリケーション ドメインで操作が試行されています。</exception>
        <altmember cref="P:System.AppDomainSetup.ShadowCopyFiles" />
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">アセンブリのシャドウ コピー</related>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _AppDomain.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _AppDomain.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = _AppDomain::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">将来利用するために予約されています。 IID_NULL にする必要があります。</param>
        <param name="rgszNames">マッピング対象として渡される名前の配列。</param>
        <param name="cNames">マッピングされる名前のカウント。</param>
        <param name="lcid">名前を解釈するロケール コンテキスト。</param>
        <param name="rgDispId">名前に対応する ID を受け取る、呼び出し元が割り当てた配列。</param>
        <summary>一連の名前を対応する一連のディスパッチ識別子に割り当てます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびマネージ コードから呼び出さないでいます。 詳細については`IDispatch::GetIDsOfNames`、MSDN ライブラリを参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> インターフェイスを使用した遅延バインディング アクセスはサポートされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _AppDomain.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _AppDomain.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = _AppDomain::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">返される型情報。</param>
        <param name="lcid">型情報のロケール ID。</param>
        <param name="ppTInfo">要求された型情報オブジェクトへのポインターを取得します。</param>
        <summary>オブジェクトの型情報を取得します。この型情報を使用して、インターフェイスの型情報を取得できます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびマネージ コードから呼び出さないでいます。 詳細については`IDispatch::GetTypeInfo`、MSDN ライブラリを参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> インターフェイスを使用した遅延バインディング アクセスはサポートされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _AppDomain.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _AppDomain.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = _AppDomain::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">オブジェクトによって提供される型情報インターフェイスの数を受け取る場所へのポインター。</param>
        <summary>オブジェクトが提供する型情報インターフェイスの数 (0 または 1) を取得します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびマネージ コードから呼び出さないでいます。 詳細については`IDispatch::GetTypeInfoCount`、MSDN ライブラリを参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> インターフェイスを使用した遅延バインディング アクセスはサポートされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.Invoke">
      <MemberSignature Language="C#" Value="void _AppDomain.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _AppDomain.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = _AppDomain::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">メンバーを識別します。</param>
        <param name="riid">将来利用するために予約されています。 IID_NULL にする必要があります。</param>
        <param name="lcid">引数を解釈する対象のロケール コンテキスト。</param>
        <param name="wFlags">呼び出しのコンテキストを記述するフラグ。</param>
        <param name="pDispParams">引数の配列、名前付き引数の DISPID の配列、配列内の要素数のカウントを格納している構造体へのポインター。</param>
        <param name="pVarResult">結果が格納される場所へのポインター。</param>
        <param name="pExcepInfo">例外情報を格納する構造体へのポインター。</param>
        <param name="puArgErr">エラーが存在する最初の引数のインデックス。</param>
        <summary>オブジェクトによって公開されたプロパティおよびメソッドへのアクセスを提供します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびマネージ コードから呼び出さないでいます。 詳細については`IDispatch::Invoke`、MSDN ライブラリを参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> インターフェイスを使用した遅延バインディング アクセスはサポートされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="appDomain.ToString " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>アプリケーション ドメインの表示名とコンテキスト ポリシーを含む文字列形式を取得します。</summary>
        <returns>アプリケーション ドメインの表示名であるリテラル文字列 "Name:" と、コンテキスト ポリシーの文字列形式または "There are no context policies." という文字列のどちらかを連結した文字列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例の戻り値の表示、<xref:System.AppDomain.ToString%2A>メソッド。  
  
 [!code-cpp[ADToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADToString/CPP/adtostring.cpp#1)]
 [!code-csharp[ADToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADToString/CS/adtostring.cs#1)]
 [!code-vb[ADToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADToString/VB/adtostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">現在の <see cref="T:System.AppDomain" /> によって表されるアプリケーション ドメインは既にアンロードされています。</exception>
      </Docs>
    </Member>
    <Member MemberName="TypeResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler TypeResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler TypeResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.TypeResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TypeResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event ResolveEventHandler ^ TypeResolve;" />
      <MemberSignature Language="F#" Value="member this.TypeResolve : ResolveEventHandler " Usage="member this.TypeResolve : System.ResolveEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.TypeResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>型の解決が失敗したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomain.TypeResolve>イベントは、共通言語ランタイムが要求された型を作成できるアセンブリを特定できない場合に発生します。 これは、動的アセンブリで型が定義されているまたは型が動的アセンブリで定義されていないが、ランタイムには、型がで定義されているアセンブリがわからない場合に発生することができます。 後者の状況が発生することがとき<xref:System.Type.GetType%2A?displayProperty=nameWithType>アセンブリ名で修飾されていない型名と呼びます。  
  
 <xref:System.ResolveEventHandler>のこのイベントは、検索し、型の作成を試むことができます。  
  
 ただし、<xref:System.AppDomain.TypeResolve>ランタイムは、特定のアセンブリの種類を検索することはできませんを把握している場合、イベントは発生しません。 たとえば、静的アセンブリでは、ランタイムの型は、静的アセンブリに動的に追加することはできませんが知っているため、型が存在しない場合、このイベントは発生しません。  
  
 以降では、 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]、<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>プロパティには、型を要求したアセンブリが含まれています。 詳細については、「<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>」を参照してください。  
  
 このイベントのイベント ハンドラーを登録するには、必要なアクセス許可が必要または<xref:System.Security.SecurityException>がスローされます。  
  
 イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。  
  
   
  
## Examples  
 次のサンプルでは、<xref:System.AppDomain.TypeResolve>イベント。  
  
 このコード例を実行するには、完全修飾アセンブリ名を指定する必要があります。 完全修飾アセンブリ名を取得する方法については、次を参照してください。[アセンブリ名](~/docs/framework/app-domains/assembly-names.md)します。  
  
 [!code-cpp[AppDomain_TypeResolve#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_TypeResolve/CPP/typeresolve.cpp#1)]
 [!code-csharp[AppDomain_TypeResolve#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_TypeResolve/CS/typeresolve.cs#1)]
 [!code-vb[AppDomain_TypeResolve#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_TypeResolve/VB/typeresolve.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="UnhandledException">
      <MemberSignature Language="C#" Value="public event UnhandledExceptionEventHandler UnhandledException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.UnhandledExceptionEventHandler UnhandledException" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.UnhandledException" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event UnhandledException As UnhandledExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event UnhandledExceptionEventHandler ^ UnhandledException;" />
      <MemberSignature Language="F#" Value="member this.UnhandledException : UnhandledExceptionEventHandler " Usage="member this.UnhandledException : System.UnhandledExceptionEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.UnhandledException</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UnhandledExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>例外がキャッチされない場合に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、キャッチされない例外の通知を提供します。 システムの既定のハンドラーがユーザーに例外を報告、およびアプリケーションの終了前に、例外に関する情報を記録するアプリケーションをできるようにします。 その他の操作を行うことがあります、アプリケーションの状態に関する十分な情報を使用できる場合、その後の復旧のプログラムのデータを保存するなど。 例外が処理されない場合は、プログラムのデータが破壊されることがあるため、警告が表示されます。  
  
> [!NOTE]
>  .NET Framework バージョン 1.0 および 1.1 では、アプリケーションの終了とデバッグ オプションが報告ユーザーではなくより後の前に、このイベントが発生します。  
  
 このイベントは、任意のアプリケーション ドメインで処理することができます。 ただし、イベントは必ずしも発生しませんが、例外が発生したアプリケーション ドメインで。 スレッドのスタック全体が解除されたアンワインドため、まずイベントを発生させることができますが、スレッドが作成されたアプリケーション ドメインでは、該当する例外ハンドラーを検索せず場合にのみ、例外が処理されません。  
  
> [!NOTE]
>  .NET Framework バージョン 1.0 および 1.1 では、このイベントは、アプリケーションを開始するときに、システムによって作成される既定のアプリケーション ドメインに対してのみ発生します。 アプリケーションでは、追加のアプリケーション ドメインを作成する場合は、これらのアプリケーション ドメインでこのイベントのデリゲートを指定しても効果はありません。  
  
 場合、<xref:System.AppDomain.UnhandledException>イベントは既定のアプリケーション ドメインで処理のいずれかのハンドルされない例外では、どのようなアプリケーション ドメインに関係なく、任意のスレッド開始されたスレッドにある発生しました。 イベント ハンドラーにあるアプリケーション ドメインでスレッドが開始したかどうかは<xref:System.AppDomain.UnhandledException>、そのアプリケーション ドメインで、イベントが発生します。 そのアプリケーション ドメインが既定のアプリケーション ドメインと既定のアプリケーション ドメインで、イベント ハンドラーはまた、両方のアプリケーション ドメインで、イベントが発生します。  
  
 たとえば、スレッドの起動時あるとします"AD1"のアプリケーション ドメイン"AD2"のアプリケーション ドメインでメソッドを呼び出しし、そこからメソッドを呼び出し、"AD3"のアプリケーション ドメインで例外がスローされます。 最初のアプリケーション ドメインを<xref:System.AppDomain.UnhandledException>イベントを発生させることができます"AD1"です。 そのアプリケーション ドメインが既定のアプリケーション ドメインでない場合は、イベントは既定のアプリケーション ドメインにも発生します。  
  
> [!NOTE]
>  共通言語ランタイムの中断イベント ハンドラーの中にスレッドの中止、<xref:System.AppDomain.UnhandledException>イベントを実行します。  
  
 イベント ハンドラーがある場合、<xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute>属性、適切なフラグでは、イベント ハンドラーは制約された実行領域として扱われます。  
  
 以降では、 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]、このイベントはスタック オーバーフローなど、プロセスの状態が破損またはイベント ハンドラーがセキュリティ クリティカルであり、違反にアクセスする例外の発生しませんが、<xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute>属性。  
  
 .NET Framework バージョン 1.0 および 1.1 では、メイン アプリケーション スレッド以外のスレッドで発生した未処理の例外はランタイムによってが検出され、アプリケーションが終了するを発生しません。 したがって、ことができる、<xref:System.AppDomain.UnhandledException>イベントが、アプリケーションを終了せずに発生します。 以降、.NET Framework version 2.0 では、この安全策子スレッドのハンドルされない例外のため、削除されましたサイレントこのような障害の影響が累積には、パフォーマンスの低下には、破損したデータにはすべての困難がハングアップが含まれていますデバッグします。 これで、ランタイムが終了しないケースの一覧を含む詳細については、次を参照してください。[マネージ スレッドにおける例外](~/docs/standard/threading/exceptions-in-managed-threads.md)します。  
  
 このイベントのイベント ハンドラーを登録するには、必要なアクセス許可が必要または<xref:System.Security.SecurityException>がスローされます。  
  
 イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。  
  
## <a name="other-events-for-unhandled-exceptions"></a>未処理の例外の他のイベント  
 特定のアプリケーション モデル、<xref:System.AppDomain.UnhandledException>イベントはメイン アプリケーション スレッドでハンドルされない例外が発生した場合、その他のイベントによって割り込まれることができます。  
  
 Windows フォームを使用するアプリケーションで未処理の例外、メイン アプリケーション スレッドが発生、<xref:System.Windows.Forms.Application.ThreadException?displayProperty=nameWithType>イベントが発生します。 このイベントが処理される場合、既定の動作は、未処理の例外が、アプリケーションを終了していないこと、アプリケーションが不明な状態のままですが。 その場合は、<xref:System.AppDomain.UnhandledException>イベントは発生しません。 アプリケーション構成ファイルを使用して、またはを使用して、この動作を変更できます、<xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A?displayProperty=nameWithType>するモードを変更するメソッドを<xref:System.Windows.Forms.UnhandledExceptionMode.ThrowException?displayProperty=nameWithType>する前に、<xref:System.Windows.Forms.Application.ThreadException>イベント ハンドラーをフックします。 これは、メイン アプリケーション スレッドにのみ適用されます。 <xref:System.AppDomain.UnhandledException>の他のスレッドでスローされた未処理の例外イベントが発生します。  
  
 Microsoft Visual Studio 2005 以降では、Visual Basic のアプリケーション フレームワークは、メイン アプリケーション スレッドでハンドルされない例外の別のイベントを提供します。 参照してください、<xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UnhandledException?displayProperty=nameWithType>イベント。 このイベントがイベント引数オブジェクトによって使用されるイベント引数オブジェクトと同じ名前で<xref:System.AppDomain.UnhandledException?displayProperty=nameWithType>がさまざまなプロパティを使用します。 特に、このイベント引数オブジェクトは、<xref:Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventArgs.ExitApplication%2A>プロパティにより、実行、未処理の例外は無視されます (および、アプリケーションが不明な状態のままになります) を継続するアプリケーションです。 その場合は、<xref:System.AppDomain.UnhandledException?displayProperty=nameWithType>イベントは発生しません。  
  
   
  
## Examples  
 次の例で示します、<xref:System.AppDomain.UnhandledException>イベント。 イベント ハンドラーを定義します`MyHandler`既定のアプリケーション ドメインでハンドルされない例外がスローされたときに呼び出されます。 2 つの例外をスローします。 最初はによって処理される、 **try ~ catch**ブロックします。 2 つ目が処理されないと起動、`MyHandle`ルーチン、アプリケーションが終了する前にします。  
  
 [!code-cpp[AppDomain_UnhandledException#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_UnhandledException/CPP/unhandledexception.cpp#1)]
 [!code-csharp[AppDomain_UnhandledException#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_UnhandledException/CS/unhandledexception.cs#1)]
 [!code-vb[AppDomain_UnhandledException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_UnhandledException/VB/unhandledexception.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="Unload">
      <MemberSignature Language="C#" Value="public static void Unload (AppDomain domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Unload(class System.AppDomain domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Unload(System.AppDomain)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Unload (domain As AppDomain)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unload(AppDomain ^ domain);" />
      <MemberSignature Language="F#" Value="static member Unload : AppDomain -&gt; unit" Usage="System.AppDomain.Unload domain" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptAppDomain, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
      </Parameters>
      <Docs>
        <param name="domain">アンロードするアプリケーション ドメイン。</param>
        <summary>指定したアプリケーション ドメインをアンロードします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework version 2.0 では、スレッドがアプリケーション ドメインのアンロードに専用です。 これにより、.NET Framework がホストされている場合は特に、信頼性が向上します。 スレッドを呼び出すと<xref:System.AppDomain.Unload%2A>、ターゲット ドメインがアンロードするためにマークされています。 専用のスレッドが、ドメインをアンロードしようとした場合、ドメイン内のすべてのスレッドは中止されます。 スレッドは中止されない、たとえば、アンマネージ コードを実行している場合、または実行されているため、`finally`を一定期間後のブロックを<xref:System.CannotUnloadAppDomainException>と呼ばれる最初のスレッドでスローされる<xref:System.AppDomain.Unload%2A>します。 最終的に中止できませんでしたが、スレッドが終了した場合、ターゲット ドメインはアンロードされません。 したがって、.NET Framework version 2.0 で`domain`実行中のスレッドを終了できない可能性がありますので、アンロードは保証されません。  
  
> [!NOTE]
>  いくつかの場合は、呼び出し<xref:System.AppDomain.Unload%2A>、すぐ<xref:System.CannotUnloadAppDomainException>、たとえば、ファイナライザーで呼び出された場合。  
  
 内のスレッド`domain`が終了を使用して、<xref:System.Threading.Thread.Abort%2A>メソッドがスローされます、<xref:System.Threading.ThreadAbortException>スレッドでします。 時間量が予測できないため実行が続行できますが、スレッドがすぐに終了する必要があります、`finally`句。  
  
## <a name="version-compatibility"></a>バージョンの互換性  
 .NET framework version 1.0 および 1.1 の場合は、スレッドを呼び出す<xref:System.AppDomain.Unload%2A>で実行されている`domain`、アンロード操作を実行する別のスレッドが開始します。 場合`domain`、アンロードすることはできません、<xref:System.CannotUnloadAppDomainException>と呼ばれる元のスレッドではなく、そのスレッドでスローされる<xref:System.AppDomain.Unload%2A>します。 ただしかどうか、スレッドを呼び出す<xref:System.AppDomain.Unload%2A>外部で実行中`domain`スレッドが例外を受け取ります。  
  
   
  
## Examples  
 次のコード例では、アプリケーション ドメインをアンロードする方法を示します。  
  
 [!code-cpp[ADUnload#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADUnload/CPP/adunload.cpp#1)]
 [!code-csharp[ADUnload#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADUnload/CS/adunload.cs#1)]
 [!code-vb[ADUnload#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADUnload/VB/adunload.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="domain" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.CannotUnloadAppDomainException">
          <paramref name="domain" /> をアンロードできませんでした。</exception>
        <exception cref="T:System.Exception">アンロード処理中にエラーが発生しました。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">このイベントのイベント ハンドラーを追加します。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain" /> (関連する列挙体) セキュリティ アクション:<see cref="F:System.Security.Permissions.SecurityAction.Demand" />します。</permission>
      </Docs>
    </Member>
  </Members>
</Type>