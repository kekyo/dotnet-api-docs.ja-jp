<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Object.xml" source-language="en-US" target-language="ja-JP">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-efd8310" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">5e05b5b2-d481-4262-b7b7-7de7ac2afe07da621eb36bda643f3e0a1e5b1a3ef53120877ab9.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">da621eb36bda643f3e0a1e5b1a3ef53120877ab9</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">df6cf590aa3087f6c7c202712eee781c6a3c8f96</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">05/07/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7.2,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Object">
          <source>Supports all classes in the .NET Framework class hierarchy and provides low-level services to derived classes.</source>
          <target state="translated">.NET Framework クラス階層のすべてのクラスをサポートし、派生クラスに下位レベルのサービスを提供します。</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" uid="T:System.Object">
          <source>This is the ultimate base class of all classes in the .NET Framework; it is the root of the type hierarchy.</source>
          <target state="translated">これは、.NET Framework の全クラスの基本クラスであり、型階層のルートです。</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>Languages typically do not require a class to declare inheritance from <ph id="ph1">&lt;xref:System.Object&gt;</ph> because the inheritance is implicit.</source>
          <target state="translated">通常の言語は、クラスからの継承を宣言する必要ありません<ph id="ph1">&lt;xref:System.Object&gt;</ph>の継承は暗黙的なためです。</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>Because all classes in the .NET Framework are derived from <ph id="ph1">&lt;xref:System.Object&gt;</ph>, every method defined in the <ph id="ph2">&lt;xref:System.Object&gt;</ph> class is available in all objects in the system.</source>
          <target state="translated">.NET Framework のすべてのクラスがから派生するため<ph id="ph1">&lt;xref:System.Object&gt;</ph>で定義されているすべてのメソッド、<ph id="ph2">&lt;xref:System.Object&gt;</ph>クラスは、システム内のすべてのオブジェクトで使用できます。</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>Derived classes can and do override some of these methods, including:</source>
          <target state="translated">クラスを派生し、これらのメソッドの一部をオーバーライドしないでください。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source><ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> - Supports comparisons between objects.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> -オブジェクト間の比較をサポートしています。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> - Performs cleanup operations before an object is automatically reclaimed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> -オブジェクトが自動的にクリアされる前に、クリーンアップ操作を実行します。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source><ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> - Generates a number corresponding to the value of the object to support the use of a hash table.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> ハッシュ テーブルの使用をサポートするために、オブジェクトの値に対応する番号を生成します。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source><ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph> - Manufactures a human-readable text string that describes an instance of the class.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph> クラスのインスタンスを記述する人が判読できるテキスト文字列を製造しています。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>Performance Considerations</source>
          <target state="translated">パフォーマンスに関する考慮事項</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>If you are designing a class, such as a collection, that must handle any type of object, you can create class members that accept instances of the <ph id="ph1">&lt;xref:System.Object&gt;</ph> class.</source>
          <target state="translated">どの型のオブジェクトを処理する必要が、コレクションなど、クラスをデザインする場合は、インスタンスを受け入れるクラス メンバーを作成することができます、<ph id="ph1">&lt;xref:System.Object&gt;</ph>クラスです。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>However, the process of boxing and unboxing a type carries a performance cost.</source>
          <target state="translated">ただし、ボックス化と型をボックス化解除のプロセスでは、パフォーマンス コストが伴います。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>If you know your new class will frequently handle certain value types you can use one of two tactics to minimize the cost of boxing.</source>
          <target state="translated">新しいクラスの特定の値型を頻繁に処理することがわかっている場合は、ボックス化のコストを最小限に 2 つの方針のいずれかを使用できます。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>Create a general method that accepts an <ph id="ph1">&lt;xref:System.Object&gt;</ph> type, and a set of type-specific method overloads that accept each value type you expect your class to frequently handle.</source>
          <target state="translated">受け取るための一般的なメソッドを作成、<ph id="ph1">&lt;xref:System.Object&gt;</ph>型、および頻繁に処理するクラスを期待する各値の型を許容する型固有のメソッド オーバー ロードのセット。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>If a type-specific method exists that accepts the calling parameter type, no boxing occurs and the type-specific method is invoked.</source>
          <target state="translated">型固有のメソッドを呼び出し元のパラメーター型を受け付けるが存在する場合は、ボックス化が行われず、型固有のメソッドが呼び出されます。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>If there is no method argument that matches the calling parameter type, the parameter is boxed and the general method is invoked.</source>
          <target state="translated">呼び出し元のパラメーター型と一致するメソッドの引数がない場合は、パラメーターがボックス化され、一般的なメソッドが呼び出されます。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>Design your type and its members to use generics.</source>
          <target state="translated">ジェネリックを使用するには、種類とそのメンバーをデザインします。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>The common language runtime creates a closed generic type when you create an instance of your class and specify a generic type argument.</source>
          <target state="translated">共通言語ランタイムは、クラスのインスタンスを作成し、ジェネリック型引数を指定するときに、クローズ ジェネリック型を作成します。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>The generic method is type-specific and can be invoked without boxing the calling parameter.</source>
          <target state="translated">ジェネリック メソッドは型固有であり、呼び出し元のパラメーターをボックス化しなくても呼び出すことができます。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>Although it is sometimes necessary to develop general purpose classes that accept and return <ph id="ph1">&lt;xref:System.Object&gt;</ph> types, you can improve performance by also providing a type-specific class to handle a frequently used type.</source>
          <target state="translated">受け取るまたは返す汎用クラスを開発するために必要な場合がありますが<ph id="ph1">&lt;xref:System.Object&gt;</ph>型も頻繁に使用される型を処理する型固有のクラスを提供することによってパフォーマンスが向上することができます。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>For example, providing a class that is specific to setting and getting Boolean values eliminates the cost of boxing and unboxing Boolean values.</source>
          <target state="translated">たとえばは、特定の設定とブール値を取得するクラスを提供するには、ボックス化とボックス化解除のブール値のコストが削減されます。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>The following example defines a Point type derived from the <ph id="ph1">&lt;xref:System.Object&gt;</ph> class and overrides many of the virtual methods of the <ph id="ph2">&lt;xref:System.Object&gt;</ph> class.</source>
          <target state="translated">次の例から派生したポイントの種類の定義、<ph id="ph1">&lt;xref:System.Object&gt;</ph>クラスし、多くの仮想メソッドのオーバーライド、<ph id="ph2">&lt;xref:System.Object&gt;</ph>クラスです。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>In addition, the example shows how to call many of the static and instance methods of the <ph id="ph1">&lt;xref:System.Object&gt;</ph> class.</source>
          <target state="translated">さらに、例は、静的の多くを呼び出す方法を示しています。 のメソッドとインスタンス、<ph id="ph1">&lt;xref:System.Object&gt;</ph>クラスです。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>Public static (<ph id="ph1">&lt;see langword="Shared" /&gt;</ph> in Visual Basic) members of this type are thread safe.</source>
          <target state="translated">パブリック静的 (<ph id="ph1">&lt;see langword="Shared" /&gt;</ph> Visual Basic で) この型のメンバーは、スレッド セーフであります。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Object">
          <source>Instance members are not guaranteed to be thread-safe.</source>
          <target state="translated">インスタンス メンバーは、スレッド セーフであることを保証はありません。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" uid="M:System.Object.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> クラスの新しいインスタンスを初期化します。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.#ctor">
          <source>This constructor is called by constructors in derived classes, but it can also be used to directly create an instance of the <ph id="ph1">&lt;xref:System.Object&gt;</ph> class.</source>
          <target state="translated">このコンス トラクターは派生クラスでコンス トラクターによって呼び出されますが、直接のインスタンスの作成にも使用できます、<ph id="ph1">&lt;xref:System.Object&gt;</ph>クラスです。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" uid="T:System.Object">
          <source>Determines whether two object instances are equal.</source>
          <target state="translated">2 つのオブジェクト インスタンスが等しいかどうかを判断します。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="M:System.Object.Equals(System.Object)">
          <source>The object to compare with the current object.</source>
          <target state="translated">現在のオブジェクトと比較するオブジェクト。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="M:System.Object.Equals(System.Object)">
          <source>Determines whether the specified object is equal to the current object.</source>
          <target state="translated">指定したオブジェクトが、現在のオブジェクトと等しいかどうかを判断します。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" uid="M:System.Object.Equals(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the specified object  is equal to the current object; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">指定したオブジェクトが現在のオブジェクトと等しい場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。それ以外の場合は <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The type of comparison between the current instance and the <ph id="ph1">`obj`</ph> parameter depends on whether the current instance is a reference type or a value type.</source>
          <target state="translated">現在のインスタンス間の比較の種類と<ph id="ph1">`obj`</ph>パラメーターは、現在のインスタンスは、参照型または値型かどうかによって異なります。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>If the current instance is a reference type, the <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> method tests for reference equality, and a call to the <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> method is equivalent to a call to the <ph id="ph3">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method.</source>
          <target state="translated">現在のインスタンスが、参照型である場合、<ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>参照の等価性のテストのメソッドを呼び出すと、<ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>メソッドへの呼び出しには、<ph id="ph3">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Reference equality means that the object variables that are compared refer to the same object.</source>
          <target state="translated">参照の等価性は、比較されたオブジェクト変数が同じオブジェクトを参照していることを意味します。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The following example illustrates the result of such a comparison.</source>
          <target state="translated">次の例は、このような比較の結果を示しています。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>It defines a <ph id="ph1">`Person`</ph> class, which is a reference type, and calls the <ph id="ph2">`Person`</ph> class constructor to instantiate two new <ph id="ph3">`Person`</ph> objects, <ph id="ph4">`person1a`</ph> and <ph id="ph5">`person2`</ph>, which have the same value.</source>
          <target state="translated">定義する、<ph id="ph1">`Person`</ph>クラスは、参照型である、および呼び出し、<ph id="ph2">`Person`</ph>新しい 2 つのインスタンス化するクラスのコンス トラクター<ph id="ph3">`Person`</ph>オブジェクト、<ph id="ph4">`person1a`</ph>と<ph id="ph5">`person2`</ph>値が同じであります。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>It also assigns <ph id="ph1">`person1a`</ph> to another object variable, <ph id="ph2">`person1b`</ph>.</source>
          <target state="translated">割り当てます<ph id="ph1">`person1a`</ph>を別のオブジェクト変数<ph id="ph2">`person1b`</ph>です。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>As the output from the example shows, <ph id="ph1">`person1a`</ph> and <ph id="ph2">`person1b`</ph> are equal because they reference the same object.</source>
          <target state="translated">例から出力として<ph id="ph1">`person1a`</ph>と<ph id="ph2">`person1b`</ph>が同じオブジェクトを参照するために等しい。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>However, <ph id="ph1">`person1a`</ph> and <ph id="ph2">`person2`</ph> are not equal, although they have the same value.</source>
          <target state="translated">ただし、<ph id="ph1">`person1a`</ph>と<ph id="ph2">`person2`</ph>が、同じ値が等しくないです。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>If the current instance is a value type, the <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> method tests for value equality.</source>
          <target state="translated">現在のインスタンスが、値型である場合、<ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>値の等価性のテストのメソッドです。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Value equality means the following:</source>
          <target state="translated">値の等価性には、次のことを意味します。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The two objects are of the same type.</source>
          <target state="translated">2 つのオブジェクトでは、同じ型です。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>As the following example shows, a <ph id="ph1">&lt;xref:System.Byte&gt;</ph> object that has a value of 12 does not equal an <ph id="ph2">&lt;xref:System.Int32&gt;</ph> object that has a value of 12, because the two objects have different run-time types.</source>
          <target state="translated">次の例に示すように、 <ph id="ph1">&lt;xref:System.Byte&gt;</ph> 12 の値を持つオブジェクトが等しくない、<ph id="ph2">&lt;xref:System.Int32&gt;</ph>を 2 つのオブジェクトがある実行時の型が異なるため、12 の値を持つオブジェクト。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The values of the public and private fields of the two objects are equal.</source>
          <target state="translated">2 つのオブジェクトのパブリックおよびプライベート フィールドの値が等しいです。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The following example tests for value equality.</source>
          <target state="translated">次の例は、値の等価性をテストします。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>It defines a <ph id="ph1">`Person`</ph> structure, which is a value type, and calls the <ph id="ph2">`Person`</ph> class constructor to instantiate two new <ph id="ph3">`Person`</ph> objects, <ph id="ph4">`person1`</ph> and <ph id="ph5">`person2`</ph>, which have the same value.</source>
          <target state="translated">定義する、 <ph id="ph1">`Person`</ph> 、構造体は値型と呼び出し、<ph id="ph2">`Person`</ph>新しい 2 つのインスタンス化するクラスのコンス トラクター<ph id="ph3">`Person`</ph>オブジェクト、<ph id="ph4">`person1`</ph>と<ph id="ph5">`person2`</ph>、同じ値であります。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>As the output from the example shows, although the two object variables refer to different objects, <ph id="ph1">`person1`</ph> and <ph id="ph2">`person2`</ph> are equal because they have the same value for the private <ph id="ph3">`personName`</ph> field.</source>
          <target state="translated">例の出力では、2 つのオブジェクト変数、複数のオブジェクトを参照していますが<ph id="ph1">`person1`</ph>と<ph id="ph2">`person2`</ph>がプライベートの同じ値があるために等しい<ph id="ph3">`personName`</ph>フィールドです。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Because the <ph id="ph1">&lt;xref:System.Object&gt;</ph> class is the base class for all types in the .NET Framework, the <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> method provides the default equality comparison for all other types.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object&gt;</ph>クラスは、.NET Framework のすべての型の基本クラス、<ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph>メソッドは、他のすべての種類の既定の等値比較を提供します。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>However, types often override the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> method to implement value equality.</source>
          <target state="translated">ただし、型多くの場合、上書き、<ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph>値の等価性を実装するメソッド。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>For more information, see the Notes for Callers and Notes for Inheritors sections.</source>
          <target state="translated">詳細については、の継承元のセクションでは呼び出し元関数とノートのノートを参照します。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Notes for the <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph></source>
          <target state="translated">は、 <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph></target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>When you call the <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> method overload on a class in the <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>, it provides the default behavior for classes that don’t override <ph id="ph3">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>.</source>
          <target state="translated">呼び出すと、<ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>のクラスのメソッドのオーバー ロード、 <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>、しないをオーバーライドするクラスの既定の動作を提供<ph id="ph3">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>This is part of the support that the .NET Framework provides for the <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> (see <bpt id="p1">[</bpt>.NET Framework Support for Windows Store Apps and Windows Runtime<ept id="p1">](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)</ept>).</source>
          <target state="translated">これは、.NET Framework 提供するサポートの一部、 <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> (を参照してください<bpt id="p1">[</bpt>フレームワークをサポートして Windows ストア アプリ用 .NET と Windows ランタイム<ept id="p1">](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)</ept>)。</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Classes in the <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> don’t inherit <ph id="ph2">&lt;xref:System.Object&gt;</ph>, and currently don’t implement an <ph id="ph3">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> method.</source>
          <target state="translated">内のクラス、<ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>継承しない<ph id="ph2">&lt;xref:System.Object&gt;</ph>、現在実装していないと、<ph id="ph3">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>However, they appear to have <ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>, and <ph id="ph3">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides the default behavior for these methods.</source>
          <target state="translated">ただし、それらがように見えます<ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph>、 <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>、および<ph id="ph3">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>メソッド、c# または Visual Basic コードで使用すると、.NET Framework では、これらのメソッドの既定の動作です。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source><ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> classes that are written in C# or Visual Basic can override the <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> method overload.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> c# または Visual Basic で記述されたクラスをオーバーライドして、<ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>メソッドのオーバー ロードします。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Notes for Callers</source>
          <target state="translated">呼び出し元のノート</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Derived classes frequently override the <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> method to implement value equality.</source>
          <target state="translated">派生クラスでオーバーライドよく、<ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph>値の等価性を実装するメソッド。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>In addition, types also frequently provide an additional strongly typed overload to the <ph id="ph1">`Equals`</ph> method, typically by implementing the <ph id="ph2">&lt;xref:System.IEquatable%601&gt;</ph> interface.</source>
          <target state="translated">さらに、種類もを頻繁に提供する追加の厳密に型指定されたオーバー ロード、<ph id="ph1">`Equals`</ph>メソッドを実装することで、通常、<ph id="ph2">&lt;xref:System.IEquatable%601&gt;</ph>インターフェイスです。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>When you call the <ph id="ph1">`Equals`</ph> method to test for equality, you should know whether the current instance overrides <ph id="ph2">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph> and understand how a particular call to an <ph id="ph3">`Equals`</ph> method is resolved.</source>
          <target state="translated">呼び出すと、<ph id="ph1">`Equals`</ph>等しいかどうかをテストするメソッド、現在のインスタンスを上書きするかどうかを知っておくべき<ph id="ph2">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>に特定の呼び出し方法を理解して、<ph id="ph3">`Equals`</ph>メソッドが解決します。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Otherwise, you may be performing a test for equality that is different from what you intended, and the method may return an unexpected value.</source>
          <target state="translated">それ以外の場合、意図したものとは異なる等価性テストを実行して、メソッドは、予期しない値を返す可能性があります。</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The following example provides an illustration.</source>
          <target state="translated">具体的な例を次に示します。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>It instantiates three <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> objects with identical strings, and then makes four calls to <ph id="ph2">`Equals`</ph> methods.</source>
          <target state="translated">3 つをインスタンス化<ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph>オブジェクトと同一の文字列とを 4 つの呼び出しを行い、<ph id="ph2">`Equals`</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The first method call returns <ph id="ph1">`true`</ph>, and the remaining three return <ph id="ph2">`false`</ph>.</source>
          <target state="translated">最初のメソッドの呼び出しを返します<ph id="ph1">`true`</ph>と残りの 3 つの戻り値<ph id="ph2">`false`</ph>です。</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>In the first case, the strongly typed <ph id="ph1">&lt;xref:System.Text.StringBuilder.Equals%28System.Text.StringBuilder%29?displayProperty=nameWithType&gt;</ph> method overload, which tests for value equality, is called.</source>
          <target state="translated">最初の場合、厳密に型指定<ph id="ph1">&lt;xref:System.Text.StringBuilder.Equals%28System.Text.StringBuilder%29?displayProperty=nameWithType&gt;</ph>値の等価性テスト メソッドのオーバー ロードが呼び出されます。</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Because the strings assigned to the two <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> objects are equal, the method returns <ph id="ph2">`true`</ph>.</source>
          <target state="translated">2 つの文字列が割り当てられているため<ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph>オブジェクトが等しい、メソッドが返されます<ph id="ph2">`true`</ph>です。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>However, <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> does not override <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">ただし、<ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph>をオーバーライドしません<ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Because of this, when the <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> object is cast to an <ph id="ph2">&lt;xref:System.Object&gt;</ph>, when a <ph id="ph3">&lt;xref:System.Text.StringBuilder&gt;</ph> instance is assigned to a variable of type <ph id="ph4">&lt;xref:System.Object&gt;</ph>, and when the <ph id="ph5">&lt;xref:System.Object.Equals%28System.Object%2CSystem.Object%29?displayProperty=nameWithType&gt;</ph> method is passed two <ph id="ph6">&lt;xref:System.Text.StringBuilder&gt;</ph> objects, the default <ph id="ph7">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> method is called.</source>
          <target state="translated">このため、ときに、<ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph>オブジェクトにキャスト、<ph id="ph2">&lt;xref:System.Object&gt;</ph>ときに、<ph id="ph3">&lt;xref:System.Text.StringBuilder&gt;</ph>インスタンスが型の変数に割り当てられた<ph id="ph4">&lt;xref:System.Object&gt;</ph>とタイミング、<ph id="ph5">&lt;xref:System.Object.Equals%28System.Object%2CSystem.Object%29?displayProperty=nameWithType&gt;</ph>メソッドが渡される 2 つ<ph id="ph6">&lt;xref:System.Text.StringBuilder&gt;</ph>オブジェクト、既定値<ph id="ph7">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph>メソッドが呼び出されます。</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Because <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> is a reference type, this is equivalent to passing the two <ph id="ph2">&lt;xref:System.Text.StringBuilder&gt;</ph> objects to the <ph id="ph3">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> 、参照型では、これは、2 つを渡すことに相当<ph id="ph2">&lt;xref:System.Text.StringBuilder&gt;</ph>オブジェクトを<ph id="ph3">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Although all three <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> objects contain identical strings, they refer to three distinct objects.</source>
          <target state="translated">3 つすべて<ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph>オブジェクトと同じ文字列を格納する、3 つの異なるオブジェクトを参照しています。</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>As a result, these three method calls return <ph id="ph1">`false`</ph>.</source>
          <target state="translated">その結果、これら 3 つのメソッド呼び出しを返す<ph id="ph1">`false`</ph>です。</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>You can compare the current object to another object for reference equality by calling the <ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method.</source>
          <target state="translated">現在のオブジェクトを別のオブジェクト参照の等価性を比較するには呼び出すことによって、<ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>In Visual Basic, you can also use the <ph id="ph1">`is`</ph> keyword (for example, <ph id="ph2">`If Me Is otherObject Then ...`</ph>).</source>
          <target state="translated">Visual basic で使用することも、<ph id="ph1">`is`</ph>キーワード (たとえば、 <ph id="ph2">`If Me Is otherObject Then ...`</ph>)。</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Notes for Inheritors</source>
          <target state="translated">継承時の注意</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>When you define your own type, that type inherits the functionality defined by the <ph id="ph1">`Equals`</ph> method of its base type.</source>
          <target state="translated">独自の型を定義すると、その型を継承によって定義されている機能、<ph id="ph1">`Equals`</ph>その基本型のメソッドです。</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The following table lists the default implementation of the <ph id="ph1">`Equals`</ph> method for the major categories of types in the .NET Framework.</source>
          <target state="translated">次の表に、既定の実装、 <ph id="ph1">`Equals`</ph> .NET Framework の型の主なカテゴリのメソッドです。</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Type category</source>
          <target state="translated">型のカテゴリ</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Equality defined by</source>
          <target state="translated">によって定義される等価性</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Comments</source>
          <target state="translated">コメント</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Class derived directly from <ph id="ph1">&lt;xref:System.Object&gt;</ph></source>
          <target state="translated">直接派生したクラス <ph id="ph1">&lt;xref:System.Object&gt;</ph></target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Reference equality; equivalent to calling <ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">参照の等価性です。呼び出すことと同じ<ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Structure</source>
          <target state="translated">構造体</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Value equality; either direct byte-by-byte comparison or field-by-field comparison using reflection.</source>
          <target state="translated">値の等価性です。直接比較するバイトでまたはリフレクションを使用してフィールドの比較できます。</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Enumeration</source>
          <target state="translated">列挙</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Values must have the same enumeration type and the same underlying value.</source>
          <target state="translated">値は、同じ列挙型と同じ基になる値が必要です。</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Delegate</source>
          <target state="translated">Delegate</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Delegates must have the same type with identical invocation lists.</source>
          <target state="translated">デリゲートには、同一の呼び出しリストを持つ同じ型が必要です。</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Interface</source>
          <target state="translated">Interface</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Reference equality.</source>
          <target state="translated">参照の等価性。</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>For a value type, you should always override <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph>, because tests for equality that rely on reflection offer poor performance.</source>
          <target state="translated">値型にする必要がありますを常にオーバーライド<ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph>リフレクションに依存するテストが等しいかどうかは、パフォーマンスの低下を提供します。</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>You can also override the default implementation of <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> for reference types to test for value equality instead of reference equality and to define the precise meaning of value equality.</source>
          <target state="translated">既定の実装を上書きすることもできます。<ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph>参照型の参照の等価性ではなく値の等価性をテストすると、値の等価性の正確な意味を定義します。</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Such implementations of <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> return <ph id="ph2">`true`</ph> if the two objects have the same value, even if they are not the same instance.</source>
          <target state="translated">このような実装の<ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph>返す<ph id="ph2">`true`</ph>同じインスタンスでない場合でも、2 つのオブジェクトが同じ値があるかどうか。</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The type's implementer decides what constitutes an object's value, but it is typically some or all the data stored in the instance variables of the object.</source>
          <target state="translated">型の実行者は、オブジェクトの値の構成内容を決定が、通常一部またはすべてのデータ オブジェクトのインスタンスの変数に格納します。</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>For example, the value of a <ph id="ph1">&lt;xref:System.String&gt;</ph> object is based on the characters of the string; the <ph id="ph2">&lt;xref:System.String.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> method overrides the <ph id="ph3">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> method to return <ph id="ph4">`true`</ph> for any two string instances that contain the same characters in the same order.</source>
          <target state="translated">たとえばの値、<ph id="ph1">&lt;xref:System.String&gt;</ph>オブジェクトは、文字列の文字に基づいて、<ph id="ph2">&lt;xref:System.String.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph>メソッドのオーバーライド、<ph id="ph3">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph>を返すメソッドを<ph id="ph4">`true`</ph>任意の 2 つの文字列と同じ順序で同じ文字が含まれているインスタンス。</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The following example shows how to override the <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> method to test for value equality.</source>
          <target state="translated">次の例は、オーバーライドする方法を示します、<ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph>値の等価性をテストするメソッド。</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>It overrides the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> method for the <ph id="ph2">`Person`</ph> class.</source>
          <target state="translated">も優先、<ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph>のメソッド、<ph id="ph2">`Person`</ph>クラスです。</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>If <ph id="ph1">`Person`</ph> accepted its base class implementation of equality, two <ph id="ph2">`Person`</ph> objects would be equal only if they referenced a single object.</source>
          <target state="translated">場合<ph id="ph1">`Person`</ph>の等値をその基本クラス実装を受け入れる次の 2 つ<ph id="ph2">`Person`</ph>オブジェクトは 1 つのオブジェクトを参照した場合にのみ、等価になります。</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>However, in this case, two <ph id="ph1">`Person`</ph> objects are equal if they have the same value for the <ph id="ph2">`Person.Id`</ph> property.</source>
          <target state="translated">ただし、このケースでは、次の 2 つ<ph id="ph1">`Person`</ph>オブジェクトが同じ値がある場合に等しく、<ph id="ph2">`Person.Id`</ph>プロパティです。</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>In addition to overriding <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph>, you can implement the <ph id="ph2">&lt;xref:System.IEquatable%601&gt;</ph> interface to provide a strongly typed test for equality.</source>
          <target state="translated">オーバーライドするだけでなく<ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph>、実装することができます、<ph id="ph2">&lt;xref:System.IEquatable%601&gt;</ph>等値の厳密に型指定されたテストを提供するインターフェイスです。</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The following statements must be true for all implementations of the <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> method.</source>
          <target state="translated">次のステートメントは、のすべての実装の場合は true である必要があります、<ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>In the list, <ph id="ph1">`x`</ph>, <ph id="ph2">`y`</ph>, and <ph id="ph3">`z`</ph> represent object references that are not <bpt id="p1">**</bpt>null<ept id="p1">**</ept>.</source>
          <target state="translated">一覧で、 <ph id="ph1">`x`</ph>、 <ph id="ph2">`y`</ph>、および<ph id="ph3">`z`</ph>れていないオブジェクト参照を表す<bpt id="p1">**</bpt>null<ept id="p1">**</ept>です。</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source><ph id="ph1">`x.Equals(x)`</ph> returns <ph id="ph2">`true`</ph>, except in cases that involve floating-point types.</source>
          <target state="translated"><ph id="ph1">`x.Equals(x)`</ph> 返します<ph id="ph2">`true`</ph>、浮動小数点型に関連する場合は除きます。</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>See ISO/IEC/IEEE 60559:2011, Information technology -- Microprocessor Systems -- Floating-Point arithmetic.</source>
          <target state="translated">ISO と IEC/IEEE 60559:2011、情報テクノロジ--マイクロプロセッサ システムであり、浮動小数点算術演算子を参照してください。</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source><ph id="ph1">`x.Equals(y)`</ph> returns the same value as <ph id="ph2">`y.Equals(x)`</ph>.</source>
          <target state="translated"><ph id="ph1">`x.Equals(y)`</ph> 同じ値を返します<ph id="ph2">`y.Equals(x)`</ph>です。</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source><ph id="ph1">`x.Equals(y)`</ph> returns <ph id="ph2">`true`</ph> if both <ph id="ph3">`x`</ph> and <ph id="ph4">`y`</ph> are <ph id="ph5">`NaN`</ph>.</source>
          <target state="translated"><ph id="ph1">`x.Equals(y)`</ph> 返します<ph id="ph2">`true`</ph>両方<ph id="ph3">`x`</ph>と<ph id="ph4">`y`</ph>は<ph id="ph5">`NaN`</ph>します。</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>If <ph id="ph1">`(x.Equals(y) &amp;&amp; y.Equals(z))`</ph> returns <ph id="ph2">`true`</ph>, then <ph id="ph3">`x.Equals(z)`</ph> returns <ph id="ph4">`true`</ph>.</source>
          <target state="translated">場合<ph id="ph1">`(x.Equals(y) &amp;&amp; y.Equals(z))`</ph>返します<ph id="ph2">`true`</ph>、し<ph id="ph3">`x.Equals(z)`</ph>返します<ph id="ph4">`true`</ph>です。</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Successive calls to <ph id="ph1">`x.Equals(y)`</ph> return the same value as long as the objects referenced by <ph id="ph2">`x`</ph> and <ph id="ph3">`y`</ph> are not modified.</source>
          <target state="translated">連続して呼び出す<ph id="ph1">`x.Equals(y)`</ph>によってオブジェクトが参照されている限り、同じ値を返す<ph id="ph2">`x`</ph>と<ph id="ph3">`y`</ph>は変更されません。</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source><ph id="ph1">`x.Equals(null)`</ph> returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated"><ph id="ph1">`x.Equals(null)`</ph> は、<ph id="ph2">`false`</ph> を返します。</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Implementations of <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> must not throw exceptions; they should always return a value.</source>
          <target state="translated">実装<ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph>は例外をスローする必要がありますいないそれらは常に値を返します。</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>For example, if <ph id="ph1">`obj`</ph> is <ph id="ph2">`null`</ph>, the <ph id="ph3">&lt;xref:System.Object.Equals%2A&gt;</ph> method should return <ph id="ph4">`false`</ph> instead of throwing an <ph id="ph5">&lt;xref:System.ArgumentNullException&gt;</ph>.</source>
          <target state="translated">たとえば場合、<ph id="ph1">`obj`</ph>は<ph id="ph2">`null`</ph>、<ph id="ph3">&lt;xref:System.Object.Equals%2A&gt;</ph>メソッドが返す<ph id="ph4">`false`</ph>スローする代わりに、<ph id="ph5">&lt;xref:System.ArgumentNullException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Follow these guidelines when overriding <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>:</source>
          <target state="translated">オーバーライドする場合は、次のガイドラインをに従って<ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>:</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Types that implement <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> must override <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>.</source>
          <target state="translated">型を実装する<ph id="ph1">&lt;xref:System.IComparable&gt;</ph>オーバーライドする必要があります<ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Types that override <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> must also override <ph id="ph2">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>; otherwise, hash tables  might not work correctly.</source>
          <target state="translated">型のオーバーライドが<ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>もオーバーライドしなければなりません<ph id="ph2">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>以外の場合、ハッシュ テーブルが正しく動作しません。</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>You should consider implementing the <ph id="ph1">&lt;xref:System.IEquatable%601&gt;</ph> interface to support strongly typed tests for equality.</source>
          <target state="translated">実装を検討する必要があります、<ph id="ph1">&lt;xref:System.IEquatable%601&gt;</ph>強くをサポートするインターフェイスが等しいかどうかのテストを入力します。</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Your <ph id="ph1">&lt;xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType&gt;</ph> implementation should return results that are consistent with <ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType&gt;</ph>実装と一貫性のある結果を返す必要があります<ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>If your programming language supports operator overloading and you overload the equality operator for a given type, you must also override the <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> method to return the same result as the equality operator.</source>
          <target state="translated">場合は、プログラミング言語は、演算子のオーバー ロードをサポートしていると、指定された型の等値演算子をオーバー ロードする、上書きすることも必要があります、<ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>等値演算子と同じ結果を返すメソッド。</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>This  helps ensure that class library code that uses <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> (such as <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> and <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph>) behaves in a manner that is consistent with the way the equality operator is used by application code.</source>
          <target state="translated">これにより、そのクラス ライブラリのコードを使用する<ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph>(など<ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>と<ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph>) は、アプリケーション コードで、等値演算子を使用する方法と一致するように動作します。</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Guidelines for Reference Types</source>
          <target state="translated">参照型に関するガイドライン</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The following guidelines apply to overriding <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> for a reference type:</source>
          <target state="translated">オーバーライドするのに次のガイドラインが適用<ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>参照型。</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Consider overriding <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> if the semantics of the type are based on the fact that the type represents some value(s).</source>
          <target state="translated">オーバーライドを検討してください<ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph>場合は、型のセマンティクスは、という事実に基づいて、種類がいくつかの値を表します。</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Most reference types must not overload the equality operator, even if they override <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph>.</source>
          <target state="translated">ほとんどの参照型である必要がありますをオーバーライドする場合でもを等値演算子オーバー ロードしない<ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>However, if you are implementing a reference type that is intended to have value semantics, such as a complex number type, you must override the equality operator.</source>
          <target state="translated">ただしなど、複雑な数値型の値のセマンティクスを持つものでは参照型を実装している場合は、等値演算子をオーバーライドする必要があります。</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>You should not override <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> on a mutable reference type.</source>
          <target state="translated">オーバーライドしないでください<ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph>変更可能な参照型にします。</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>This is because overriding <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> requires that you also override the <ph id="ph2">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> method, as discussed in the previous section.</source>
          <target state="translated">これは、オーバーライドするため<ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph>オーバーライドすることも必要があります、<ph id="ph2">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>メソッド、前のセクションで説明したようにします。</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>This means that the hash code of an instance of a mutable reference type can change during its lifetime, which can cause the object to be lost in a hash table.</source>
          <target state="translated">つまり、変更可能な参照型のインスタンスのハッシュ コードがその有効期間中に、ハッシュ テーブルで、オブジェクトが失われた可能性がありますを変更できます。</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Guidelines for Value Types</source>
          <target state="translated">値の型に関するガイドライン</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The following guidelines apply to overriding <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> for a value type:</source>
          <target state="translated">オーバーライドするのに次のガイドラインが適用<ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>値の型に対して。</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>If you are defining a value type that includes one or more fields whose values are reference types, you should override <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>.</source>
          <target state="translated">1 つまたは複数のフィールドを含む値の型を定義している場合は参照型の値が、オーバーライドする必要があります<ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> implementation provided by <ph id="ph2">&lt;xref:System.ValueType&gt;</ph> performs a byte-by-byte comparison for value types whose fields are all value types, but it uses reflection to perform a field-by-field comparison of value types whose fields include reference types.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>で提供される実装<ph id="ph2">&lt;xref:System.ValueType&gt;</ph>値型がバイト単位の比較を実行のフィールドは、すべての値の型がリフレクションを使用して、その結果、フィールドが参照型を含む値の型のフィールドの比較を実行します。</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>If you override <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and your development language supports operator overloading, you must overload the equality operator.</source>
          <target state="translated">オーバーライドする場合は<ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph>開発言語には、演算子のオーバー ロードがサポートしていると、等値演算子をオーバー ロードする必要があります。</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>You should implement the <ph id="ph1">&lt;xref:System.IEquatable%601&gt;</ph> interface.</source>
          <target state="translated">実装する必要があります、<ph id="ph1">&lt;xref:System.IEquatable%601&gt;</ph>インターフェイスです。</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Calling the strongly typed <ph id="ph1">&lt;xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType&gt;</ph> method avoids boxing the <ph id="ph2">`obj`</ph> argument.</source>
          <target state="translated">厳密に型を呼び出す<ph id="ph1">&lt;xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType&gt;</ph>メソッドは、ボックス化を回避できます、<ph id="ph2">`obj`</ph>引数。</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The following example shows a <ph id="ph1">`Point`</ph> class that overrides the <ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph> method to provide value equality, and a <ph id="ph3">`Point3D`</ph> class that is derived from <ph id="ph4">`Point`</ph>.</source>
          <target state="translated">例を次に、<ph id="ph1">`Point`</ph>をオーバーライドするクラス、<ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph>値の等価性を提供するメソッドと<ph id="ph3">`Point3D`</ph>から派生したクラスを<ph id="ph4">`Point`</ph>です。</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Because <ph id="ph1">`Point`</ph> overrides <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> to test for value equality, the <ph id="ph3">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> method is not called.</source>
          <target state="translated"><ph id="ph1">`Point`</ph>オーバーライド<ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph>値の等価性をテストする、<ph id="ph3">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph>メソッドは呼び出されません。</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>However, <ph id="ph1">`Point3D.Equals`</ph> calls <ph id="ph2">`Point.Equals`</ph> because <ph id="ph3">`Point`</ph> implements <ph id="ph4">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> in a manner that provides value equality.</source>
          <target state="translated">ただし、<ph id="ph1">`Point3D.Equals`</ph>呼び出し<ph id="ph2">`Point.Equals`</ph>ため<ph id="ph3">`Point`</ph>実装<ph id="ph4">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph>で値の等価性を提供できるようにします。</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The <ph id="ph1">`Point.Equals`</ph> method checks to make sure that the <ph id="ph2">`obj`</ph> argument is not <bpt id="p1">**</bpt>null<ept id="p1">**</ept> and that it references an instance of the same type as this object.</source>
          <target state="translated"><ph id="ph1">`Point.Equals`</ph>メソッドをチェックすることを確認して、<ph id="ph2">`obj`</ph>引数ではありません<bpt id="p1">**</bpt>null<ept id="p1">**</ept>このオブジェクトと同じ型のインスタンスを参照しているとします。</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>If either check fails, the method returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">メソッドを返しますのかどうかはいずれかのチェックに失敗する、<ph id="ph1">`false`</ph>です。</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The <ph id="ph1">`Point.Equals`</ph> method calls the <ph id="ph2">&lt;xref:System.Object.GetType%2A&gt;</ph> method to determine whether the run-time types of the two objects are identical.</source>
          <target state="translated"><ph id="ph1">`Point.Equals`</ph>メソッドの呼び出し、 <ph id="ph2">&lt;xref:System.Object.GetType%2A&gt;</ph> 2 つのオブジェクトの実行時の型が同一かどうかを調べます。</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>If the method used a check of the form <ph id="ph1">`obj is Point`</ph> in C# or <ph id="ph2">`TryCast(obj, Point)`</ph> in Visual Basic, the check would return <ph id="ph3">`true`</ph> in cases where <ph id="ph4">`obj`</ph> is an instance of a derived class of <ph id="ph5">`Point`</ph>, even though <ph id="ph6">`obj`</ph> and the current instance are not of the same run-time type.</source>
          <target state="translated">メソッドには、フォームのチェックが使用されている場合<ph id="ph1">`obj is Point`</ph>(C#) または<ph id="ph2">`TryCast(obj, Point)`</ph>Visual basic で、チェックを返すよう<ph id="ph3">`true`</ph>の場合、<ph id="ph4">`obj`</ph>の派生クラスのインスタンスは、<ph id="ph5">`Point`</ph>場合でも、<ph id="ph6">`obj`</ph>と現在インスタンスが同一の実行時の型です。</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Having verified that both objects are of the same type, the method casts <ph id="ph1">`obj`</ph> to type <ph id="ph2">`Point`</ph> and returns the result of comparing the instance fields of the two objects.</source>
          <target state="translated">両方のオブジェクトが同じ型、メソッドのキャストのことを確認したら<ph id="ph1">`obj`</ph>入力<ph id="ph2">`Point`</ph>2 つのオブジェクトのインスタンス フィールドを比較の結果を返します。</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>In <ph id="ph1">`Point3D.Equals`</ph>, the inherited <ph id="ph2">`Point.Equals`</ph> method, which overrides <ph id="ph3">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph>, is invoked before anything else is done.</source>
          <target state="translated"><ph id="ph1">`Point3D.Equals`</ph>、継承された<ph id="ph2">`Point.Equals`</ph>メソッドのオーバーライド<ph id="ph3">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph>が何を行う前に呼び出されます。</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Because <ph id="ph1">`Point3D`</ph> is a sealed class (<ph id="ph2">`NotInheritable`</ph> in Visual Basic), a check in the form <ph id="ph3">`obj is Point`</ph> in C# or <ph id="ph4">`TryCast(obj, Point)`</ph> in Visual Basic is adequate to ensure that <ph id="ph5">`obj`</ph> is a <ph id="ph6">`Point3D`</ph> object.</source>
          <target state="translated"><ph id="ph1">`Point3D`</ph> 、シール クラスは、(<ph id="ph2">`NotInheritable`</ph> Visual Basic で)、フォームにチェック マーク<ph id="ph3">`obj is Point`</ph>(C#) または<ph id="ph4">`TryCast(obj, Point)`</ph>Visual Basic では、いることを確認するのに十分<ph id="ph5">`obj`</ph>は、<ph id="ph6">`Point3D`</ph>オブジェクト。</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>If it is a <ph id="ph1">`Point3D`</ph> object, it is cast to a <ph id="ph2">`Point`</ph> object and passed to the base class implementation of <ph id="ph3">&lt;xref:System.Object.Equals%2A&gt;</ph>.</source>
          <target state="translated">ある場合、<ph id="ph1">`Point3D`</ph>オブジェクトにキャスト、<ph id="ph2">`Point`</ph>オブジェクトし、の基本クラスの実装に渡される<ph id="ph3">&lt;xref:System.Object.Equals%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Only when the inherited <ph id="ph1">`Point.Equals`</ph> method returns <ph id="ph2">`true`</ph> does the method compare the <ph id="ph3">`z`</ph> instance fields introduced in the derived class.</source>
          <target state="translated">場合にのみ、継承された<ph id="ph1">`Point.Equals`</ph>メソッドを返します。<ph id="ph2">`true`</ph>メソッド比較は、<ph id="ph3">`z`</ph>インスタンス フィールドが、派生クラスで導入されました。</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The following example defines a <ph id="ph1">`Rectangle`</ph> class that internally implements a rectangle as two <ph id="ph2">`Point`</ph> objects.</source>
          <target state="translated">次の例では定義、<ph id="ph1">`Rectangle`</ph>として 2 つの四角形を内部的に実装するクラス<ph id="ph2">`Point`</ph>オブジェクト。</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>The <ph id="ph1">`Rectangle`</ph> class also overrides <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> to provide for value equality.</source>
          <target state="translated"><ph id="ph1">`Rectangle`</ph>クラスも上書き<ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph>値の等価性を提供します。</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Some languages such as C# and Visual Basic support operator overloading.</source>
          <target state="translated">C# および Visual Basic などの一部の言語では、演算子のオーバー ロードをサポートします。</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>When a type overloads the equality operator, it must also override the <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> method to provide the same functionality.</source>
          <target state="translated">オーバーライドする必要がありますも、型は、等値演算子をオーバー ロード、ときに、<ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>同じ機能を提供するメソッド。</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>This is typically accomplished by writing the <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> method in terms of the overloaded equality operator, as in the following example.</source>
          <target state="translated">記述してこれは通常、<ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>次の例のように、オーバー ロードされた等値演算子の観点からのメソッドです。</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Because <ph id="ph1">`Complex`</ph> is a value type, it cannot be derived from.</source>
          <target state="translated"><ph id="ph1">`Complex`</ph>は、値の型から派生することはできません。</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object)">
          <source>Therefore, the override to <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> method need not call <ph id="ph2">&lt;xref:System.Object.GetType%2A&gt;</ph> to determine the precise run-time type of each object, but can instead use the <ph id="ph3">`is`</ph> operator in C# or the <ph id="ph4">`TypeOf`</ph> operator in Visual Basic to check the type of the <ph id="ph5">`obj`</ph> parameter.</source>
          <target state="translated">そのため、上書きを<ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>メソッドを呼び出す必要はありません<ph id="ph2">&lt;xref:System.Object.GetType%2A&gt;</ph>を決定する正確なランタイムを入力できますが、各オブジェクトの代わりに使用する、 <ph id="ph3">`is`</ph> (C#) 演算子または<ph id="ph4">`TypeOf`</ph>の種類を確認するVisualBasicの演算子<ph id="ph5">`obj`</ph>パラメーター。</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>The first object to compare.</source>
          <target state="translated">比較する最初のオブジェクト。</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>The second object to compare.</source>
          <target state="translated">比較する 2 番目のオブジェクト。</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>Determines whether the specified object instances are considered equal.</source>
          <target state="translated">指定されたインスタンスが等しいかどうかを判断します。</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the objects are considered equal; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">オブジェクトが等しいと見なされた場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。それ以外の場合は <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>If both <ph id="ph1">&lt;paramref name="objA" /&gt;</ph> and <ph id="ph2">&lt;paramref name="objB" /&gt;</ph> are <bpt id="p1">**</bpt>null<ept id="p1">**</ept>, the method returns <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="objA" /&gt;</ph> と <ph id="ph2">&lt;paramref name="objB" /&gt;</ph> の両方が <bpt id="p1">**</bpt>null<ept id="p1">**</ept> の場合、このメソッドは <ph id="ph3">&lt;see langword="true" /&gt;</ph> を返します。</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>The static <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%2CSystem.Object%29&gt;</ph> method indicates whether two objects, <ph id="ph2">`objA`</ph> and  <ph id="ph3">`objB`</ph>, are equal.</source>
          <target state="translated">静的な<ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%2CSystem.Object%29&gt;</ph>かどうか 2 つのオブジェクト、メソッドを示します<ph id="ph2">`objA`</ph>と<ph id="ph3">`objB`</ph>、等しい。</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>It also enables you to test objects whose value is <bpt id="p1">**</bpt>null<ept id="p1">**</ept> for equality.</source>
          <target state="translated">オブジェクトの値をテストすることもできます<bpt id="p1">**</bpt>null<ept id="p1">**</ept>等しいかどうか。</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>It compares <ph id="ph1">`objA`</ph> and <ph id="ph2">`objB`</ph> for equality as follows:</source>
          <target state="translated">比較<ph id="ph1">`objA`</ph>と<ph id="ph2">`objB`</ph>次のように等しいかどうか。</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>It determines whether the two objects represent the same object reference.</source>
          <target state="translated">これは、2 つのオブジェクトが同じオブジェクト参照を表すかどうかを判断します。</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>If they do, the method returns <ph id="ph1">`true`</ph>.</source>
          <target state="translated">このメソッドを返しますのかどうかは、<ph id="ph1">`true`</ph>です。</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>This test is equivalent to calling the <ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method.</source>
          <target state="translated">このテストは呼び出すことと同じ、<ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>In addition, if both <ph id="ph1">`objA`</ph> and <ph id="ph2">`objB`</ph> are <bpt id="p1">**</bpt>null<ept id="p1">**</ept>, the method returns <ph id="ph3">`true`</ph>.</source>
          <target state="translated">さらに、両方<ph id="ph1">`objA`</ph>と<ph id="ph2">`objB`</ph>は<bpt id="p1">**</bpt>null<ept id="p1">**</ept>、メソッドを返します<ph id="ph3">`true`</ph>です。</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>It determines whether either <ph id="ph1">`objA`</ph> or <ph id="ph2">`objB`</ph> is <bpt id="p1">**</bpt>null<ept id="p1">**</ept>.</source>
          <target state="translated">決定するかどうか、<ph id="ph1">`objA`</ph>または<ph id="ph2">`objB`</ph>は<bpt id="p1">**</bpt>null<ept id="p1">**</ept>です。</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>If so, it returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">そのため、返された場合<ph id="ph1">`false`</ph>です。</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>If the two objects do not represent the same object reference and neither is <bpt id="p1">**</bpt>null<ept id="p1">**</ept>, it calls <ph id="ph1">`objA`</ph>.<ph id="ph2">`Equals`</ph>(<ph id="ph3">`objB`</ph>) and returns the result.</source>
          <target state="translated">2 つのオブジェクトが同じオブジェクト参照を表さないとなりはどちらも<bpt id="p1">**</bpt>null<ept id="p1">**</ept>、呼び出す<ph id="ph1">`objA`</ph>.<ph id="ph2">`Equals`</ph>(<ph id="ph3">`objB`</ph>) し、結果を返します。</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>This means that if <ph id="ph1">`objA`</ph> overrides the <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> method, this override is called.</source>
          <target state="translated">つまり、<ph id="ph1">`objA`</ph>よりも優先、<ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph>メソッド、このオーバーライドが呼び出されます。</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Equals(System.Object,System.Object)">
          <source>The following example illustrates the <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%2CSystem.Object%29&gt;</ph> method and compares it with the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method.</source>
          <target state="translated">次の例を示しています、<ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%2CSystem.Object%29&gt;</ph>メソッドとの比較、<ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.Object.Finalize">
          <source>Allows an object to try to free resources and perform other cleanup operations before it is reclaimed by garbage collection.</source>
          <target state="translated">オブジェクトが、ガベージ コレクションによって収集される前に、リソースの解放とその他のクリーンアップ操作の実行を試みることができるようにします。</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method is used to perform cleanup operations on unmanaged resources held by the current object before the object is destroyed.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph>オブジェクトが破棄される前に、現在のオブジェクトによって保持されているアンマネージ リソースのクリーンアップ操作を実行するメソッドを使用します。</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The method is protected and therefore is accessible only through this class or through a derived class.</source>
          <target state="translated">メソッドが保護されているためおよび派生クラスによって、またはこのクラスによってのみアクセスできます。</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>In this section:</source>
          <target state="translated">このセクションの内容:</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source><bpt id="p1">[</bpt>How finalization works<ept id="p1">](#How)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>終了処理のしくみ<ept id="p1">](#How)</ept></target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source><bpt id="p1">[</bpt>Notes for implementers<ept id="p1">](#Notes)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>実装についてのメモ<ept id="p1">](#Notes)</ept></target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source><bpt id="p1">[</bpt>The SafeHandle alternative<ept id="p1">](#SafeHandle)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>SafeHandle の代替手段<ept id="p1">](#SafeHandle)</ept></target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>How finalization works</source>
          <target state="translated">終了処理のしくみ</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The <ph id="ph1">&lt;xref:System.Object&gt;</ph> class provides no implementation for the <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> method, and the garbage collector does not mark types derived from <ph id="ph3">&lt;xref:System.Object&gt;</ph> for finalization unless they override the <ph id="ph4">&lt;xref:System.Object.Finalize%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object&gt;</ph>クラスの実装を提供なし、<ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph>メソッド、および、ガベージ コレクターから派生した型をマークしません<ph id="ph3">&lt;xref:System.Object&gt;</ph>終了がオーバーライドされない限り、<ph id="ph4">&lt;xref:System.Object.Finalize%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>If a type does override the <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method, the garbage collector adds an entry for each instance of the type to an internal structure called the finalization queue.</source>
          <target state="translated">型をオーバーライドする場合、<ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph>メソッド、ガベージ コレクターにエントリを追加、型のインスタンスごとにファイナライザー キューと呼ばれる内部構造体。</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The finalization queue contains entries for all the objects in the managed heap whose finalization code must run before the garbage collector can reclaim their memory.</source>
          <target state="translated">ファイナライザーのキューには、すべてのオブジェクトが終了コードは、ガベージ コレクターが自らのメモリを解放する前に実行する必要があります、マネージ ヒープ内のエントリが含まれています。</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The garbage collector then calls the <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method automatically under the following conditions:</source>
          <target state="translated">ガベージ コレクターを呼び出して、<ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph>メソッドは、次の条件下で自動的に。</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>After the garbage collector has discovered that an object is inaccessible, unless the object has been exempted from finalization by a call to the <ph id="ph1">&lt;xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">ガベージ コレクターがオブジェクトをへの呼び出しによって終了処理から除外されている場合を除き、オブジェクトがアクセス可能でないを検出したら、<ph id="ph1">&lt;xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>During shutdown of an application domain, unless the object is exempt from finalization.</source>
          <target state="translated">アプリケーション ドメインのシャット ダウン中にオブジェクトが終了処理から除外されている場合を除き、します。</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>During shutdown, even objects that are still accessible are finalized.</source>
          <target state="translated">シャット ダウン中、引き続きアクセスできるものオブジェクトが完了しました。</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> is automatically called only once on a given instance, unless the object is re-registered by using a mechanism such as <ph id="ph2">&lt;xref:System.GC.ReRegisterForFinalize%2A?displayProperty=nameWithType&gt;</ph> and the <ph id="ph3">&lt;xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType&gt;</ph> method has not been subsequently called.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> 自動的に 1 回だけ呼び出す特定のインスタンスでオブジェクトが再などのメカニズムを使用して、登録されている場合を除き、<ph id="ph2">&lt;xref:System.GC.ReRegisterForFinalize%2A?displayProperty=nameWithType&gt;</ph>と<ph id="ph3">&lt;xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType&gt;</ph>メソッドが、その後に呼び出されていません。</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> operations have the following limitations:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> 操作には、次の制限があります。</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The exact time when the finalizer executes is undefined.</source>
          <target state="translated">ファイナライザーの実行の正確な時間は、定義されていません。</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>To ensure deterministic release of resources for instances of your class, implement a <ph id="ph1">`Close`</ph> method or provide a <ph id="ph2">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> implementation.</source>
          <target state="translated">リソースの確定的に解放をように、クラスのインスタンスを実装する、<ph id="ph1">`Close`</ph>メソッドを提供したり、<ph id="ph2">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph>実装します。</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The finalizers of two objects are not guaranteed to run in any specific order, even if one object refers to the other.</source>
          <target state="translated">2 つのオブジェクトのファイナライザーは、1 つのオブジェクトを指す他の場合でも、特定の順序で実行する保証はありません。</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>That is, if Object A has a reference to Object B and both have finalizers, Object B might have already been finalized when the finalizer of Object A starts.</source>
          <target state="translated">つまり、オブジェクト A がオブジェクト B への参照を両方ファイナライザーがある場合は、オブジェクト B 可能性がありますが既に終了されているオブジェクトのファイナライザーの開始時にします。</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The thread on which the finalizer runs is unspecified.</source>
          <target state="translated">ファイナライザーが実行されているスレッドは、指定されていません。</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method might not run to completion or might not run at all under the following exceptional circumstances:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph>メソッドが完了するまで実行されないか、次の例外的な状況でまったく実行されない可能性があります。</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>If another finalizer blocks indefinitely (goes into an infinite loop, tries to obtain a lock it can never obtain, and so on).</source>
          <target state="translated">別のファイナライザーが無期限にブロックした場合 (、無限ループに移動しようとすることはありませんを入手してなどのロックの取得)。</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>Because the runtime tries to run finalizers to completion, other finalizers might not be called if a finalizer blocks indefinitely.</source>
          <target state="translated">ランタイムがファイナライザーを完了するまで実行しようとするとため、その他のファイナライザー可能性がある場合は呼び出されませんファイナライザー ブロック無期限にします。</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>If the process terminates without giving the runtime a chance to clean up.</source>
          <target state="translated">場合は、ランタイムをクリーンアップする機会を与えることがなく、プロセスを終了します。</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>In this case, the runtime's first notification of process termination is a DLL_PROCESS_DETACH notification.</source>
          <target state="translated">この場合、ランタイムのプロセスの終了の最初の通知はあります通知です。</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The runtime continues to finalize objects during shutdown only while the number of finalizable objects continues to decrease.</source>
          <target state="translated">ランタイムは、ファイナライズ可能なオブジェクトの数が減少し続けます中にのみ、シャット ダウン中にオブジェクトを最終処理を続行します。</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>If <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> or an override of <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> throws an exception, and the runtime is not hosted by an application that overrides the default policy, the runtime terminates the process and no active <ph id="ph3">`try`</ph><ph id="ph4">/</ph><ph id="ph5">`finally`</ph> blocks or finalizers are executed.</source>
          <target state="translated">場合<ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph>またはのオーバーライド<ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph>、例外をスローし、ランタイムが、既定のポリシーをオーバーライドするアプリケーションによってホストされていない、プロセスとはアクティブなランタイムが終了する<ph id="ph3">`try`</ph> <ph id="ph4">/</ph> <ph id="ph5">`finally`</ph>ブロックまたはファイナライザーを実行します。</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>This behavior ensures process integrity if the finalizer cannot free or destroy resources.</source>
          <target state="translated">この動作は、ファイナライザーが解放またはリソースを破棄できない場合、プロセスの整合性を確保します。</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>Overriding the Finalize method</source>
          <target state="translated">Finalize メソッドをオーバーライドします。</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>You should override <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> for a class that uses unmanaged resources, such as file handles or database connections that must be released when the managed object that uses them is discarded during garbage collection.</source>
          <target state="translated">オーバーライドする必要があります<ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph>ファイル ハンドルやガベージ コレクション中にそれらを使用するマネージ オブジェクトが破棄されたときに解放する必要がありますのあるデータベース接続などのアンマネージ リソースを使用するクラス。</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>You shouldn't implement a <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method for managed objects because the garbage collector releases managed resources automatically.</source>
          <target state="translated">実装しないでください、<ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph>ガベージ コレクターが自動的にマネージ リソースを解放するためのメソッドがオブジェクトを管理します。</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>If a <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> object is available that wraps your unmanaged resource, the recommended alternative is to implement the dispose pattern with a safe handle and not override <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph>.</source>
          <target state="translated">場合、<ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph>オブジェクトが使用可能なアンマネージ リソースをラップする、推奨される代替手段は、セーフ ハンドルの dispose パターンを実装し、無効にする<ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>For more information, see <bpt id="p1">[</bpt>The SafeHandle alternative<ept id="p1">](#SafeHandle)</ept> section.</source>
          <target state="translated">詳細については、次を参照してください。<bpt id="p1">[</bpt>代わりに、SafeHandle<ept id="p1">](#SafeHandle)</ept>セクションです。</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The <ph id="ph1">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph> method does nothing by default, but you should override <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> only if necessary, and only to release unmanaged resources.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph>メソッドは既定では、何しますが、オーバーライドする必要があります<ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph>のみ必要であれば、アンマネージ リソースを解放するだけです。</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>Reclaiming memory tends to take much longer if a finalization operation runs, because it requires at least two garbage collections.</source>
          <target state="translated">メモリを再利用するには、少なくとも 2 つのガベージ コレクションが必要とするために終了操作を実行する場合は、かなり長くかかる傾向があります。</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>In addition, you should override the <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method for reference types only.</source>
          <target state="translated">さらに、オーバーライドする必要があります、<ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph>参照用のメソッドの型だけです。</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The common language runtime only finalizes reference types.</source>
          <target state="translated">共通言語ランタイムは、参照型のみを終了します。</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>It ignores finalizers on value types.</source>
          <target state="translated">値型でファイナライザーは無視されます。</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The scope of the <ph id="ph1">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph> method is <ph id="ph2">`protected`</ph>.</source>
          <target state="translated">スコープ、<ph id="ph1">&lt;xref:System.Object.Finalize%2A?displayProperty=nameWithType&gt;</ph>メソッドは<ph id="ph2">`protected`</ph>します。</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>You should maintain this limited scope when you override the method in your class.</source>
          <target state="translated">クラス内でこのメソッドをオーバーライドする場合は、このスコープの範囲を維持する必要があります。</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>By keeping a <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method protected, you prevent users of your application from calling an object's <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> method directly.</source>
          <target state="translated">保持することで、<ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph>保護されているメソッド、オブジェクトの呼び出し元から、アプリケーションのユーザーを防ぐ<ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph>メソッドを直接です。</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>Every implementation of <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> in a derived type must call its base type's implementation of <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph>.</source>
          <target state="translated">すべての実装の<ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph>派生型での基本データ型の実装を呼び出す必要があります<ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>This is the only case in which application code is allowed to call <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph>.</source>
          <target state="translated">これを呼び出すアプリケーション コードが許可されている場合だけ<ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>An object's <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method shouldn't call a method on any objects other than that of its base class.</source>
          <target state="translated">オブジェクトの<ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph>メソッドは、基底クラスのではないすべてのオブジェクトに対するメソッドを呼び出すことはできません。</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>This is because the other objects being called could be collected at the same time as the calling object, such as in the case of a common language runtime shutdown.</source>
          <target state="translated">これは、共通言語ランタイムがシャットダウンされる場合など、呼び出し元のオブジェクトと呼び出された別のオブジェクトが同時にガベージ コレクションされることがあるからです。</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The C# compiler does not allow you to override the <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method.</source>
          <target state="translated">C# コンパイラを上書きすることはできません、<ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>Instead, you provide a finalizer by implementing a <bpt id="p1">[</bpt>destructor<ept id="p1">](~/docs/csharp/programming-guide/classes-and-structs/destructors.md)</ept> for your class.</source>
          <target state="translated">実装することでファイナライザーを用意する代わりに、<bpt id="p1">[</bpt>デストラクター<ept id="p1">](~/docs/csharp/programming-guide/classes-and-structs/destructors.md)</ept>クラスです。</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>A C# destructor automatically calls the destructor of its base class.</source>
          <target state="translated">C# のデストラクターは、その基本クラスのデストラクターを自動的に呼び出します。</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>Visual C++ also provides its own syntax for implementing the <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method.</source>
          <target state="translated">Visual C を実装する独自の構文もが用意されています、<ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>For more information, see the "Destructors and finalizers" section of <bpt id="p1">[</bpt>How to: Define and Consume Classes and Structs (C++/CLI)<ept id="p1">](http://msdn.microsoft.com/library/1c03cb0d-1459-4b5e-af65-97d6b3094fd7)</ept>.</source>
          <target state="translated">詳細については、の「デストラクターとファイナライザー」セクションを参照してください。<bpt id="p1">[</bpt>する方法: を定義すると消費クラスと構造体 (C + + CLI)<ept id="p1">](http://msdn.microsoft.com/library/1c03cb0d-1459-4b5e-af65-97d6b3094fd7)</ept>です。</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>Because garbage collection is non-deterministic, you do not know precisely when the garbage collector performs finalization.</source>
          <target state="translated">ガベージ コレクションは非決定的であるため、ガベージ コレクターが終了処理を実行すると正確にわかっていません。</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>To release resources immediately, you can also choose to implement the <bpt id="p1">[</bpt>dispose pattern<ept id="p1">](~/docs/standard/design-guidelines/dispose-pattern.md)</ept> and the <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interface.</source>
          <target state="translated">リソースを解放する、すぐにこともできますを実装する、 <bpt id="p1">[</bpt>dispose パターン<ept id="p1">](~/docs/standard/design-guidelines/dispose-pattern.md)</ept>と<ph id="ph1">&lt;xref:System.IDisposable&gt;</ph>インターフェイスです。</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> implementation can be called by consumers of your class to free unmanaged resources, and you can use the <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> method to free unmanaged resources in the event that the <ph id="ph3">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method is not called.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType&gt;</ph> 、アンマネージ リソースを解放する、クラスのコンシューマーによって実装を呼び出すことができ、使用することができます、<ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph>アンマネージ リソースを解放するメソッドを<ph id="ph3">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph>メソッドは呼び出されません。</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> can take almost any action, including resurrecting an object (that is, making the object accessible again) after it has been cleaned up during garbage collection.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> ガベージ コレクション中にクリーンアップされた後に、オブジェクト (つまり、オブジェクトにアクセスできるように再度) 復活させる方法を含む、ほぼすべてのアクションを実行することができます。</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>However, the object can only be resurrected once; <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> cannot be called on resurrected objects during garbage collection.</source>
          <target state="translated">ただし、オブジェクトできますのみ再生できるは 1 回です。<ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph>ガベージ コレクション中に再生されたオブジェクトで呼び出すことができません。</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>There is one action that your implementation of <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> should never take: it should never throw an exception.</source>
          <target state="translated">1 つのアクションがあることの実装<ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph>を渡す必要があります: が例外をスローする必要がありますしません。</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>If any exceptions thrown by methods called from the <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method are unhandled by the <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> method, the runtime assumes that the <ph id="ph3">&lt;xref:System.Object.Finalize%2A&gt;</ph> method returned and continues to call the <ph id="ph4">&lt;xref:System.Object.Finalize%2A&gt;</ph> methods of other objects.</source>
          <target state="translated">メソッドによってスローされた例外が呼び出された場合、<ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph>メソッドがで処理されない、<ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph>メソッド、ランタイムが想定する、<ph id="ph3">&lt;xref:System.Object.Finalize%2A&gt;</ph>メソッドが返され、呼び出しは引き続き、<ph id="ph4">&lt;xref:System.Object.Finalize%2A&gt;</ph>他のオブジェクトのメソッドです。</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The SafeHandle alternative</source>
          <target state="translated">代替手段としての SafeHandle</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>Creating reliable finalizers is often difficult, because you cannot make assumptions about the state of your application, and because unhandled system exceptions such as <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> and <ph id="ph2">&lt;xref:System.StackOverflowException&gt;</ph> terminate the finalizer.</source>
          <target state="translated">信頼性の高いファイナライザーの作成が多くの場合、困難ですが、アプリケーションの状態に関する仮定をすることはできないためなど、未処理のシステム例外<ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph>と<ph id="ph2">&lt;xref:System.StackOverflowException&gt;</ph>ファイナライザーを終了します。</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>Instead of implementing a finalizer for your class to release unmanaged resources, you can use an object that is derived from the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType&gt;</ph> class to wrap your unmanaged resources, and then implement the dispose pattern without a finalizer.</source>
          <target state="translated">派生したオブジェクトを使用するアンマネージ リソースを解放するには、クラスのファイナライザーを実装するには、代わりに、<ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType&gt;</ph>アンマネージ リソースをラップするクラスし、ファイナライザーせず、dispose パターンを実装します。</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The .NET Framework provides the following classes in the <ph id="ph1">&lt;xref:Microsoft.Win32?displayProperty=nameWithType&gt;</ph> namespace that are derived from <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType&gt;</ph>:</source>
          <target state="translated">.NET Framework の次のクラスには、<ph id="ph1">&lt;xref:Microsoft.Win32?displayProperty=nameWithType&gt;</ph>から派生した名前空間<ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType&gt;</ph>:</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source><ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeFileHandle&gt;</ph> is a wrapper class for a file handle.</source>
          <target state="translated"><ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeFileHandle&gt;</ph> ファイル ハンドルのラッパー クラスです。</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source><ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle&gt;</ph> is a wrapper class for memory-mapped file handles.</source>
          <target state="translated"><ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle&gt;</ph> メモリ マップト ファイル ハンドルのラッパー クラスです。</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source><ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle&gt;</ph> is a wrapper class for a pointer to a block of unmanaged memory.</source>
          <target state="translated"><ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle&gt;</ph> アンマネージ メモリ ブロックへのポインターのラッパー クラスです。</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source><ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle&gt;</ph>, <ph id="ph2">&lt;xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle&gt;</ph>, and <ph id="ph3">&lt;xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle&gt;</ph> are wrapper classes for cryptographic handles.</source>
          <target state="translated"><ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle&gt;</ph>、 <ph id="ph2">&lt;xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle&gt;</ph>、および<ph id="ph3">&lt;xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle&gt;</ph>暗号化ハンドルのラッパー クラスです。</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source><ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafePipeHandle&gt;</ph> is a wrapper class for pipe handles.</source>
          <target state="translated"><ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafePipeHandle&gt;</ph> パイプ ハンドルのラッパー クラスです。</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source><ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle&gt;</ph> is a wrapper class for a handle to a registry key.</source>
          <target state="translated"><ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle&gt;</ph> レジストリ キーへのハンドルのラッパー クラスです。</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source><ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeWaitHandle&gt;</ph> is a wrapper class for a wait handle.</source>
          <target state="translated"><ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeWaitHandle&gt;</ph> 待機ハンドルのラッパー クラスです。</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The following example uses the <bpt id="p1">[</bpt>dispose pattern<ept id="p1">](~/docs/standard/design-guidelines/dispose-pattern.md)</ept> with safe handles instead of overriding the <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method.</source>
          <target state="translated">次の例では、 <bpt id="p1">[</bpt>dispose パターン<ept id="p1">](~/docs/standard/design-guidelines/dispose-pattern.md)</ept>オーバーライドする代わりにセーフ ハンドルを使った、<ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>It defines a <ph id="ph1">`FileAssociation`</ph> class that wraps registry information about the application that handles files with a particular file extension.</source>
          <target state="translated">定義する、<ph id="ph1">`FileAssociation`</ph>特定のファイル拡張子を持つファイルを処理するアプリケーションのレジストリ情報をラップするクラス。</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The two registry handles returned as <ph id="ph1">`out`</ph> parameters by Windows <bpt id="p1">[</bpt>RegOpenKeyEx<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms724897.aspx)</ept> function calls are passed to the <ph id="ph2">&lt;xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle&gt;</ph> constructor.</source>
          <target state="translated">として返される 2 つのレジストリ ハンドル<ph id="ph1">`out`</ph>Windows によってパラメーター <bpt id="p1">[</bpt>RegOpenKeyEx<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms724897.aspx)</ept>関数の呼び出しに渡される、<ph id="ph2">&lt;xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle&gt;</ph>コンス トラクターです。</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The type's protected <ph id="ph1">`Dispose`</ph> method then calls the <ph id="ph2">`SafeRegistryHandle.Dispose`</ph> method  to free these two handles.</source>
          <target state="translated">型の保護された<ph id="ph1">`Dispose`</ph>メソッドを呼び出します、<ph id="ph2">`SafeRegistryHandle.Dispose`</ph>これら 2 つのハンドルを解放します。</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>The following example verifies that the <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method is called when an object that overrides <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> is destroyed.</source>
          <target state="translated">次の例では、あることを確認、<ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph>オブジェクトを上書きする場合に、メソッドが呼び出されます<ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph>は破棄されます。</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>Note that, in a production application, the <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method would be overridden to release unmanaged resources held by the object.</source>
          <target state="translated">なお、実稼働アプリケーションで、<ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph>オブジェクトによって保持されているアンマネージ リソースを解放するメソッドはオーバーライドされます。</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>Also note that the C# example provides a destructor instead of overriding the <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method.</source>
          <target state="translated">なお、c# の例にオーバーライドする代わりにデストラクターが提供されている、<ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.Finalize">
          <source>For an additional example that overrides the <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method, see the <ph id="ph2">&lt;xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">オーバーライドするその他の例については、<ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph>メソッドを参照してください、<ph id="ph2">&lt;xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" uid="M:System.Object.GetHashCode">
          <source>Serves as the default hash function.</source>
          <target state="translated">既定のハッシュ関数として機能します。</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" uid="M:System.Object.GetHashCode">
          <source>A hash code for the current object.</source>
          <target state="translated">現在のオブジェクトのハッシュ コード。</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>A hash code is a numeric value that is used to insert and identify an object in a hash-based collection such as the <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> class, the <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> class, or a type derived from the <ph id="ph3">&lt;xref:System.Collections.DictionaryBase&gt;</ph> class.</source>
          <target state="translated">ハッシュ コードを挿入し、などハッシュ ベースのコレクション内のオブジェクトの識別に使用される数値の値は、<ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph>クラス、<ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph>クラスから派生した型、または、<ph id="ph3">&lt;xref:System.Collections.DictionaryBase&gt;</ph>クラスです。</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>The <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> method provides this hash code for algorithms that need quick checks of object equality.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>を迅速にオブジェクトの等価性の確認を必要とするアルゴリズムのメソッドがこのハッシュ コードを提供します。</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>For information about how hash codes are used in hash tables and for some additional hash code algorithms, see the <bpt id="p1">[</bpt>Hash Function<ept id="p1">](https://en.wikipedia.org/wiki/Hash_function)</ept> entry in Wikipedia.</source>
          <target state="translated">ハッシュ テーブルのハッシュ コードを使用する方法に関する情報といくつか追加のハッシュ コードのアルゴリズムを参照してください、<bpt id="p1">[</bpt>ハッシュ関数<ept id="p1">](https://en.wikipedia.org/wiki/Hash_function)</ept>Wikipedia で入力します。</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Two objects that are equal return hash codes that are equal.</source>
          <target state="translated">等しいと同じ戻り値のハッシュ コードは、2 つのオブジェクト。</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>However, the reverse is not true: equal hash codes do not imply object equality, because different (unequal) objects can have identical hash codes.</source>
          <target state="translated">ただし、この逆はできません。 同じハッシュ コードを意味しませんオブジェクトの等価性 (等しくない) 別のオブジェクトが同一のハッシュ コードを持てないためです。</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Furthermore, the .NET Framework does not guarantee the default implementation of the <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> method, and the value this method returns may differ between .NET Framework versions and platforms, such as 32-bit and 64-bit platforms.</source>
          <target state="translated">さらに、.NET Framework とは限りませんの既定の実装、<ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>メソッド、および、このメソッドから返される値が異なる .NET Framework のバージョンとプラットフォームでは、32 ビットおよび 64 ビットのプラットフォームなどの間です。</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>For these reasons, do not use the default implementation of this method as a unique object identifier for hashing purposes.</source>
          <target state="translated">これらの理由から、このメソッドの既定の実装固有のオブジェクト識別子としてに使わないハッシュの目的でします。</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Two consequences follow from this:</source>
          <target state="translated">これから次の 2 つの影響。</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>You should not assume that equal hash codes imply object equality.</source>
          <target state="translated">同じハッシュ コードがオブジェクトの等価性を示すものであると想定する必要があります。</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>You should never persist or use a hash code outside the application domain in which it was created, because the same object may hash across application domains, processes, and platforms.</source>
          <target state="translated">永続化したり、同じオブジェクトをアプリケーション ドメイン、プロセス、およびプラットフォーム間でハッシュ可能性がありますのでが作成されたアプリケーション ドメインの外部ハッシュ コードを使用する必要がありますしないでください。</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>A hash code is intended for efficient insertion and lookup in collections that are based on a hash table.</source>
          <target state="translated">ハッシュ コードは、効率的な挿入とハッシュ テーブルに基づいているコレクション内の参照です。</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>A hash code is not a permanent value.</source>
          <target state="translated">ハッシュ コードは、永続的な値ではありません。</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>For this reason:</source>
          <target state="translated">このため。</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Do not serialize hash code values or store them in databases.</source>
          <target state="translated">ハッシュ コード値をシリアル化したり、データベースに格納しないでください。</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Do not use the hash code as the key to retrieve an object from a keyed collection.</source>
          <target state="translated">キー付きのコレクションからオブジェクトを取得するのに、キーとしてハッシュ コードを使用しません。</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Do not send hash codes across application domains or processes.</source>
          <target state="translated">アプリケーション ドメインまたはプロセス間では、ハッシュ コードを送信しません。</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>In some cases, hash codes may be computed on a per-process or per-application domain basis.</source>
          <target state="translated">場合によっては、プロセスごとまたはアプリケーションごとのドメインごとにハッシュ コードを計算することがあります。</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Do not use the hash code instead of a value returned by a cryptographic hashing function if you need a cryptographically strong hash.</source>
          <target state="translated">暗号強度が高いハッシュする必要がある場合は、暗号ハッシュ関数によって返される値ではなくハッシュ コードを使用しません。</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>For cryptographic hashes, use a class derived from the <ph id="ph1">&lt;xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType&gt;</ph> class.</source>
          <target state="translated">暗号法のハッシュから派生するクラスを使用して、<ph id="ph1">&lt;xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType&gt;</ph>または<ph id="ph2">&lt;xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType&gt;</ph>クラスです。</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Do not test for equality of hash codes to determine whether two objects are equal.</source>
          <target state="translated">2 つのオブジェクトが等しいかどうかを判断するハッシュ コードの等価性をテストしません。</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>(Unequal objects can have identical hash codes.) To test for equality, call the <ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph> method.</source>
          <target state="translated">(等しくないオブジェクトは、同一のハッシュ コードを持つことができます)等しいかどうかをテストするには、呼び出し、<ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph>または<ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>The <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> method can be overridden by a derived type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>派生型でメソッドをオーバーライドすることができます。</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>If <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> is not overridden, hash codes for reference types are computed by calling the <ph id="ph2">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> method of the base class, which computes a hash code based on an object's reference; for more information, see <ph id="ph3">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">場合<ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>がオーバーライドされていないハッシュ コードを呼び出すことによって計算が参照型、<ph id="ph2">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>ハッシュ コードを計算する、基本クラスのメソッド ベース以外のオブジェクトの参照の詳細についてを参照してください<ph id="ph3">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>In other words, two objects for which the <ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method returns <ph id="ph2">`true`</ph> have identical hash codes.</source>
          <target state="translated">つまり、2 つのオブジェクトを<ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph>メソッドを返します。<ph id="ph2">`true`</ph>同一のハッシュ コードがあります。</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>If value types do not override <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>, the <ph id="ph2">&lt;xref:System.ValueType.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> method of the base class uses reflection to compute the hash code based on the values of the type's fields.</source>
          <target state="translated">値の型をオーバーライドしない場合<ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>、<ph id="ph2">&lt;xref:System.ValueType.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>基底クラスのメソッドでは、リフレクションを使用して、型のフィールドの値に基づいてハッシュ コードを計算します。</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>In other words, value types whose fields have equal values have equal hash codes.</source>
          <target state="translated">つまり、その結果、フィールドが同じ値を持つ値型では、同じハッシュ コードがあります。</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>For more information about overriding <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>, see the "Notes to Inheritors" section.</source>
          <target state="translated">オーバーライドの詳細については<ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>、「ノート継承クラス」を参照してください。</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>If you override the <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> method, you should also override <ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph>, and vice versa.</source>
          <target state="translated">オーバーライドする場合、<ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>メソッドもオーバーライドする<ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph>、およびその逆です。</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>If your overridden <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> method returns <ph id="ph2">`true`</ph> when two objects are tested for equality, your overridden <ph id="ph3">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> method must return the same value for the two objects.</source>
          <target state="translated">場合、オーバーライドされた<ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph>メソッドを返します。<ph id="ph2">`true`</ph>等しいかどうかを、オーバーライドされた 2 つのオブジェクトをテストするときに<ph id="ph3">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>メソッドは、2 つのオブジェクトに対して同じ値を返す必要があります。</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>If an object that is used as a key in a hash table does not provide a useful implementation of <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>, you can specify a hash code provider by supplying an <ph id="ph2">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> implementation to one of the overloads of the <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph> class constructor.</source>
          <target state="translated">かどうか、ハッシュ テーブル内のキーとして使用されるオブジェクトの管轄外の便利な実装<ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>、ハッシュ コード プロバイダーを指定するには指定することによって、<ph id="ph2">&lt;xref:System.Collections.IEqualityComparer&gt;</ph>のオーバー ロードのいずれかに実装、<ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph>クラスのコンス トラクターです。</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Notes for the <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph></source>
          <target state="translated">は、 <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph></target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>When you call the <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> method on a class in the <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>, it provides the default behavior for classes that don’t override <ph id="ph3">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>.</source>
          <target state="translated">呼び出すと、<ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>内のクラスのメソッド、 <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>、しないをオーバーライドするクラスの既定の動作を提供<ph id="ph3">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>This is part of the support that the .NET Framework provides for the <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> (see <bpt id="p1">[</bpt>.NET Framework Support for Windows Store Apps and Windows Runtime<ept id="p1">](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)</ept>).</source>
          <target state="translated">これは、.NET Framework 提供するサポートの一部、 <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> (を参照してください<bpt id="p1">[</bpt>フレームワークをサポートして Windows ストア アプリ用 .NET と Windows ランタイム<ept id="p1">](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)</ept>)。</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Classes in the <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> don’t inherit <ph id="ph2">&lt;xref:System.Object&gt;</ph>, and currently don’t implement a <ph id="ph3">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>.</source>
          <target state="translated">内のクラス、<ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>継承しない<ph id="ph2">&lt;xref:System.Object&gt;</ph>、現在実装していないと、<ph id="ph3">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>However, they appear to have <ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>, and <ph id="ph3">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides the default behavior for these methods.</source>
          <target state="translated">ただし、それらがように見えます<ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph>、 <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>、および<ph id="ph3">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>メソッド、c# または Visual Basic コードで使用すると、.NET Framework では、これらのメソッドの既定の動作です。</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source><ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> classes that are written in C# or Visual Basic can override the <ph id="ph2">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> c# または Visual Basic で記述されたクラスをオーバーライドして、<ph id="ph2">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>One of the simplest ways to compute a hash code for a numeric value that has the same or a smaller range than the <ph id="ph1">&lt;xref:System.Int32&gt;</ph> type is to simply return that value.</source>
          <target state="translated">ハッシュ コードを同じか、またはより小さい範囲を持つ数値を計算する最も簡単な方法の 1 つ、<ph id="ph1">&lt;xref:System.Int32&gt;</ph>型が単純にその値を返すにします。</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>The following example shows such an implementation for a <ph id="ph1">`Number`</ph> structure.</source>
          <target state="translated">次の例では、このような実装、<ph id="ph1">`Number`</ph>構造体。</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Frequently, a type has multiple data fields that can participate in generating the hash code.</source>
          <target state="translated">多くの場合、型では、ハッシュ コードの生成に含めることができる複数のデータ フィールドがあります。</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>One way to generate a hash code is to combine these fields using an <ph id="ph1">`XOR (eXclusive OR)`</ph> operation, as shown in the following example.</source>
          <target state="translated">使用してこれらのフィールドを結合するにはハッシュ コードを生成する方法、<ph id="ph1">`XOR (eXclusive OR)`</ph>操作、次の例で示すようにします。</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>The previous example returns the same hash code for (n1, n2) and (n2, n1), and so may generate more collisions than are desirable.</source>
          <target state="translated">前の例は、(n1、n2) に対して同じハッシュ コードを返します (n2、n1)、および、要件を満たしているよりも多くの競合を生成する可能性があります。</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>A number of solutions are available so that hash codes in these cases are not identical.</source>
          <target state="translated">このような場合のハッシュ コードが同じでないようにソリューションの数のとおりです。</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>One is to return the hash code of a <ph id="ph1">`Tuple`</ph> object that reflects the order of each field.</source>
          <target state="translated">1 つのハッシュ コードを返すには、<ph id="ph1">`Tuple`</ph>の各フィールドの順序を反映するオブジェクト。</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>The following example shows a possible implementation that uses the <ph id="ph1">&lt;xref:System.Tuple%602&gt;</ph> class.</source>
          <target state="translated">次の例を使用して可能な実装を示しています、<ph id="ph1">&lt;xref:System.Tuple%602&gt;</ph>クラスです。</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Note, though, that the performance overhead of instantiating a <ph id="ph1">`Tuple`</ph> object may significantly impact the overall performance of an application that stores large numbers of objects in hash tables.</source>
          <target state="translated">ただしをインスタンス化のパフォーマンスのオーバーヘッドを<ph id="ph1">`Tuple`</ph>オブジェクトは、ハッシュ テーブルに多数のオブジェクトを格納するアプリケーションの全体的なパフォーマンスに大きく影響可能性があります。</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>A second alternative solution involves weighting the individual hash codes by left-shifting the hash codes of successive fields by two or more bits.</source>
          <target state="translated">2 番目の代替ソリューションには、連続するフィールドのハッシュ コードを 2 つ以上のビットを左シフトして個々 のハッシュ コードを重み付けが含まれます。</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Optimally, instead of being discarded, bits shifted beyond bit 31 should wrap around rather than be discarded.</source>
          <target state="translated">最適に、破棄されるのではなくを超えて 31 ビット シフトをラップする代わりに破棄されます。</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Since bits are discarded by the left-shift operators in both C# and Visual Basic, this requires creating a left shift-and-wrap method like the following:</source>
          <target state="translated">C# および Visual Basic の両方での左シフト演算子では、ビットが破棄され、以降は、次のように左 shift キーを押し、ラップ メソッドを作成する必要があります。</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>The following example then uses this shift-and-wrap method to compute the hash code of the <ph id="ph1">`Point`</ph> structure used in the previous examples.</source>
          <target state="translated">次の例は、のハッシュ コードを計算するこのシフトの折り返し方法を使用して、<ph id="ph1">`Point`</ph>前の例で使用される構造体。</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>A hash function is used to quickly generate a number (hash code) that corresponds to the value of an object.</source>
          <target state="translated">ハッシュ関数を使用して、オブジェクトの値に対応する番号 (ハッシュ コード) をすばやく生成します。</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Hash functions are usually specific to each type and, for uniqueness, must use at least one of the instance fields as input.</source>
          <target state="translated">ハッシュ関数は通常、各種類に固有しが、一意である必要があります少なくとも 1 つのインスタンス フィールドの入力として使用します。</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Hash codes should not be computed by using the values of static fields.</source>
          <target state="translated">静的フィールドの値を使用してハッシュ コードを計算する必要がありますされません。</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>For classes derived from <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph>, the <ph id="ph2">&lt;see langword="GetHashCode" /&gt;</ph> method can delegate to the base class <ph id="ph3">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> implementation only if the derived class defines equality to be reference equality.</source>
          <target state="translated">派生したクラスの<ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph>、<ph id="ph2">&lt;see langword="GetHashCode" /&gt;</ph>メソッドは、基底クラスに委任できます<ph id="ph3">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph>派生クラスには参照の等価性に等しいかどうかが定義されている場合にのみ実装されます。</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>The default implementation of <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> for reference types returns a hash code that is equivalent to the one returned by the <ph id="ph2">&lt;see cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" /&gt;</ph> method.</source>
          <target state="translated">既定の実装<ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph>参照の種類がによって返されたと等価のハッシュ コードを返します、<ph id="ph2">&lt;see cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" /&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>You can override <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> for immutable reference types.</source>
          <target state="translated">オーバーライドできます<ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph>変更不可の参照の種類。</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>In general, for mutable reference types, you should override <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> only if:</source>
          <target state="translated">一般に、変更可能な参照型の場合は、オーバーライドする<ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph>場合のみ。</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>You can compute the hash code from fields that are not mutable; or</source>
          <target state="translated">変更できません。 指定されたフィールドのハッシュ コードを計算することができます。または</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>You can ensure that the hash code of a mutable object does not change while the object is contained in a collection that relies on its hash code.</source>
          <target state="translated">オブジェクトがそのハッシュ コードに依存しているコレクションに含まれている間に、変更可能なオブジェクトのハッシュ コードが変更されないことを確認することができます。</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Otherwise, you might think that the mutable object is lost in the hash table.</source>
          <target state="translated">それ以外の場合、ハッシュ テーブルで変更可能なオブジェクトが失われることを検討する可能性があります。</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>If you do choose to override <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> for a mutable reference type, your documentation should make it clear that users of your type should not modify object values while the object is stored in a hash table.</source>
          <target state="translated">オーバーライドする場合は<ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph>変更可能な参照型の場合は、ドキュメント必要があることを明示するため、オブジェクトが、ハッシュ テーブルに格納されているときに、型のユーザーがオブジェクトの値を変更しないでください。</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>For value types, <ph id="ph1">&lt;see cref="M:System.ValueType.GetHashCode" /&gt;</ph> provides a default hash code implementation that uses reflection.</source>
          <target state="translated">値型の場合は、<ph id="ph1">&lt;see cref="M:System.ValueType.GetHashCode" /&gt;</ph>リフレクションを使用する既定のハッシュ コード実装を提供します。</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>You should consider overriding it for better performance.</source>
          <target state="translated">パフォーマンス向上のためにオーバーライドすることを検討する必要があります。</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>For more information and examples that compute hash codes in a variety of ways, see the Examples section.</source>
          <target state="translated">詳細とさまざまな方法でのハッシュ コードを計算する例については、「例」を参照してください。</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>A hash function must have the following properties:</source>
          <target state="translated">ハッシュ関数では、次のプロパティが必要です。</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>If two objects compare as equal, the <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> method for each object must return the same value.</source>
          <target state="translated">2 つのオブジェクトが等しいかどうか、として比較している場合、<ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph>の各オブジェクトのメソッドは、同じ値を返す必要があります。</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>However, if two objects do not compare as equal, the <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> methods for the two objects do not have to return different values.</source>
          <target state="translated">ただし、2 つのオブジェクトが等しいかどうか、として比較されない場合、 <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> 2 つのオブジェクトのメソッドは、異なる値を返す必要はありません。</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>The <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> method for an object must consistently return the same hash code as long as there is no modification to the object state that determines the return value of the object's <bpt id="p1">[</bpt>System.Object.Equals<ept id="p1">](xref:System.Object.Equals*)</ept> method.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph>メソッドは、オブジェクトがオブジェクトの戻り値を決定するオブジェクトの状態への変更がない限り、同じハッシュ コードを返す必要があります一貫して<bpt id="p1">[</bpt>System.Object.Equals<ept id="p1">](xref:System.Object.Equals*)</ept>メソッドです。</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Note that this is true only for the current execution of an application, and that a different hash code can be returned if the application is run again.</source>
          <target state="translated">アプリケーションの現在の実行にのみ true であるし、アプリケーションをもう一度実行する場合は別のハッシュ コードを返されることができますに注意してください。</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>For the best performance, a hash function should generate an even distribution for all input, including input that is heavily clustered.</source>
          <target state="translated">最高のパフォーマンスをハッシュ関数は頻度の高いクラスター化されている入力を含む、すべての入力に対して均等な分布を生成する必要があります。</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>An implication is that small modifications to object state should result in large modifications to the resulting hash code for best hash table performance.</source>
          <target state="translated">オブジェクトの状態に変更を加える必要がありますになる大きなハッシュ テーブルの最適なパフォーマンスの結果のハッシュ コード変更では、します。</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Hash functions should be inexpensive to compute.</source>
          <target state="translated">ハッシュ関数を計算する高価なすることはできません。</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>The <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> method should not throw exceptions.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph>メソッドが例外をスローする必要があります。</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>For example, the implementation of the <ph id="ph1">&lt;see cref="M:System.String.GetHashCode" /&gt;</ph> method provided by the <ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph> class returns identical hash codes for identical string values.</source>
          <target state="translated">実装など、<ph id="ph1">&lt;see cref="M:System.String.GetHashCode" /&gt;</ph>によって提供されるメソッド、<ph id="ph2">&lt;see cref="T:System.String" /&gt;</ph>クラスはまったく同じ文字列値の同一のハッシュ コードを返します。</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Therefore, two <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> objects return the same hash code if they represent the same string value.</source>
          <target state="translated">そのため、2 つ<ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>オブジェクトが同じ文字列値を表している場合、同じハッシュ コードを返します。</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Also, the method uses all the characters in the string to generate reasonably randomly distributed output, even when the input is clustered in certain ranges (for example, many users might have strings that contain only the lower 128 ASCII characters, even though a string can contain any of the 65,535 Unicode characters).</source>
          <target state="translated">また、メソッドを使用してすべての文字文字列の入力が特定の範囲にクラスター化された場合でも、ある程度ランダムに分散型の出力を生成する (たとえば、多くのユーザーがいなくても、下位 128 ASCII 文字のみを含む文字列を含めることが、文字列含めることができます、65,535 の Unicode 文字のいずれか)。</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Providing a good hash function on a class can significantly affect the performance of adding those objects to a hash table.</source>
          <target state="translated">クラスの適切なハッシュ関数を提供することができます著しく影響する場合、ハッシュ テーブルへのそれらのオブジェクトの追加のパフォーマンスです。</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>In a hash table with keys that provide a good implementation of a hash function, searching for an element takes constant time (for example, an O(1) operation).</source>
          <target state="translated">ハッシュ関数の適切な実装を提供するキーを持つハッシュ テーブル、要素の検索、(たとえば、o (1) 操作) の定数の時間がかかります。</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>In a hash table with a poor implementation of a hash function, the performance of a search depends on the number of items in the hash table (for example, an O(<ph id="ph1">`n`</ph>) operation, where <ph id="ph2">`n`</ph> is the number of items in the hash table).</source>
          <target state="translated">ハッシュ関数の不適切な実装でハッシュ テーブルの検索のパフォーマンスによって異なります、ハッシュ テーブル内の項目数 (たとえば、O (<ph id="ph1">`n`</ph>) 操作、場所<ph id="ph2">`n`</ph>ハッシュ テーブル内の項目の数です)。</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>A malicious user can input data that increases the number of collisions, which can significantly degrade the performance of applications that depend on hash tables, under the following conditions:</source>
          <target state="translated">悪意のあるユーザーには、次の条件下で、ハッシュ テーブルに依存するアプリケーションのパフォーマンスが大幅に低下の衝突の数が増加するデータを入力できます。</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>When hash functions produce frequent collisions.</source>
          <target state="translated">ときにハッシュ関数は、頻繁に競合を作成します。</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>When a large proportion of objects in a hash table produce hash codes that are equal or approximately equal to one another.</source>
          <target state="translated">ときに、ハッシュ テーブル内のオブジェクトの大部分が等しいか、互いにほぼ同じ数のハッシュ コードを生成します。</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>When users input the data from which the hash code is computed.</source>
          <target state="translated">ときにユーザーは、ハッシュ コードの計算元となるデータを入力します。</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetHashCode">
          <source>Derived classes that override <ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph> must also override <ph id="ph2">&lt;see cref="M:System.Object.Equals(System.Object)" /&gt;</ph> to guarantee that two objects considered equal have the same hash code; otherwise, the <ph id="ph3">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph> type might not work correctly.</source>
          <target state="translated">オーバーライドするクラスを派生<ph id="ph1">&lt;see cref="M:System.Object.GetHashCode" /&gt;</ph>もオーバーライドしなければなりません<ph id="ph2">&lt;see cref="M:System.Object.Equals(System.Object)" /&gt;</ph>等しいと見なされる 2 つのオブジェクトに同じハッシュ コードがあることを保証するためにそれ以外の場合、<ph id="ph3">&lt;see cref="T:System.Collections.Hashtable" /&gt;</ph>型が正しく動作しません。</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" uid="M:System.Object.GetType">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the current instance.</source>
          <target state="translated">現在のインスタンスの <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> を取得します。</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" uid="M:System.Object.GetType">
          <source>The exact runtime type of the current instance.</source>
          <target state="translated">現在のインスタンスの正確なランタイム型。</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetType">
          <source>Because <ph id="ph1">&lt;xref:System.Object?displayProperty=nameWithType&gt;</ph> is the base class for all types in the .NET Framework type system, the <ph id="ph2">&lt;xref:System.Object.GetType%2A&gt;</ph> method can be used to return <ph id="ph3">&lt;xref:System.Type&gt;</ph> objects that represent all .NET Framework types.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object?displayProperty=nameWithType&gt;</ph>の .NET Framework の型システムでは、すべての型の基底クラス、<ph id="ph2">&lt;xref:System.Object.GetType%2A&gt;</ph>を返すメソッドを使用できます<ph id="ph3">&lt;xref:System.Type&gt;</ph>すべての .NET Framework 型を表すオブジェクト。</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetType">
          <source>The .NET Framework recognizes the following five categories of types:</source>
          <target state="translated">.NET Framework には、次の 5 つの種類のカテゴリが認識されます。</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetType">
          <source>Classes, which are derived from <ph id="ph1">&lt;xref:System.Object?displayProperty=nameWithType&gt;</ph>,</source>
          <target state="translated">派生したクラス<ph id="ph1">&lt;xref:System.Object?displayProperty=nameWithType&gt;</ph>、</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetType">
          <source>Value types, which are derived from <ph id="ph1">&lt;xref:System.ValueType?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">派生した型の値<ph id="ph1">&lt;xref:System.ValueType?displayProperty=nameWithType&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetType">
          <source>Interfaces, which are derived from <ph id="ph1">&lt;xref:System.Object?displayProperty=nameWithType&gt;</ph> starting with the .NET Framework 2.0.</source>
          <target state="translated">派生したインターフェイス<ph id="ph1">&lt;xref:System.Object?displayProperty=nameWithType&gt;</ph>.NET Framework 2.0 を起動します。</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetType">
          <source>Enumerations, which are derived from <ph id="ph1">&lt;xref:System.Enum?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">派生した列挙体は、<ph id="ph1">&lt;xref:System.Enum?displayProperty=nameWithType&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetType">
          <source>Delegates, which are derived from <ph id="ph1">&lt;xref:System.MulticastDelegate?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">派生したデリゲート<ph id="ph1">&lt;xref:System.MulticastDelegate?displayProperty=nameWithType&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetType">
          <source>For two objects <ph id="ph1">`x`</ph> and <ph id="ph2">`y`</ph> that have identical runtime types, <ph id="ph3">`Object.ReferenceEquals(x.GetType(),y.GetType())`</ph> returns <ph id="ph4">`true`</ph>.</source>
          <target state="translated">2 つのオブジェクトの<ph id="ph1">`x`</ph>と<ph id="ph2">`y`</ph>同一のランタイム型がある<ph id="ph3">`Object.ReferenceEquals(x.GetType(),y.GetType())`</ph>返します<ph id="ph4">`true`</ph>です。</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetType">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Object.GetType%2A&gt;</ph> method with the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method to determine whether one numeric value is the same type as two other numeric values.</source>
          <target state="translated">次の例では、<ph id="ph1">&lt;xref:System.Object.GetType%2A&gt;</ph>メソッドを<ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph>メソッドを 1 つの数値が他の 2 つの数値の値と同じ型であるかどうかを判別します。</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetType">
          <source>To determine whether an object is a specific type, you can use your language's type comparison keyword or construct.</source>
          <target state="translated">オブジェクトがを特定の種類であるかどうかを判断するのには、言語の型の比較のキーワードを使用したりを構築できます。</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetType">
          <source>For example, you can use the <ph id="ph1">`TypeOf…Is`</ph> construct in Visual Basic or the <ph id="ph2">`is`</ph> keyword in C#.</source>
          <target state="translated">たとえば、使用することができます、 <ph id="ph1">`TypeOf…Is`</ph> Visual Basic で構築または<ph id="ph2">`is`</ph>c# のキーワードです。</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetType">
          <source>The <ph id="ph1">&lt;xref:System.Object.GetType%2A&gt;</ph> method is inherited by all types that derive from <ph id="ph2">&lt;xref:System.Object&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.GetType%2A&gt;</ph>から派生したすべての型によって継承されたメソッド<ph id="ph2">&lt;xref:System.Object&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetType">
          <source>This means that, in addition to using your own language's comparison keyword, you can use the <ph id="ph1">&lt;xref:System.Object.GetType%2A&gt;</ph> method to determine the type of a particular object, as the following example shows.</source>
          <target state="translated">これは、比較の独自言語のキーワードを使用して、に加えて使用できることを意味、<ph id="ph1">&lt;xref:System.Object.GetType%2A&gt;</ph>メソッドを次の例のように、特定のオブジェクトの種類を決定します。</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetType">
          <source>The <ph id="ph1">&lt;xref:System.Type&gt;</ph> object exposes the metadata associated with the class of the current <ph id="ph2">&lt;xref:System.Object&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type&gt;</ph>オブジェクトは、現在のクラスに関連付けられているメタデータを公開<ph id="ph2">&lt;xref:System.Object&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.GetType">
          <source>The following code example demonstrates that <ph id="ph1">&lt;xref:System.Object.GetType%2A&gt;</ph> returns the runtime type of the current instance.</source>
          <target state="translated">次のコード例では、ことを示します<ph id="ph1">&lt;xref:System.Object.GetType%2A&gt;</ph>現在のインスタンスのランタイム型を返します。</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" uid="M:System.Object.MemberwiseClone">
          <source>Creates a shallow copy of the current <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph>.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> の簡易コピーを作成します。</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" uid="M:System.Object.MemberwiseClone">
          <source>A shallow copy of the current <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph>.</source>
          <target state="translated">現在の <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> の簡易コピー。</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>The <ph id="ph1">&lt;xref:System.Object.MemberwiseClone%2A&gt;</ph> method creates a shallow copy by creating a new object, and then copying the nonstatic fields of the current object to the new object.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.MemberwiseClone%2A&gt;</ph>メソッドでは、シャロー コピーを作成して新しいオブジェクトの作成を新しいオブジェクトに現在のオブジェクトの非静的フィールドをコピーします。</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>If a field is a value type, a bit-by-bit copy of the field is performed.</source>
          <target state="translated">フィールドが値型の場合、フィールドのビットごとのコピーは実行されます。</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>If a field is a reference type, the reference is copied but the referred object is not; therefore, the original object and its clone refer to the same object.</source>
          <target state="translated">フィールドが参照型の場合、参照はコピーしますが、参照されるオブジェクトではありません。そのため、元のオブジェクトとその複製は、同じオブジェクトを参照します。</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>For example, consider an object called X that references objects A and B. Object B, in turn, references object C. A shallow copy of X creates new object X2 that also references objects A and B. In contrast, a deep copy of X creates a new object X2 that references the new objects A2 and B2, which are copies of A and B. B2, in turn, references the new object C2, which is a copy of C. The example illustrates the difference between a shallow and a deep copy operation.</source>
          <target state="translated">たとえば、オブジェクト A と B をさらに、参照の参照オブジェクト c です。 X と呼ばれるオブジェクトX の簡易コピーを作成もオブジェクト A と B を参照する新しいオブジェクト X2これに対し、X の詳細コピーが A2 と B2、A のコピーである新しいオブジェクトを参照する新しいオブジェクト X2 を作成し、B. B2 がさらに、c ドライブのコピーである新しいオブジェクト C2 を参照例は、shallow と詳細なコピー操作の違いを示しています。</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>There are numerous ways to implement a deep copy operation if the shallow copy operation performed by the <ph id="ph1">&lt;xref:System.Object.MemberwiseClone%2A&gt;</ph> method does not meet your needs.</source>
          <target state="translated">場合、シャロー コピー操作によって実行の詳細コピー操作を実装する方法はたくさんあります、<ph id="ph1">&lt;xref:System.Object.MemberwiseClone%2A&gt;</ph>ニーズを満たしていないメソッドです。</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>These include the following:</source>
          <target state="translated">次に例を示します。</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>Call a class constructor of the object to be copied to create a second object with property values taken from the first object.</source>
          <target state="translated">コピーを最初のオブジェクトから取得したプロパティ値を持つ 2 番目のオブジェクトを作成するオブジェクトのクラスのコンス トラクターを呼び出します。</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>This assumes that the values of an object are entirely defined by its class constructor.</source>
          <target state="translated">これは、クラス コンス トラクターによって、オブジェクトの値がまったく定義されていると仮定します。</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>Call the <ph id="ph1">&lt;xref:System.Object.MemberwiseClone%2A&gt;</ph> method to create a shallow copy of an object, and then assign new objects whose values are the same as the original object to any properties or fields whose values are reference types.</source>
          <target state="translated">呼び出す、<ph id="ph1">&lt;xref:System.Object.MemberwiseClone%2A&gt;</ph>メソッドをオブジェクトのシャロー コピーを作成し、そのプロパティまたはフィールドの値を持つ参照型を元のオブジェクトと同じ値が新しいオブジェクトを割り当てます。</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>The <ph id="ph1">`DeepCopy`</ph> method in the example illustrates this approach.</source>
          <target state="translated"><ph id="ph1">`DeepCopy`</ph>メソッドの例では、この方法を示しています。</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>Serialize the object to be deep copied, and then restore the serialized data to a different object variable.</source>
          <target state="translated">コピーするには、深くするオブジェクトをシリアル化し、別のオブジェクト変数をシリアル化されたデータを復元します。</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>Use reflection with recursion to perform the deep copy operation.</source>
          <target state="translated">再帰ではリフレクションを使用して、詳細なコピー操作を実行します。</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>The following example illustrates the <ph id="ph1">&lt;xref:System.Object.MemberwiseClone%2A&gt;</ph> method.</source>
          <target state="translated">次の例を示しています、<ph id="ph1">&lt;xref:System.Object.MemberwiseClone%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>It defines a <ph id="ph1">`ShallowCopy`</ph> method that calls the <ph id="ph2">&lt;xref:System.Object.MemberwiseClone%2A&gt;</ph> method to perform a shallow copy operation on a <ph id="ph3">`Person`</ph> object.</source>
          <target state="translated">定義する、<ph id="ph1">`ShallowCopy`</ph>メソッドを呼び出す、<ph id="ph2">&lt;xref:System.Object.MemberwiseClone%2A&gt;</ph>シャロー コピー操作を実行するメソッド、<ph id="ph3">`Person`</ph>オブジェクト。</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>It also defines a <ph id="ph1">`DeepCopy`</ph> method that performs a deep copy operation on a <ph id="ph2">`Person`</ph> object.</source>
          <target state="translated">定義、<ph id="ph1">`DeepCopy`</ph>のディープ コピー操作を実行するメソッド、<ph id="ph2">`Person`</ph>オブジェクト。</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>In this example, the <ph id="ph1">`Person.IdInfo`</ph> property returns an <ph id="ph2">`IdInfo`</ph> object.</source>
          <target state="translated">この例では、<ph id="ph1">`Person.IdInfo`</ph>プロパティから返される、<ph id="ph2">`IdInfo`</ph>オブジェクト。</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>As the output from the example shows, when a <ph id="ph1">`Person`</ph> object is cloned by calling the <ph id="ph2">&lt;xref:System.Object.MemberwiseClone%2A&gt;</ph> method, the cloned <ph id="ph3">`Person`</ph> object is an independent copy of the original object, except that they share the same <ph id="ph4">`Person.IdInfo`</ph> object reference.</source>
          <target state="translated">例から出力としてときに、<ph id="ph1">`Person`</ph>オブジェクトを呼び出すことによって複製、<ph id="ph2">&lt;xref:System.Object.MemberwiseClone%2A&gt;</ph>メソッドは、複製された<ph id="ph3">`Person`</ph>同じを共有する点を除いて、オブジェクトは、元のオブジェクトの独立したコピー<ph id="ph4">`Person.IdInfo`</ph>オブジェクト参照。</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>As a result, modifying the clone's <ph id="ph1">`Person.IdInfo`</ph> property changes the original object's <ph id="ph2">`Person.IdInfo`</ph> property.</source>
          <target state="translated">その結果、変更、複製の<ph id="ph1">`Person.IdInfo`</ph>プロパティには、元のオブジェクトが変更された<ph id="ph2">`Person.IdInfo`</ph>プロパティです。</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.MemberwiseClone">
          <source>On the other hand, when a deep copy operation is performed, the cloned <ph id="ph1">`Person`</ph> object, including its <ph id="ph2">`Person.IdInfo`</ph> property, can be modified without affecting the original object.</source>
          <target state="translated">その一方で、詳細なコピー操作が行われる場合、複製された<ph id="ph1">`Person`</ph>オブジェクトを含むその<ph id="ph2">`Person.IdInfo`</ph>プロパティは、元のオブジェクトの影響を与えずに変更できます。</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>The first object to compare.</source>
          <target state="translated">比較する最初のオブジェクト。</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>The second object  to compare.</source>
          <target state="translated">比較する 2 番目のオブジェクト。</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>Determines whether the specified <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> instances are the same instance.</source>
          <target state="translated">指定した複数の <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> インスタンスが同一インスタンスかどうかを判断します。</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="objA" /&gt;</ph> is the same instance as <ph id="ph3">&lt;paramref name="objB" /&gt;</ph> or if both are <bpt id="p1">**</bpt>null<ept id="p1">**</ept>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="objA" /&gt;</ph> が <ph id="ph3">&lt;paramref name="objB" /&gt;</ph> と同一のインスタンスである場合、または両方のインスタンスが <bpt id="p1">**</bpt>null<ept id="p1">**</ept> の場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。それ以外の場合は <ph id="ph4">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>Unlike the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> method and the equality operator, the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method cannot be overridden.</source>
          <target state="translated">異なり、<ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph>メソッドおよび等値演算子、<ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph>メソッドをオーバーライドすることはできません。</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>Because of this, if you want to test two object references for equality and you are unsure about the implementation of the <ph id="ph1">`Equals`</ph> method, you can call the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method.</source>
          <target state="translated">このためをテストする場合は、2 つのオブジェクトが等しいかどうかを参照していないの実装に関することを確認して、<ph id="ph1">`Equals`</ph>メソッドが呼び出すことができます、<ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>However, the return value of the <ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method may appear to be anomalous in these two scenarios:</source>
          <target state="translated">ただし、戻り値の<ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph>メソッドは、これら 2 つのシナリオで異常なできるように表示される可能性があります。</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>When comparing value types.</source>
          <target state="translated">ときに、値の型を比較します。</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>If <ph id="ph1">`objA`</ph> and <ph id="ph2">`objB`</ph> are value types, they are boxed before they are passed to the <ph id="ph3">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method.</source>
          <target state="translated">場合<ph id="ph1">`objA`</ph>と<ph id="ph2">`objB`</ph>は、値の型に渡される前にボックス化されている、<ph id="ph3">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>This means that if both <ph id="ph1">`objA`</ph> and <ph id="ph2">`objB`</ph> represent the same instance of a value type, the <ph id="ph3">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method nevertheless returns <ph id="ph4">`false`</ph>, as the following example shows.</source>
          <target state="translated">つまり、この両方<ph id="ph1">`objA`</ph>と<ph id="ph2">`objB`</ph>値の型の同じインスタンスを表す、<ph id="ph3">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph>メソッドを返しますそれにもかかわらず<ph id="ph4">`false`</ph>次の例に示すように、します。</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>For information on boxing value types, see <bpt id="p1">[</bpt>Boxing and Unboxing<ept id="p1">](~/docs/csharp/programming-guide/types/boxing-and-unboxing.md)</ept>.</source>
          <target state="translated">値の型をボックス化については、次を参照してください。<bpt id="p1">[</bpt>ボックス化とボックス化解除<ept id="p1">](~/docs/csharp/programming-guide/types/boxing-and-unboxing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>When comparing strings.</source>
          <target state="translated">文字列を比較する場合。</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>If <ph id="ph1">`objA`</ph> and <ph id="ph2">`objB`</ph> are strings, the <ph id="ph3">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method returns <ph id="ph4">`true`</ph> if the string is interned.</source>
          <target state="translated">場合<ph id="ph1">`objA`</ph>と<ph id="ph2">`objB`</ph>文字列、<ph id="ph3">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph>メソッドを返します。<ph id="ph4">`true`</ph>場合は、文字列がインターン プールに存在します。</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>It does not perform a test for value equality.</source>
          <target state="translated">値の等価性テストを行うことはできません。</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>In the following example, <ph id="ph1">`s1`</ph> and <ph id="ph2">`s2`</ph> are equal because they are two instances of a single interned string.</source>
          <target state="translated">次の例では、<ph id="ph1">`s1`</ph>と<ph id="ph2">`s2`</ph>は等しいためにが 1 つのインターン処理後の文字列の 2 つのインスタンス。</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>However, <ph id="ph1">`s3`</ph> and <ph id="ph2">`s4`</ph> are not equal, because although they are have identical string values, that string is not interned.</source>
          <target state="translated">ただし、<ph id="ph1">`s3`</ph>と<ph id="ph2">`s4`</ph>が等しくない、まったく同じ文字列値がありますは、その文字列がインターンいないためです。</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>For more information about string interning, see <ph id="ph1">&lt;xref:System.String.IsInterned%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">文字列インターンの使用の詳細については、次を参照してください。<ph id="ph1">&lt;xref:System.String.IsInterned%2A?displayProperty=nameWithType&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ReferenceEquals(System.Object,System.Object)">
          <source>The following example uses <ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> to determine if two objects are the same instance.</source>
          <target state="translated">次の例で<ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph>2 つのオブジェクトが同じインスタンスがかどうかを判断します。</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" uid="M:System.Object.ToString">
          <source>Returns a string that represents the current object.</source>
          <target state="translated">現在のオブジェクトを表す文字列を返します。</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" uid="M:System.Object.ToString">
          <source>A string that represents the current object.</source>
          <target state="translated">現在のオブジェクトを表す文字列。</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source><ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> is the major formatting method in the .NET Framework.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> .NET Framework のメソッドを書式設定、メジャーです。</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>It converts an object to its string representation so that it is suitable for display.</source>
          <target state="translated">表示に適したされるため、オブジェクトの文字列形式に変換されます。</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>(For information about formatting support in the .NET Framework, see <bpt id="p1">[</bpt>Formatting Types<ept id="p1">](~/docs/standard/base-types/formatting-types.md)</ept>.) Default implementations of the <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> method return the fully qualified name of the object's type.</source>
          <target state="translated">(.NET Framework のサポートを書式設定については、次を参照してください<bpt id="p1">[</bpt>型の書式設定<ept id="p1">](~/docs/standard/base-types/formatting-types.md)</ept>。)。既定の実装、<ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>メソッドがオブジェクトの型の完全修飾名を返します。</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>You may have reached this page by following the link from the member list of another type.</source>
          <target state="translated">別の型のメンバーの一覧からリンクからこのページを表示が可能性があります。</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>That is because that type does not override <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">これはその型をオーバーライドしないため<ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Instead, it inherits the functionality of the <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">代わりの機能を継承、<ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Types frequently override the <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> method to provide a more suitable string representation of a particular type.</source>
          <target state="translated">型は多くの場合、オーバーライド、<ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>特定の型の適切な文字列形式を指定するメソッド。</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Types also frequently overload the <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> method to provide support for format strings or culture-sensitive formatting.</source>
          <target state="translated">型でも頻繁にオーバー ロード、<ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>書式指定文字列またはカルチャの書式設定のサポートを提供するメソッド。</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>In this section:</source>
          <target state="translated">このセクションの内容:</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source><bpt id="p1">[</bpt>The default Object.ToString() method<ept id="p1">](#Default)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>既定の Object.ToString() メソッド<ept id="p1">](#Default)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source><bpt id="p1">[</bpt>Overriding the Object.ToString() method<ept id="p1">](#Overriding)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Object.ToString() メソッドのオーバーライド<ept id="p1">](#Overriding)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source><bpt id="p1">[</bpt>Overloading the ToString method<ept id="p1">](#Overloading)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>ToString メソッドをオーバー ロード<ept id="p1">](#Overloading)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source><bpt id="p1">[</bpt>Extending the Object.ToString method<ept id="p1">](#Extending)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Object.ToString メソッドを拡張します。<ept id="p1">](#Extending)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source><bpt id="p1">[</bpt>Notes for the Windows Runtime<ept id="p1">](#WinRT)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Windows ランタイムのメモ<ept id="p1">](#WinRT)</ept></target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>The default Object.ToString() method</source>
          <target state="translated">既定の Object.ToString() メソッド</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>The default implementation of the <ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph> method returns the fully qualified name of the type of the <ph id="ph2">&lt;xref:System.Object&gt;</ph>, as the following example shows.</source>
          <target state="translated">既定の実装、<ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph>メソッドの型の完全修飾名を返します、<ph id="ph2">&lt;xref:System.Object&gt;</ph>次の例を示します。</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Because <ph id="ph1">&lt;xref:System.Object&gt;</ph> is the base class of all reference types in the .NET Framework, this behavior is inherited by reference types that do not override the <ph id="ph2">&lt;xref:System.Object.ToString%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object&gt;</ph>すべての参照型の基本クラスは、.NET Framework でこの動作はオーバーライドしない参照型によって継承、<ph id="ph2">&lt;xref:System.Object.ToString%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>The following example illustrates this.</source>
          <target state="translated">次に例を示します。</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>It defines a class named <ph id="ph1">`Object1`</ph> that accepts the default implementation of all <ph id="ph2">&lt;xref:System.Object&gt;</ph> members.</source>
          <target state="translated">という名前のクラスが定義<ph id="ph1">`Object1`</ph>すべての既定の実装を受け入れる<ph id="ph2">&lt;xref:System.Object&gt;</ph>メンバー。</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Its <ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph> method returns the object's fully qualified type name.</source>
          <target state="translated">その<ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph>メソッド、オブジェクトの完全修飾型名を返します。</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Overriding the Object.ToString() method</source>
          <target state="translated">Object.ToString() メソッドのオーバーライド</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Types commonly override the <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> method to return a string that represents the object instance.</source>
          <target state="translated">型は通常、オーバーライド、<ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>オブジェクトのインスタンスを表す文字列を返すメソッド。</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>For example, the base types such as <ph id="ph1">&lt;xref:System.Char&gt;</ph>, <ph id="ph2">&lt;xref:System.Int32&gt;</ph>, and <ph id="ph3">&lt;xref:System.String&gt;</ph> provide <ph id="ph4">&lt;xref:System.Object.ToString%2A&gt;</ph> implementations that return the string form of the value that the object represents.</source>
          <target state="translated">たとえば、基本などの型<ph id="ph1">&lt;xref:System.Char&gt;</ph>、<ph id="ph2">&lt;xref:System.Int32&gt;</ph>と<ph id="ph3">&lt;xref:System.String&gt;</ph>提供<ph id="ph4">&lt;xref:System.Object.ToString%2A&gt;</ph>オブジェクトによって表される値の文字列形式を返す実装します。</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>The following example defines a class, <ph id="ph1">`Object2`</ph>, that overrides the <ph id="ph2">&lt;xref:System.Object.ToString%2A&gt;</ph> method to return the type name along with its value.</source>
          <target state="translated">次の例は、クラスを定義<ph id="ph1">`Object2`</ph>、オーバーライド、<ph id="ph2">&lt;xref:System.Object.ToString%2A&gt;</ph>とその値の型名を返すメソッド。</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>The following table lists the type categories in the .NET Framework and indicates whether or not they override the <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">次の表は、.NET Framework の型のカテゴリを一覧表示し、それらを上書きするかどうかどうかを示す、<ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Type category</source>
          <target state="translated">型のカテゴリ</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Overrides Object.ToString()</source>
          <target state="translated">Object.ToString() をオーバーライドします。</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Behavior</source>
          <target state="translated">動作</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Class</source>
          <target state="translated">クラス</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>n/a</source>
          <target state="translated">N/A</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>n/a</source>
          <target state="translated">N/A</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Structure</source>
          <target state="translated">構造体</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Yes (<ph id="ph1">&lt;xref:System.ValueType.ToString%2A?displayProperty=nameWithType&gt;</ph>)</source>
          <target state="translated">はい (<ph id="ph1">&lt;xref:System.ValueType.ToString%2A?displayProperty=nameWithType&gt;</ph>)</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Same as Object.ToString()</source>
          <target state="translated">Object.ToString() と同じ</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Enumeration</source>
          <target state="translated">列挙</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Yes (<ph id="ph1">&lt;xref:System.Enum.ToString?displayProperty=nameWithType&gt;</ph>)</source>
          <target state="translated">はい (<ph id="ph1">&lt;xref:System.Enum.ToString?displayProperty=nameWithType&gt;</ph>)</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>The member name</source>
          <target state="translated">メンバー名</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Interface</source>
          <target state="translated">Interface</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>n/a</source>
          <target state="translated">N/A</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Delegate</source>
          <target state="translated">Delegate</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>No</source>
          <target state="translated">×</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>n/a</source>
          <target state="translated">N/A</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>See the Notes to Inheritors section for additional information on overriding <ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph>.</source>
          <target state="translated">オーバーライドの詳細については、継承クラス」の注意を参照してください<ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Overloading the ToString method</source>
          <target state="translated">ToString メソッドをオーバー ロード</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>In addition to overriding the parameterless <ph id="ph1">&lt;xref:System.Object.ToString?displayProperty=nameWithType&gt;</ph> method, many types overload the <ph id="ph2">`ToString`</ph> method to provide versions of the method that accept parameters.</source>
          <target state="translated">パラメーターなしのオーバーライドをするだけでなく<ph id="ph1">&lt;xref:System.Object.ToString?displayProperty=nameWithType&gt;</ph>メソッド、さまざまな種類のオーバー ロード、<ph id="ph2">`ToString`</ph>メソッドのパラメーターを受け取るバージョンを指定するメソッド。</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Most commonly, this is done to provide support for variable formatting and culture-sensitive formatting.</source>
          <target state="translated">ほとんどの場合、この変数の書式とカルチャの書式設定のサポートを提供する行われます。</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>The following example overloads the <ph id="ph1">`ToString`</ph> method to return a result string that includes the value of various fields of an <ph id="ph2">`Automobile`</ph> class.</source>
          <target state="translated">次の例のオーバー ロード、<ph id="ph1">`ToString`</ph>のさまざまなフィールドの値を含む結果の文字列を返すメソッドを<ph id="ph2">`Automobile`</ph>クラスです。</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>It defines four format strings: G, which returns the model name and year; D, which returns the model name, year, and number of doors; C, which returns the model name, year, and number of cylinders; and A, which returns a string with all four field values.</source>
          <target state="translated">次の 4 つの書式指定文字列を定義します G、モデルの名前と年度; が返されます。D で、モデルの名前、year、および; のドアの数を返しますC で、モデルの名前、year、およびシリンダー; の数を返しますおよび A, と 4 つのフィールドの値の文字列が返されます。</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>The following example calls the overloaded <ph id="ph1">&lt;xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph> method to display culture-sensitive formatting of a currency value.</source>
          <target state="translated">次の例では、オーバー ロードされた<ph id="ph1">&lt;xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType&gt;</ph>カルチャが通貨値の書式を表示します。</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>For more information on format strings and culture-sensitive formatting, see <bpt id="p1">[</bpt>Formatting Types<ept id="p1">](~/docs/standard/base-types/formatting-types.md)</ept>.</source>
          <target state="translated">書式指定文字列とカルチャの書式設定の詳細については、次を参照してください。<bpt id="p1">[</bpt>型の書式設定<ept id="p1">](~/docs/standard/base-types/formatting-types.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>For the format strings supported by numeric values, see <bpt id="p1">[</bpt>Standard Numeric Format Strings<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> and <bpt id="p2">[</bpt>Custom Numeric Format Strings<ept id="p2">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>.</source>
          <target state="translated">書式指定文字列を数値でサポートされている、次を参照してください。<bpt id="p1">[</bpt>標準の数値書式指定文字列<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept>と<bpt id="p2">[</bpt>カスタム数値書式指定文字列<ept id="p2">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>For the format strings supported by date and time values, see <bpt id="p1">[</bpt>Standard Date and Time Format Strings<ept id="p1">](~/docs/standard/base-types/standard-date-and-time-format-strings.md)</ept> and <bpt id="p2">[</bpt>Custom Date and Time Format Strings<ept id="p2">](~/docs/standard/base-types/custom-date-and-time-format-strings.md)</ept>.</source>
          <target state="translated">日付と時刻の値でサポートされている書式指定文字列を参照してください。<bpt id="p1">[</bpt>標準の日付と時刻の書式指定文字列<ept id="p1">](~/docs/standard/base-types/standard-date-and-time-format-strings.md)</ept>と<bpt id="p2">[</bpt>カスタムの日付と時刻の書式指定文字列<ept id="p2">](~/docs/standard/base-types/custom-date-and-time-format-strings.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Extending the Object.ToString method</source>
          <target state="translated">Object.ToString メソッドを拡張します。</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Because a type inherits the default <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> method, you may find its behavior undesirable and want to change it.</source>
          <target state="translated">型が既定値を継承しているため<ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>メソッド、検索の動作が望ましくないしてを変更します。</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>This is particularly true of arrays and collection classes.</source>
          <target state="translated">これは特に、配列とコレクション クラスです。</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>While you may expect the <ph id="ph1">`ToString`</ph> method of an array or collection class to display the values of its members, it instead displays the type fully qualified type name, as the following example shows.</source>
          <target state="translated">期待したときに、<ph id="ph1">`ToString`</ph>メソッド配列またはコレクションのメンバーの値を表示するクラスの代わりに、型の完全修飾型名として表示例を示します。</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>You have several options to produce the result string that you'd like.</source>
          <target state="translated">希望する結果の文字列を生成するためにいくつかのオプションがあります。</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>If the type is an array, a collection object, or an object that implements the <ph id="ph1">&lt;xref:System.Collections.IEnumerable&gt;</ph> or <ph id="ph2">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> interfaces, you can enumerate its elements by using the <ph id="ph3">`foreach`</ph> statement in C# or the <ph id="ph4">`For Each...Next`</ph> construct in Visual Basic.</source>
          <target state="translated">型が、配列、コレクション オブジェクト、または実装するオブジェクトの場合、<ph id="ph1">&lt;xref:System.Collections.IEnumerable&gt;</ph>または<ph id="ph2">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph>インターフェイスを使用してその要素を列挙することができます、 <ph id="ph3">`foreach`</ph> (C#) ステートメント、または<ph id="ph4">`For Each...Next`</ph>Visual Basic で作成します。</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>If the class is not <ph id="ph1">`sealed`</ph> (in C#) or <ph id="ph2">`NotInheritable`</ph> (in Visual Basic), you can develop a wrapper class that inherits from the base class whose <ph id="ph3">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> method you want to customize.</source>
          <target state="translated">クラスがない場合<ph id="ph1">`sealed`</ph>(C# の場合) または<ph id="ph2">`NotInheritable`</ph>の基本クラスから継承するラッパー クラスを開発する (Visual Basic の場合) の<ph id="ph3">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>をカスタマイズする方法です。</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>At a minimum, this requires that you do the following:</source>
          <target state="translated">少なくとも次行う必要があります。</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Implement any necessary constructors.</source>
          <target state="translated">必要なコンス トラクターを実装します。</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Derived classes do not inherit their base class constructors.</source>
          <target state="translated">派生クラスでは、その基本クラスのコンス トラクターは継承されません。</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Override the <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> method to return the result string that you'd like.</source>
          <target state="translated">上書き、<ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>を希望する結果の文字列を返すメソッド。</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>The following example defines a wrapper class for the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> class.</source>
          <target state="translated">次の例のラッパー クラスを定義する、<ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph>クラスです。</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>It overrides the <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> method to display the value of each method of the collection rather than the fully qualified type name.</source>
          <target state="translated">も優先、<ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>完全修飾型名ではなく、コレクションの各メソッドの値を表示するメソッド。</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Develop an <bpt id="p1">[</bpt>extension method<ept id="p1">](~/docs/standard/design-guidelines/extension-methods.md)</ept> that returns the result string that you want.</source>
          <target state="translated">開発、<bpt id="p1">[</bpt>拡張メソッド<ept id="p1">](~/docs/standard/design-guidelines/extension-methods.md)</ept>かされる結果の文字列を返します。</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Note that you can't override the default <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> method in this way (that is, your extension class (in C#) or module (in Visual Basic) cannot have a parameterless method named <ph id="ph2">`ToString`</ph> that is called in place of the original type's <ph id="ph3">`ToString`</ph> method.</source>
          <target state="translated">既定値をオーバーライドすることはできません注<ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>この方法でメソッド (拡張機能クラス (c#) または (Visual Basic) のモジュールがという名前のパラメーターのないメソッドを持つことはできません、<ph id="ph2">`ToString`</ph>元の型の代わりに呼び出される<ph id="ph3">`ToString`</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>You'll have to provide some other name for your parameterless <ph id="ph1">`ToString`</ph> replacement.</source>
          <target state="translated">パラメーターなしの他のいくつかの名前を指定する必要があります<ph id="ph1">`ToString`</ph>置換します。</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>The following example defines two methods that extend the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> class: a parameterless <ph id="ph2">`ToString2`</ph> method, and a <ph id="ph3">`ToString`</ph> method with a <ph id="ph4">&lt;xref:System.String&gt;</ph> parameter that represents a format string.</source>
          <target state="translated">次の例を拡張する 2 つのメソッドを定義する、<ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph>クラス: パラメーターのない<ph id="ph2">`ToString2`</ph>メソッド、および<ph id="ph3">`ToString`</ph>メソッドを<ph id="ph4">&lt;xref:System.String&gt;</ph>書式指定文字列を表すパラメーター。</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Notes for the <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph></source>
          <target state="translated">は、 <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph></target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>When you call the <ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph> method on a class in the <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>, it provides the default behavior for classes that don’t override <ph id="ph3">&lt;xref:System.Object.ToString%2A&gt;</ph>.</source>
          <target state="translated">呼び出すと、<ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph>内のクラスのメソッド、 <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>、しないをオーバーライドするクラスの既定の動作を提供<ph id="ph3">&lt;xref:System.Object.ToString%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>This is part of the support that the .NET Framework provides for the <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> (see <bpt id="p1">[</bpt>.NET Framework Support for Windows Store Apps and Windows Runtime<ept id="p1">](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)</ept>).</source>
          <target state="translated">これは、.NET Framework 提供するサポートの一部、 <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> (を参照してください<bpt id="p1">[</bpt>フレームワークをサポートして Windows ストア アプリ用 .NET と Windows ランタイム<ept id="p1">](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)</ept>)。</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Classes in the <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> don’t inherit <ph id="ph2">&lt;xref:System.Object&gt;</ph>, and don’t always implement a <ph id="ph3">&lt;xref:System.Object.ToString%2A&gt;</ph>.</source>
          <target state="translated">内のクラス、<ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>継承しない<ph id="ph2">&lt;xref:System.Object&gt;</ph>、常に実装していないと、<ph id="ph3">&lt;xref:System.Object.ToString%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>However, they always appear to have <ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>, and <ph id="ph3">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides a default behavior for these methods.</source>
          <target state="translated">ただし、常に現れるが<ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph>、<ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>と<ph id="ph3">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>メソッド、c# または Visual Basic コードで使用すると、.NET Framework では、これらのメソッドの既定の動作です。</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v451](~/includes/net-v451-md.md)]</ph>, the common language runtime will use <bpt id="p1">[</bpt>IStringable.ToString<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)</ept> on a <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> object before falling back to the default implementation of <ph id="ph3">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">以降で、 <ph id="ph1">[!INCLUDE[net_v451](~/includes/net-v451-md.md)]</ph>、共通言語ランタイムを使用して<bpt id="p1">[</bpt>IStringable.ToString<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)</ept>上、<ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>の既定の実装に戻る前にオブジェクト<ph id="ph3">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source><ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> classes that are written in C# or Visual Basic can override the <ph id="ph2">&lt;xref:System.Object.ToString%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> c# または Visual Basic で記述されたクラスをオーバーライドして、<ph id="ph2">&lt;xref:System.Object.ToString%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>The <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> and the IStringable Interface</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>と IStringable インターフェイス</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Starting with <ph id="ph1">[!INCLUDE[win81](~/includes/win81-md.md)]</ph>, the <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> includes an <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> interface whose single method, <bpt id="p2">[</bpt>IStringable.ToString<ept id="p2">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)</ept>, provides basic formatting support comparable to that provided by <ph id="ph3">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">以降で<ph id="ph1">[!INCLUDE[win81](~/includes/win81-md.md)]</ph>、<ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>が含まれています、 <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept>が 1 つのメソッドをインターフェイス<bpt id="p2">[</bpt>IStringable.ToString<ept id="p2">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)</ept>で提供される比較可能な基本の書式設定のサポートを提供<ph id="ph3">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>To prevent ambiguity, you should not implement <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> on managed types.</source>
          <target state="translated">あいまいさを回避するのには実装しないでください<bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept>マネージ型にします。</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>When managed objects are called by native code or by code written in languages such as JavaScript or C++/CX, they appear to implement <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept>.</source>
          <target state="translated">ネイティブ コードまたは JavaScript または C++ などの言語で記述されたコードでのマネージ オブジェクトが呼び出されるタイミング + CX、表示される実装<bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept>です。</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>The common language runtime will automatically route calls from <bpt id="p1">[</bpt>IStringable.ToString<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)</ept> to <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> in the event <bpt id="p2">[</bpt>IStringable<ept id="p2">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> is not implemented on the managed object.</source>
          <target state="translated">共通言語ランタイムはからの呼び出しに自動的にルーティング<bpt id="p1">[</bpt>IStringable.ToString<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)</ept>に<ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>イベント<bpt id="p2">[</bpt>IStringable<ept id="p2">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept>がマネージ オブジェクトでは実装されていません。</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Because the common language runtime auto-implements <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> for all managed types in <ph id="ph1">[!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)]</ph> apps, we recommend that you do not provide your own <bpt id="p2">[</bpt>IStringable<ept id="p2">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> implementation.</source>
          <target state="translated">共通言語ランタイムの自動実装<bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept>内の型のすべての管理<ph id="ph1">[!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)]</ph>アプリでは、ことをお勧めするを指定しない独自<bpt id="p2">[</bpt>IStringable<ept id="p2">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept>実装します。</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Implementing <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> may result in unintended behavior when calling <ph id="ph1">`ToString`</ph> from the <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>, C++/CX, or JavaScript.</source>
          <target state="translated">実装する<bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept>を呼び出すときに予期しない動作で発生する可能性があります<ph id="ph1">`ToString`</ph>から、 <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>C + +/CX、または JavaScript。</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>If you do choose to implement <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> in a public managed type that is exported in a <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> component, the following restrictions apply:</source>
          <target state="translated">実装することを選択する場合<bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept>でエクスポートしたパブリック マネージ型の<ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>コンポーネント、次の制限が適用されます。</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>You can define the <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> interface only in a "class implements" relationship, such as</source>
          <target state="translated">定義することができます、 <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept>など、「クラスが実装する」関係でしかインターフェイス</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>in C#, or</source>
          <target state="translated">C# では、上記のようになります。</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>in Visual Basic.</source>
          <target state="translated">Visual Basic では、上記のようになります。</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>You cannot implement <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> on an interface.</source>
          <target state="translated">実装することはできません<bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept>インターフェイスでします。</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>You cannot declare a parameter to be of type <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept>.</source>
          <target state="translated">型のパラメーターを宣言することはできません<bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept>です。</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source><bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> cannot be the return type of a method, property, or field.</source>
          <target state="translated"><bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept>メソッド、プロパティ、またはフィールドの戻り値の型にすることはできません。</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>You cannot hide your <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> implementation from base classes by using a method definition such as the following:</source>
          <target state="translated">非表示にすることはできません、 <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept>実装を次のようなメソッド定義を使用して、基本クラスから。</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Instead, the <bpt id="p1">[</bpt>IStringable.ToString<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)</ept> implementation must always override the base class implementation.</source>
          <target state="translated">代わりに、 <bpt id="p1">[</bpt>IStringable.ToString<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)</ept>実装は、基本クラスの実装を常にオーバーライドする必要があります。</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>You can hide a <ph id="ph1">`ToString`</ph> implementation only by invoking it on a strongly typed class instance.</source>
          <target state="translated"><ph id="ph1">`ToString`</ph> の実装を隠すことができるのは、厳密に型指定されたクラス インスタンスで呼び出す場合だけです。</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Note that under a variety of conditions, calls from native code to a managed type that implements <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> or hides its <bpt id="p2">[</bpt>ToString<ept id="p2">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)</ept> implementation can produce unexpected behavior.</source>
          <target state="translated">なお、さまざまな条件を実装するマネージ型をネイティブ コードから呼び出す<bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept>を表示または非その<bpt id="p2">[</bpt>ToString<ept id="p2">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)</ept>実装は、予期しない動作を引き起こすことができます。</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>When you implement your own types, you should override the <ph id="ph1">&lt;see cref="M:System.Object.ToString" /&gt;</ph> method to return values that are meaningful for those types.</source>
          <target state="translated">オーバーライドする必要があります、独自の型を実装するときに、<ph id="ph1">&lt;see cref="M:System.Object.ToString" /&gt;</ph>の種類に対して意味のある値を返すメソッド。</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Derived classes that require more control over formatting than <ph id="ph1">&lt;see cref="M:System.Object.ToString" /&gt;</ph> provides can implement the <ph id="ph2">&lt;see cref="T:System.IFormattable" /&gt;</ph> interface.</source>
          <target state="translated">も書式指定より詳細に制御を必要とするクラスを派生<ph id="ph1">&lt;see cref="M:System.Object.ToString" /&gt;</ph>提供実装できる、<ph id="ph2">&lt;see cref="T:System.IFormattable" /&gt;</ph>インターフェイスです。</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Its <ph id="ph1">&lt;see cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)" /&gt;</ph> method enables you to define format strings that control formatting and to use an <ph id="ph2">&lt;see cref="T:System.IFormatProvider" /&gt;</ph> object that can provide for culture-specific formatting.</source>
          <target state="translated">その<ph id="ph1">&lt;see cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)" /&gt;</ph>メソッドを使用する書式を制御する書式指定文字列を定義し、使用すると、<ph id="ph2">&lt;see cref="T:System.IFormatProvider" /&gt;</ph>カルチャに固有の書式設定するために提供できるオブジェクト。</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Overrides of the <ph id="ph1">&lt;see cref="M:System.Object.ToString" /&gt;</ph> method should follow these guidelines:</source>
          <target state="translated">上書きが、<ph id="ph1">&lt;see cref="M:System.Object.ToString" /&gt;</ph>メソッドが次のガイドラインに従う必要があります。</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>The returned string should be friendly and readable by humans.</source>
          <target state="translated">返される文字列は、わかりやすい、人間が判読できるにする必要があります。</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>The returned string should uniquely identify the value of the object instance.</source>
          <target state="translated">返される文字列は、オブジェクトのインスタンスの値を一意に識別する必要があります。</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>The returned string should be as short as possible so that it is suitable for display by a debugger.</source>
          <target state="translated">返される文字列は、できるように、デバッガーによって表示に適していますできるだけ短くする必要があります。</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Your <ph id="ph1">&lt;see cref="M:System.Object.ToString" /&gt;</ph> override should not return <ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph> or a null string.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Object.ToString" /&gt;</ph>オーバーライドを返さないでください<ph id="ph2">&lt;see cref="F:System.String.Empty" /&gt;</ph>または null 文字列です。</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Your <ph id="ph1">&lt;see cref="M:System.Object.ToString" /&gt;</ph> override should not throw an exception.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Object.ToString" /&gt;</ph>オーバーライドが例外をスローする必要があります。</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>If the string representation of an instance is culture-sensitive or can be formatted in multiple ways, implement the <ph id="ph1">&lt;see cref="T:System.IFormattable" /&gt;</ph> interface.</source>
          <target state="translated">インスタンスの文字列形式をカルチャに依存、いくつかの方法でフォーマットできる場合は、実装、<ph id="ph1">&lt;see cref="T:System.IFormattable" /&gt;</ph>インターフェイスです。</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>If the returned string includes sensitive information, you should first demand an appropriate permission.</source>
          <target state="translated">返される文字列には、機密情報が含まれている場合は、適切なアクセス許可をまず要求する必要があります。</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>If the demand succeeds, you can return the sensitive information; otherwise, you should return a string that excludes the sensitive information.</source>
          <target state="translated">要求が成功した場合、機密情報を返すことができます。それ以外の場合、機密情報を除外する文字列を返す必要があります。</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>Your <ph id="ph1">&lt;see cref="M:System.Object.ToString" /&gt;</ph> override should have no observable side effects to avoid complications in debugging.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Object.ToString" /&gt;</ph>上書きには、デバッグで複雑さを回避する副作用はありません。</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>For example, a call to the <ph id="ph1">&lt;see cref="M:System.Object.ToString" /&gt;</ph> method should not change the value of instance fields.</source>
          <target state="translated">呼び出しなど、<ph id="ph1">&lt;see cref="M:System.Object.ToString" /&gt;</ph>メソッドはインスタンス フィールドの値を変更しないでください。</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Object.ToString">
          <source>If your type implements a parsing method (or <ph id="ph1">&lt;see langword="Parse" /&gt;</ph> or <ph id="ph2">&lt;see langword="TryParse" /&gt;</ph> method, a constructor, or some other static method that instantiates an instance of the type from a string), you should ensure that the string returned by the <ph id="ph3">&lt;see cref="M:System.Object.ToString" /&gt;</ph> method can be converted to an object instance.</source>
          <target state="translated">種類を解析メソッドを実装する場合 (または<ph id="ph1">&lt;see langword="Parse" /&gt;</ph>または<ph id="ph2">&lt;see langword="TryParse" /&gt;</ph>メソッド、コンス トラクター、または文字列から型のインスタンスをインスタンス化するいくつか他の静的メソッド)、によって返される文字列をようにする必要があります、<ph id="ph3">&lt;see cref="M:System.Object.ToString" /&gt;</ph>メソッドを指定できますオブジェクトのインスタンスに変換されます。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>